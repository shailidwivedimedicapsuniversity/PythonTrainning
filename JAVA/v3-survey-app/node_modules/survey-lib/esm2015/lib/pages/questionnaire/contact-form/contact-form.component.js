/**
 * @fileoverview added by tsickle
 * Generated from: lib/pages/questionnaire/contact-form/contact-form.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input } from '@angular/core';
import { Question } from '../../pages.model';
import { FormControl, FormGroup, Validators } from '@angular/forms';
import { PagesService } from '../../../shared/pages-services/pages.service';
export class ContactFormComponent {
    /**
     * @param {?} pagesService
     */
    constructor(pagesService) {
        this.pagesService = pagesService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.createForm();
    }
    /**
     * @return {?}
     */
    createForm() {
        /** @type {?} */
        const formGroup = {};
        for (let prop of Object.keys(this.contactForm.contactForm)) {
            formGroup[prop] = new FormControl(this.contactForm.contactForm[prop].value || '', ContactFormComponent.mapValidators(this.contactForm.contactForm[prop].validation));
        }
        this.form = new FormGroup(formGroup);
    }
    /**
     * @private
     * @param {?} validators
     * @return {?}
     */
    static mapValidators(validators) {
        /** @type {?} */
        const formValidators = [];
        if (validators) {
            for (const validation of Object.keys(validators)) {
                if (validation === 'required') {
                    formValidators.push(Validators.required);
                }
                else if (validation === 'min') {
                    formValidators.push(Validators.min(validators[validation]));
                }
            }
        }
        return formValidators;
    }
    /**
     * @return {?}
     */
    onSubmit() {
        this.response.contactInfo = this.objectProps;
        this.response.questionId = this.contactForm.questionId;
        this.pagesService.persistSurvey(this.response);
        //console.log(this.dataObject);
        /*  for (let controlsKey in this.form.controls) {
            this.dataObject[controlsKey].value = form[controlsKey];
          }
          console.log(this.dataObject);
          this.response.questionId = this.contactForm.questionId;*/
        //this.response.contactInfo
    }
}
ContactFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'app-contact-form',
                template: "\n<div>\n\n  <form novalidate (ngSubmit)=\"onSubmit()\" [formGroup]=\"form\">\n    <div *ngFor=\"let prop of objectProps\">\n      <label [attr.for]=\"prop\">{{prop.label}}</label>\n\n      <div [ngSwitch]=\"prop.type\">\n        <input *ngSwitchCase=\"'text'\"\n               [formControlName]=\"prop.key\"\n               [id]=\"prop.key\" [type]=\"prop.type\"\n               [(ngModel)] = \"prop.value\">\n\n      </div>\n<!--\n      <div class=\"error\" *ngIf=\"form.get(prop.key).invalid && (form.get(prop.key).dirty || form.get(prop.key).touched)\">\n        <div *ngIf=\"form.get(prop.key).errors.required\">\n          <h6>{{ prop.label }} is required.</h6>\n        </div>\n      </div>-->\n\n\n    </div>\n    <p>\n      <button type=\"submit\">Done</button>\n    </p>\n  </form>\n\n</div>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
ContactFormComponent.ctorParameters = () => [
    { type: PagesService }
];
ContactFormComponent.propDecorators = {
    contactForm: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    ContactFormComponent.prototype.contactForm;
    /** @type {?} */
    ContactFormComponent.prototype.form;
    /** @type {?} */
    ContactFormComponent.prototype.objectProps;
    /**
     * @type {?}
     * @private
     */
    ContactFormComponent.prototype.response;
    /**
     * @type {?}
     * @private
     */
    ContactFormComponent.prototype.surveyState;
    /**
     * @type {?}
     * @private
     */
    ContactFormComponent.prototype.pagesService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGFjdC1mb3JtLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL3N1cnZleS1saWIvIiwic291cmNlcyI6WyJsaWIvcGFnZXMvcXVlc3Rpb25uYWlyZS9jb250YWN0LWZvcm0vY29udGFjdC1mb3JtLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsS0FBSyxFQUFTLE1BQU0sZUFBZSxDQUFDO0FBQ3ZELE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUMzQyxPQUFPLEVBQUMsV0FBVyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUtsRSxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sOENBQThDLENBQUM7QUFPMUUsTUFBTSxPQUFPLG9CQUFvQjs7OztJQVUvQixZQUFvQixZQUEwQjtRQUExQixpQkFBWSxHQUFaLFlBQVksQ0FBYztJQUM5QyxDQUFDOzs7O0lBR0QsUUFBUTtRQUNOLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUdwQixDQUFDOzs7O0lBRUQsVUFBVTs7Y0FFRixTQUFTLEdBQUcsRUFBRTtRQUNwQixLQUFJLElBQUksSUFBSSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsRUFBRTtZQUN6RCxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUUsRUFBRSxvQkFBb0IsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztTQUN0SztRQUNELElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDdkMsQ0FBQzs7Ozs7O0lBRU8sTUFBTSxDQUFDLGFBQWEsQ0FBQyxVQUFVOztjQUMvQixjQUFjLEdBQUcsRUFBRTtRQUV6QixJQUFHLFVBQVUsRUFBRTtZQUNiLEtBQUksTUFBTSxVQUFVLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDL0MsSUFBRyxVQUFVLEtBQUssVUFBVSxFQUFFO29CQUM1QixjQUFjLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDMUM7cUJBQU0sSUFBRyxVQUFVLEtBQUssS0FBSyxFQUFFO29CQUM5QixjQUFjLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDN0Q7YUFDRjtTQUNGO1FBRUQsT0FBTyxjQUFjLENBQUM7SUFDeEIsQ0FBQzs7OztJQUVELFFBQVE7UUFDTixJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBQzdDLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDO1FBQ3ZELElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUcvQywrQkFBK0I7UUFDakM7Ozs7bUVBSTJEO1FBQ3pELDJCQUEyQjtJQUM3QixDQUFDOzs7WUEvREYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxrQkFBa0I7Z0JBQzVCLCt5QkFBNEM7O2FBRTdDOzs7O1lBTk8sWUFBWTs7OzBCQVNqQixLQUFLOzs7O0lBQU4sMkNBQStCOztJQUUvQixvQ0FBZ0I7O0lBQ2hCLDJDQUFZOzs7OztJQUVaLHdDQUFrQzs7Ozs7SUFDbEMsMkNBQStEOzs7OztJQUVuRCw0Q0FBa0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudCwgSW5wdXQsIE9uSW5pdH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1F1ZXN0aW9ufSBmcm9tICcuLi8uLi9wYWdlcy5tb2RlbCc7XG5pbXBvcnQge0Zvcm1Db250cm9sLCBGb3JtR3JvdXAsIFZhbGlkYXRvcnN9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1N1cnZleVJlc3BvbnNlc30gZnJvbSAnLi4vLi4vc3VydmV5LXJlc3BvbnNlLm1vZGVsJztcbmltcG9ydCB7U3RvcmV9IGZyb20gJ0BuZ3J4L3N0b3JlJztcbmltcG9ydCAqIGFzIHN1cnZleUFjdGlvbnMgZnJvbSAnLi4vLi4vc3RvcmUvc3VydmV5LWFjdGlvbnMnO1xuaW1wb3J0IHtQYWdlc1NlcnZpY2V9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9wYWdlcy1zZXJ2aWNlcy9wYWdlcy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYXBwLWNvbnRhY3QtZm9ybScsXG4gIHRlbXBsYXRlVXJsOiAnLi9jb250YWN0LWZvcm0uY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9jb250YWN0LWZvcm0uY29tcG9uZW50LmNzcyddXG59KVxuZXhwb3J0IGNsYXNzIENvbnRhY3RGb3JtQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICBASW5wdXQoKSBjb250YWN0Rm9ybTogUXVlc3Rpb247XG5cbiAgZm9ybTogRm9ybUdyb3VwO1xuICBvYmplY3RQcm9wcztcblxuICBwcml2YXRlIHJlc3BvbnNlOiBTdXJ2ZXlSZXNwb25zZXM7XG4gIHByaXZhdGUgc3VydmV5U3RhdGU6IE9ic2VydmFibGU8e3Jlc3BvbnNlOiBTdXJ2ZXlSZXNwb25zZXNbXX0+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcGFnZXNTZXJ2aWNlOiBQYWdlc1NlcnZpY2UpIHtcbiAgfVxuXG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5jcmVhdGVGb3JtKCk7XG5cblxuICB9XG5cbiAgY3JlYXRlRm9ybSgpe1xuXG4gICAgY29uc3QgZm9ybUdyb3VwID0ge307XG4gICAgZm9yKGxldCBwcm9wIG9mIE9iamVjdC5rZXlzKHRoaXMuY29udGFjdEZvcm0uY29udGFjdEZvcm0pKSB7XG4gICAgICBmb3JtR3JvdXBbcHJvcF0gPSBuZXcgRm9ybUNvbnRyb2wodGhpcy5jb250YWN0Rm9ybS5jb250YWN0Rm9ybVtwcm9wXS52YWx1ZSB8fCAnJywgQ29udGFjdEZvcm1Db21wb25lbnQubWFwVmFsaWRhdG9ycyh0aGlzLmNvbnRhY3RGb3JtLmNvbnRhY3RGb3JtW3Byb3BdLnZhbGlkYXRpb24pKTtcbiAgICB9XG4gICAgdGhpcy5mb3JtID0gbmV3IEZvcm1Hcm91cChmb3JtR3JvdXApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgbWFwVmFsaWRhdG9ycyh2YWxpZGF0b3JzKSB7XG4gICAgY29uc3QgZm9ybVZhbGlkYXRvcnMgPSBbXTtcblxuICAgIGlmKHZhbGlkYXRvcnMpIHtcbiAgICAgIGZvcihjb25zdCB2YWxpZGF0aW9uIG9mIE9iamVjdC5rZXlzKHZhbGlkYXRvcnMpKSB7XG4gICAgICAgIGlmKHZhbGlkYXRpb24gPT09ICdyZXF1aXJlZCcpIHtcbiAgICAgICAgICBmb3JtVmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvcnMucmVxdWlyZWQpO1xuICAgICAgICB9IGVsc2UgaWYodmFsaWRhdGlvbiA9PT0gJ21pbicpIHtcbiAgICAgICAgICBmb3JtVmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvcnMubWluKHZhbGlkYXRvcnNbdmFsaWRhdGlvbl0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmb3JtVmFsaWRhdG9ycztcbiAgfVxuXG4gIG9uU3VibWl0KCkge1xuICAgIHRoaXMucmVzcG9uc2UuY29udGFjdEluZm8gPSB0aGlzLm9iamVjdFByb3BzO1xuICAgIHRoaXMucmVzcG9uc2UucXVlc3Rpb25JZCA9IHRoaXMuY29udGFjdEZvcm0ucXVlc3Rpb25JZDtcbiAgICB0aGlzLnBhZ2VzU2VydmljZS5wZXJzaXN0U3VydmV5KHRoaXMucmVzcG9uc2UpO1xuXG5cbiAgICAvL2NvbnNvbGUubG9nKHRoaXMuZGF0YU9iamVjdCk7XG4gIC8qICBmb3IgKGxldCBjb250cm9sc0tleSBpbiB0aGlzLmZvcm0uY29udHJvbHMpIHtcbiAgICAgIHRoaXMuZGF0YU9iamVjdFtjb250cm9sc0tleV0udmFsdWUgPSBmb3JtW2NvbnRyb2xzS2V5XTtcbiAgICB9XG4gICAgY29uc29sZS5sb2codGhpcy5kYXRhT2JqZWN0KTtcbiAgICB0aGlzLnJlc3BvbnNlLnF1ZXN0aW9uSWQgPSB0aGlzLmNvbnRhY3RGb3JtLnF1ZXN0aW9uSWQ7Ki9cbiAgICAvL3RoaXMucmVzcG9uc2UuY29udGFjdEluZm9cbiAgfVxufVxuIl19
import { MoveArrayControlAction } from '../../actions';
import { computeArrayState } from '../../state';
import { childReducer, updateIdRecursive } from './util';
export function move(array, fromIndex, toIndex) {
    const item = array[fromIndex];
    const length = array.length;
    if (fromIndex > toIndex) {
        return [
            ...array.slice(0, toIndex),
            item,
            ...array.slice(toIndex, fromIndex),
            ...array.slice(fromIndex + 1, length),
        ];
    }
    else {
        const targetIndex = toIndex + 1;
        return [
            ...array.slice(0, fromIndex),
            ...array.slice(fromIndex + 1, targetIndex),
            item,
            ...array.slice(targetIndex, length),
        ];
    }
}
export function moveControlReducer(state, action) {
    if (action.type !== MoveArrayControlAction.TYPE) {
        return state;
    }
    if (action.controlId !== state.id) {
        return childReducer(state, action);
    }
    const fromIndex = action.fromIndex;
    const toIndex = action.toIndex;
    if (fromIndex === toIndex) {
        return state;
    }
    if (fromIndex < 0 || toIndex < 0) {
        throw new Error(`fromIndex ${fromIndex} or toIndex ${fromIndex} was negative`);
    }
    if (fromIndex >= state.controls.length || toIndex >= state.controls.length) {
        throw new Error(`fromIndex ${fromIndex} or toIndex ${toIndex} is out of bounds with the length of the controls ${state.controls.length}`);
    }
    let controls = move(state.controls, fromIndex, toIndex);
    controls = controls.map((c, i) => updateIdRecursive(c, `${state.id}.${i}`));
    return computeArrayState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
        wasOrShouldBeDirty: true,
        wasOrShouldBeEnabled: state.isEnabled,
        wasOrShouldBeTouched: state.isTouched,
        wasOrShouldBeSubmitted: state.isSubmitted,
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW92ZS1jb250cm9sLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmdyeC1mb3Jtcy8iLCJzb3VyY2VzIjpbInNyYy9hcnJheS9yZWR1Y2VyL21vdmUtY29udHJvbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQVcsc0JBQXNCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDaEUsT0FBTyxFQUFFLGlCQUFpQixFQUFrQixNQUFNLGFBQWEsQ0FBQztBQUNoRSxPQUFPLEVBQUUsWUFBWSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sUUFBUSxDQUFDO0FBRXpELE1BQU0sVUFBVSxJQUFJLENBQUMsS0FBcUIsRUFBRSxTQUFpQixFQUFFLE9BQWU7SUFDNUUsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzlCLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFDNUIsSUFBSSxTQUFTLEdBQUcsT0FBTyxFQUFFO1FBQ3ZCLE9BQU87WUFDTCxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQztZQUMxQixJQUFJO1lBQ0osR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUM7WUFDbEMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUUsTUFBTSxDQUFDO1NBQ3RDLENBQUM7S0FDSDtTQUFNO1FBQ0wsTUFBTSxXQUFXLEdBQUcsT0FBTyxHQUFHLENBQUMsQ0FBQztRQUNoQyxPQUFPO1lBQ0wsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUM7WUFDNUIsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUUsV0FBVyxDQUFDO1lBQzFDLElBQUk7WUFDSixHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQztTQUNwQyxDQUFDO0tBQ0g7QUFDSCxDQUFDO0FBRUQsTUFBTSxVQUFVLGtCQUFrQixDQUNoQyxLQUE2QixFQUM3QixNQUF5QjtJQUV6QixJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssc0JBQXNCLENBQUMsSUFBSSxFQUFFO1FBQy9DLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxJQUFJLE1BQU0sQ0FBQyxTQUFTLEtBQUssS0FBSyxDQUFDLEVBQUUsRUFBRTtRQUNqQyxPQUFPLFlBQVksQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDcEM7SUFFRCxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDO0lBQ25DLE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUM7SUFFL0IsSUFBSSxTQUFTLEtBQUssT0FBTyxFQUFFO1FBQ3pCLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFFRCxJQUFJLFNBQVMsR0FBRyxDQUFDLElBQUksT0FBTyxHQUFHLENBQUMsRUFBRTtRQUNoQyxNQUFNLElBQUksS0FBSyxDQUFDLGFBQWEsU0FBUyxlQUFlLFNBQVMsZUFBZSxDQUFDLENBQUM7S0FDaEY7SUFFRCxJQUFJLFNBQVMsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxPQUFPLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUU7UUFDMUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxhQUFhLFNBQVMsZUFBZSxPQUFPLHFEQUFxRCxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7S0FDM0k7SUFFRCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFFeEQsUUFBUSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUU1RSxPQUFPLGlCQUFpQixDQUN0QixLQUFLLENBQUMsRUFBRSxFQUNSLFFBQVEsRUFDUixLQUFLLENBQUMsS0FBSyxFQUNYLEtBQUssQ0FBQyxNQUFNLEVBQ1osS0FBSyxDQUFDLGtCQUFrQixFQUN4QixLQUFLLENBQUMscUJBQXFCLEVBQzNCO1FBQ0Usa0JBQWtCLEVBQUUsSUFBSTtRQUN4QixvQkFBb0IsRUFBRSxLQUFLLENBQUMsU0FBUztRQUNyQyxvQkFBb0IsRUFBRSxLQUFLLENBQUMsU0FBUztRQUNyQyxzQkFBc0IsRUFBRSxLQUFLLENBQUMsV0FBVztLQUMxQyxDQUNGLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWN0aW9ucywgTW92ZUFycmF5Q29udHJvbEFjdGlvbiB9IGZyb20gJy4uLy4uL2FjdGlvbnMnO1xyXG5pbXBvcnQgeyBjb21wdXRlQXJyYXlTdGF0ZSwgRm9ybUFycmF5U3RhdGUgfSBmcm9tICcuLi8uLi9zdGF0ZSc7XHJcbmltcG9ydCB7IGNoaWxkUmVkdWNlciwgdXBkYXRlSWRSZWN1cnNpdmUgfSBmcm9tICcuL3V0aWwnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1vdmUoYXJyYXk6IHJlYWRvbmx5IGFueVtdLCBmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleDogbnVtYmVyKSB7XHJcbiAgY29uc3QgaXRlbSA9IGFycmF5W2Zyb21JbmRleF07XHJcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG4gIGlmIChmcm9tSW5kZXggPiB0b0luZGV4KSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAuLi5hcnJheS5zbGljZSgwLCB0b0luZGV4KSxcclxuICAgICAgaXRlbSxcclxuICAgICAgLi4uYXJyYXkuc2xpY2UodG9JbmRleCwgZnJvbUluZGV4KSxcclxuICAgICAgLi4uYXJyYXkuc2xpY2UoZnJvbUluZGV4ICsgMSwgbGVuZ3RoKSxcclxuICAgIF07XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IHRhcmdldEluZGV4ID0gdG9JbmRleCArIDE7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAuLi5hcnJheS5zbGljZSgwLCBmcm9tSW5kZXgpLFxyXG4gICAgICAuLi5hcnJheS5zbGljZShmcm9tSW5kZXggKyAxLCB0YXJnZXRJbmRleCksXHJcbiAgICAgIGl0ZW0sXHJcbiAgICAgIC4uLmFycmF5LnNsaWNlKHRhcmdldEluZGV4LCBsZW5ndGgpLFxyXG4gICAgXTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtb3ZlQ29udHJvbFJlZHVjZXI8VFZhbHVlPihcclxuICBzdGF0ZTogRm9ybUFycmF5U3RhdGU8VFZhbHVlPixcclxuICBhY3Rpb246IEFjdGlvbnM8VFZhbHVlW10+LFxyXG4pOiBGb3JtQXJyYXlTdGF0ZTxUVmFsdWU+IHtcclxuICBpZiAoYWN0aW9uLnR5cGUgIT09IE1vdmVBcnJheUNvbnRyb2xBY3Rpb24uVFlQRSkge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuICBpZiAoYWN0aW9uLmNvbnRyb2xJZCAhPT0gc3RhdGUuaWQpIHtcclxuICAgIHJldHVybiBjaGlsZFJlZHVjZXIoc3RhdGUsIGFjdGlvbik7XHJcbiAgfVxyXG5cclxuICBjb25zdCBmcm9tSW5kZXggPSBhY3Rpb24uZnJvbUluZGV4O1xyXG4gIGNvbnN0IHRvSW5kZXggPSBhY3Rpb24udG9JbmRleDtcclxuXHJcbiAgaWYgKGZyb21JbmRleCA9PT0gdG9JbmRleCkge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZyb21JbmRleCA8IDAgfHwgdG9JbmRleCA8IDApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgZnJvbUluZGV4ICR7ZnJvbUluZGV4fSBvciB0b0luZGV4ICR7ZnJvbUluZGV4fSB3YXMgbmVnYXRpdmVgKTtcclxuICB9XHJcblxyXG4gIGlmIChmcm9tSW5kZXggPj0gc3RhdGUuY29udHJvbHMubGVuZ3RoIHx8IHRvSW5kZXggPj0gc3RhdGUuY29udHJvbHMubGVuZ3RoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGZyb21JbmRleCAke2Zyb21JbmRleH0gb3IgdG9JbmRleCAke3RvSW5kZXh9IGlzIG91dCBvZiBib3VuZHMgd2l0aCB0aGUgbGVuZ3RoIG9mIHRoZSBjb250cm9scyAke3N0YXRlLmNvbnRyb2xzLmxlbmd0aH1gKTtcclxuICB9XHJcblxyXG4gIGxldCBjb250cm9scyA9IG1vdmUoc3RhdGUuY29udHJvbHMsIGZyb21JbmRleCwgdG9JbmRleCk7XHJcblxyXG4gIGNvbnRyb2xzID0gY29udHJvbHMubWFwKChjLCBpKSA9PiB1cGRhdGVJZFJlY3Vyc2l2ZShjLCBgJHtzdGF0ZS5pZH0uJHtpfWApKTtcclxuXHJcbiAgcmV0dXJuIGNvbXB1dGVBcnJheVN0YXRlKFxyXG4gICAgc3RhdGUuaWQsXHJcbiAgICBjb250cm9scyxcclxuICAgIHN0YXRlLnZhbHVlLFxyXG4gICAgc3RhdGUuZXJyb3JzLFxyXG4gICAgc3RhdGUucGVuZGluZ1ZhbGlkYXRpb25zLFxyXG4gICAgc3RhdGUudXNlckRlZmluZWRQcm9wZXJ0aWVzLFxyXG4gICAge1xyXG4gICAgICB3YXNPclNob3VsZEJlRGlydHk6IHRydWUsXHJcbiAgICAgIHdhc09yU2hvdWxkQmVFbmFibGVkOiBzdGF0ZS5pc0VuYWJsZWQsXHJcbiAgICAgIHdhc09yU2hvdWxkQmVUb3VjaGVkOiBzdGF0ZS5pc1RvdWNoZWQsXHJcbiAgICAgIHdhc09yU2hvdWxkQmVTdWJtaXR0ZWQ6IHN0YXRlLmlzU3VibWl0dGVkLFxyXG4gICAgfVxyXG4gICk7XHJcbn1cclxuIl19
import * as tslib_1 from "tslib";
import { Directive, ElementRef, Host, Input, Optional, Renderer2, } from '@angular/core';
import { NgrxSelectViewAdapter } from './select';
import { NgrxSelectMultipleViewAdapter } from './select-multiple';
const ɵ0 = () => void 0;
// tslint:disable:directive-class-suffix
const NULL_RENDERER = {
    setProperty: ɵ0,
};
/**
 * This directive is necessary to restore the default behaviour of Angular
 * when an `option` is used without an **ngrx-forms** form state. Since it
 * is not possible to select an element with a selector that considers its
 * parent the `option` directives for `select` and `select[multiple]` will
 * always be applied and therefore overriding the `[value]` binding which
 * disabled Angular's normal behaviour. This directive restores this
 * behaviour if no `select` or `select[multiple]` view adapter is found.
 * This is not a perfect solution since it may interfere with other
 * directives that try to set the `[value]` but that is very unlikely.
 */
let NgrxFallbackSelectOption = class NgrxFallbackSelectOption {
    constructor(element, renderer, viewAdapter, multipleViewAdapter) {
        this.element = element;
        this.renderer = renderer;
        this.renderer = viewAdapter || multipleViewAdapter ? NULL_RENDERER : renderer;
    }
    set value(value) {
        this.renderer.setProperty(this.element.nativeElement, 'value', value);
    }
};
tslib_1.__decorate([
    Input('value'),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], NgrxFallbackSelectOption.prototype, "value", null);
NgrxFallbackSelectOption = tslib_1.__decorate([
    Directive({
        // tslint:disable-next-line:directive-selector
        selector: 'option',
    }),
    tslib_1.__param(2, Host()), tslib_1.__param(2, Optional()),
    tslib_1.__param(3, Host()), tslib_1.__param(3, Optional()),
    tslib_1.__metadata("design:paramtypes", [ElementRef,
        Renderer2,
        NgrxSelectViewAdapter,
        NgrxSelectMultipleViewAdapter])
], NgrxFallbackSelectOption);
export { NgrxFallbackSelectOption };
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3B0aW9uLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmdyeC1mb3Jtcy8iLCJzb3VyY2VzIjpbInNyYy92aWV3LWFkYXB0ZXIvb3B0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFVBQVUsRUFDVixJQUFJLEVBQ0osS0FBSyxFQUNMLFFBQVEsRUFDUixTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQ2pELE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLG1CQUFtQixDQUFDO1dBS25ELEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQztBQUgzQix3Q0FBd0M7QUFFeEMsTUFBTSxhQUFhLEdBQWM7SUFDL0IsV0FBVyxJQUFjO0NBQ25CLENBQUM7QUFFVDs7Ozs7Ozs7OztHQVVHO0FBS0gsSUFBYSx3QkFBd0IsR0FBckMsTUFBYSx3QkFBd0I7SUFDbkMsWUFDVSxPQUFtQixFQUNuQixRQUFtQixFQUNQLFdBQWtDLEVBQ2xDLG1CQUFrRDtRQUg5RCxZQUFPLEdBQVAsT0FBTyxDQUFZO1FBQ25CLGFBQVEsR0FBUixRQUFRLENBQVc7UUFJM0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxXQUFXLElBQUksbUJBQW1CLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO0lBQ2hGLENBQUM7SUFHRCxJQUFJLEtBQUssQ0FBQyxLQUFVO1FBQ2xCLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN4RSxDQUFDO0NBQ0YsQ0FBQTtBQUhDO0lBREMsS0FBSyxDQUFDLE9BQU8sQ0FBQzs7O3FEQUdkO0FBYlUsd0JBQXdCO0lBSnBDLFNBQVMsQ0FBQztRQUNULDhDQUE4QztRQUM5QyxRQUFRLEVBQUUsUUFBUTtLQUNuQixDQUFDO0lBS0csbUJBQUEsSUFBSSxFQUFFLENBQUEsRUFBRSxtQkFBQSxRQUFRLEVBQUUsQ0FBQTtJQUNsQixtQkFBQSxJQUFJLEVBQUUsQ0FBQSxFQUFFLG1CQUFBLFFBQVEsRUFBRSxDQUFBOzZDQUhGLFVBQVU7UUFDVCxTQUFTO1FBQ00scUJBQXFCO1FBQ2IsNkJBQTZCO0dBTDdELHdCQUF3QixDQWNwQztTQWRZLHdCQUF3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgRGlyZWN0aXZlLFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgSG9zdCxcclxuICBJbnB1dCxcclxuICBPcHRpb25hbCxcclxuICBSZW5kZXJlcjIsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgeyBOZ3J4U2VsZWN0Vmlld0FkYXB0ZXIgfSBmcm9tICcuL3NlbGVjdCc7XHJcbmltcG9ydCB7IE5ncnhTZWxlY3RNdWx0aXBsZVZpZXdBZGFwdGVyIH0gZnJvbSAnLi9zZWxlY3QtbXVsdGlwbGUnO1xyXG5cclxuLy8gdHNsaW50OmRpc2FibGU6ZGlyZWN0aXZlLWNsYXNzLXN1ZmZpeFxyXG5cclxuY29uc3QgTlVMTF9SRU5ERVJFUjogUmVuZGVyZXIyID0ge1xyXG4gIHNldFByb3BlcnR5OiAoKSA9PiB2b2lkIDAsXHJcbn0gYXMgYW55O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIG5lY2Vzc2FyeSB0byByZXN0b3JlIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiBBbmd1bGFyXHJcbiAqIHdoZW4gYW4gYG9wdGlvbmAgaXMgdXNlZCB3aXRob3V0IGFuICoqbmdyeC1mb3JtcyoqIGZvcm0gc3RhdGUuIFNpbmNlIGl0XHJcbiAqIGlzIG5vdCBwb3NzaWJsZSB0byBzZWxlY3QgYW4gZWxlbWVudCB3aXRoIGEgc2VsZWN0b3IgdGhhdCBjb25zaWRlcnMgaXRzXHJcbiAqIHBhcmVudCB0aGUgYG9wdGlvbmAgZGlyZWN0aXZlcyBmb3IgYHNlbGVjdGAgYW5kIGBzZWxlY3RbbXVsdGlwbGVdYCB3aWxsXHJcbiAqIGFsd2F5cyBiZSBhcHBsaWVkIGFuZCB0aGVyZWZvcmUgb3ZlcnJpZGluZyB0aGUgYFt2YWx1ZV1gIGJpbmRpbmcgd2hpY2hcclxuICogZGlzYWJsZWQgQW5ndWxhcidzIG5vcm1hbCBiZWhhdmlvdXIuIFRoaXMgZGlyZWN0aXZlIHJlc3RvcmVzIHRoaXNcclxuICogYmVoYXZpb3VyIGlmIG5vIGBzZWxlY3RgIG9yIGBzZWxlY3RbbXVsdGlwbGVdYCB2aWV3IGFkYXB0ZXIgaXMgZm91bmQuXHJcbiAqIFRoaXMgaXMgbm90IGEgcGVyZmVjdCBzb2x1dGlvbiBzaW5jZSBpdCBtYXkgaW50ZXJmZXJlIHdpdGggb3RoZXJcclxuICogZGlyZWN0aXZlcyB0aGF0IHRyeSB0byBzZXQgdGhlIGBbdmFsdWVdYCBidXQgdGhhdCBpcyB2ZXJ5IHVubGlrZWx5LlxyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRpcmVjdGl2ZS1zZWxlY3RvclxyXG4gIHNlbGVjdG9yOiAnb3B0aW9uJyxcclxufSlcclxuZXhwb3J0IGNsYXNzIE5ncnhGYWxsYmFja1NlbGVjdE9wdGlvbiB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXHJcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXHJcbiAgICBASG9zdCgpIEBPcHRpb25hbCgpIHZpZXdBZGFwdGVyOiBOZ3J4U2VsZWN0Vmlld0FkYXB0ZXIsXHJcbiAgICBASG9zdCgpIEBPcHRpb25hbCgpIG11bHRpcGxlVmlld0FkYXB0ZXI6IE5ncnhTZWxlY3RNdWx0aXBsZVZpZXdBZGFwdGVyLFxyXG4gICkge1xyXG4gICAgdGhpcy5yZW5kZXJlciA9IHZpZXdBZGFwdGVyIHx8IG11bHRpcGxlVmlld0FkYXB0ZXIgPyBOVUxMX1JFTkRFUkVSIDogcmVuZGVyZXI7XHJcbiAgfVxyXG5cclxuICBASW5wdXQoJ3ZhbHVlJylcclxuICBzZXQgdmFsdWUodmFsdWU6IGFueSkge1xyXG4gICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgdmFsdWUpO1xyXG4gIH1cclxufVxyXG4iXX0=
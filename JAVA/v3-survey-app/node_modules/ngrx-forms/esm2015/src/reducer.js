import { ALL_NGRX_FORMS_ACTION_TYPES } from './actions';
import { formArrayReducer } from './array/reducer';
import { formControlReducer } from './control/reducer';
import { formGroupReducer } from './group/reducer';
import { isArrayState, isFormState, isGroupState } from './state';
export function formStateReducer(state, action) {
    if (!state) {
        throw new Error('The form state must be defined!');
    }
    if (!isFormState(state)) {
        throw new Error(`state must be a form state, got ${state}`);
    }
    if (isGroupState(state)) {
        return formGroupReducer(state, action);
    }
    if (isArrayState(state)) {
        return formArrayReducer(state, action);
    }
    return formControlReducer(state, action);
}
/**
 * This function creates a reducer function that first applies an action to the state
 * and afterwards applies all given update functions one after another to the resulting
 * form state. However, the update functions are only applied if the form state changed
 * as result of applying the action. If you need the update functions to be applied
 * regardless of whether the state changed (e.g. because the update function closes
 * over variables that may change independently of the form state) you can simply apply
 * the update manually (e.g. `updateFunction(formStateReducer(state, action))`).
 *
 * The following (contrived) example uses this function to create a reducer that after
 * each action validates the child control `name` to be required and sets the child
 * control `email`'s value to be `''` if the name is invalid.
 *
```typescript
interface FormValue {
  name: string;
  email: string;
}

const updateFormState = updateGroup<FormValue>(
  {
    name: validate(required),
  },
  {
    email: (email, parentGroup) =>
      parentGroup.controls.name.isInvalid
        ? setValue('', email)
        : email,
  },
);

const reducer = createFormStateReducerWithUpdate<FormValue>(updateFormState);
```
 */
export function createFormStateReducerWithUpdate(updateFnOrUpdateFnArr, ...updateFnArr) {
    updateFnArr = [...(Array.isArray(updateFnOrUpdateFnArr) ? updateFnOrUpdateFnArr : [updateFnOrUpdateFnArr]), ...updateFnArr];
    return (state, action) => {
        const newState = formStateReducer(state, action);
        return newState === state ? state : updateFnArr.reduce((s, f) => f(s), newState);
    };
}
function reduceNestedFormState(state, key, action) {
    const value = state[key];
    if (!isFormState(value)) {
        return state;
    }
    return Object.assign({}, state, { [key]: formStateReducer(value, action) });
}
function reduceNestedFormStates(state, action) {
    return Object.keys(state).reduce((s, key) => reduceNestedFormState(s, key, action), state);
}
/**
 * This function returns an object that can be passed to ngrx's `createReducer`
 * function (available starting with ngrx version 8). By doing this all form
 * state properties on the state will be updated whenever necessary (i.e.
 * whenever an ngrx-forms action is dispatched).
 *
 * To manually update a form state (e.g. to validate it) use
 * `wrapReducerWithFormStateUpdate`.
 */
export function onNgrxForms() {
    return {
        reducer: (state, action) => reduceNestedFormStates(state, action),
        types: ALL_NGRX_FORMS_ACTION_TYPES,
    };
}
/**
 * Define a reducer for a ngrx-forms action. This functions works the same as
 * ngrx's `on` except that you provide the ngrx-forms action class instead of
 * your action creator as a parameter.
 */
export function onNgrxFormsAction(actionCons, reducer) {
    return {
        reducer: (state, action) => reducer(reduceNestedFormStates(state, action), action),
        types: [actionCons.TYPE],
    };
}
/**
 * This function wraps a reducer and returns another reducer that first calls
 * the given reducer and then calls the given update function for the form state
 * that is specified by the form state locator function.
 *
 * The update function is passed the form state and the updated containing state
 * as parameters.
 */
export function wrapReducerWithFormStateUpdate(reducer, formStateLocator, updateFn) {
    return (state, action) => {
        const updatedState = reducer(state, action);
        const formState = formStateLocator(updatedState);
        const formStateKey = Object.keys(updatedState).find(key => updatedState[key] === formState);
        const updatedFormState = updateFn(formState, updatedState);
        if (updatedFormState === formState) {
            return updatedState;
        }
        return Object.assign({}, updatedState, { [formStateKey]: updatedFormState });
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVkdWNlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25ncngtZm9ybXMvIiwic291cmNlcyI6WyJzcmMvcmVkdWNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQVcsMkJBQTJCLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDakUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDbkQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDdkQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDbkQsT0FBTyxFQUFxRCxZQUFZLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUdySCxNQUFNLFVBQVUsZ0JBQWdCLENBQzlCLEtBQW1FLEVBQ25FLE1BQWM7SUFFZCxJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO0tBQ3BEO0lBRUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0tBQzdEO0lBRUQsSUFBSSxZQUFZLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDdkIsT0FBTyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFRLENBQUM7S0FDL0M7SUFFRCxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUN2QixPQUFPLGdCQUFnQixDQUFDLEtBQUssRUFBRSxNQUFNLENBQVEsQ0FBQztLQUMvQztJQUVELE9BQU8sa0JBQWtCLENBQUMsS0FBOEIsRUFBRSxNQUFNLENBQVEsQ0FBQztBQUMzRSxDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWlDRztBQUNILE1BQU0sVUFBVSxnQ0FBZ0MsQ0FDOUMscUJBQW9GLEVBQ3BGLEdBQUcs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QUMsRUFBRSxnQkFBZ0IsSUFDaEM7SUFDSixDQUFDLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWN0aW9uLCBBY3Rpb25SZWR1Y2VyIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xyXG5cclxuaW1wb3J0IHsgQWN0aW9ucywgQUxMX05HUlhfRk9STVNfQUNUSU9OX1RZUEVTIH0gZnJvbSAnLi9hY3Rpb25zJztcclxuaW1wb3J0IHsgZm9ybUFycmF5UmVkdWNlciB9IGZyb20gJy4vYXJyYXkvcmVkdWNlcic7XHJcbmltcG9ydCB7IGZvcm1Db250cm9sUmVkdWNlciB9IGZyb20gJy4vY29udHJvbC9yZWR1Y2VyJztcclxuaW1wb3J0IHsgZm9ybUdyb3VwUmVkdWNlciB9IGZyb20gJy4vZ3JvdXAvcmVkdWNlcic7XHJcbmltcG9ydCB7IEFic3RyYWN0Q29udHJvbFN0YXRlLCBGb3JtQ29udHJvbFN0YXRlLCBGb3JtU3RhdGUsIGlzQXJyYXlTdGF0ZSwgaXNGb3JtU3RhdGUsIGlzR3JvdXBTdGF0ZSB9IGZyb20gJy4vc3RhdGUnO1xyXG5pbXBvcnQgeyBQcm9qZWN0Rm4gfSBmcm9tICcuL3VwZGF0ZS1mdW5jdGlvbi91dGlsJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtU3RhdGVSZWR1Y2VyPFRWYWx1ZT4oXHJcbiAgc3RhdGU6IEZvcm1TdGF0ZTxUVmFsdWU+IHwgQWJzdHJhY3RDb250cm9sU3RhdGU8VFZhbHVlPiB8IHVuZGVmaW5lZCxcclxuICBhY3Rpb246IEFjdGlvbixcclxuKTogRm9ybVN0YXRlPFRWYWx1ZT4ge1xyXG4gIGlmICghc3RhdGUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZvcm0gc3RhdGUgbXVzdCBiZSBkZWZpbmVkIScpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFpc0Zvcm1TdGF0ZShzdGF0ZSkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgc3RhdGUgbXVzdCBiZSBhIGZvcm0gc3RhdGUsIGdvdCAke3N0YXRlfWApO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzR3JvdXBTdGF0ZShzdGF0ZSkpIHtcclxuICAgIHJldHVybiBmb3JtR3JvdXBSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIGFzIGFueTtcclxuICB9XHJcblxyXG4gIGlmIChpc0FycmF5U3RhdGUoc3RhdGUpKSB7XHJcbiAgICByZXR1cm4gZm9ybUFycmF5UmVkdWNlcihzdGF0ZSwgYWN0aW9uKSBhcyBhbnk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZm9ybUNvbnRyb2xSZWR1Y2VyKHN0YXRlIGFzIEZvcm1Db250cm9sU3RhdGU8YW55PiwgYWN0aW9uKSBhcyBhbnk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSByZWR1Y2VyIGZ1bmN0aW9uIHRoYXQgZmlyc3QgYXBwbGllcyBhbiBhY3Rpb24gdG8gdGhlIHN0YXRlXHJcbiAqIGFuZCBhZnRlcndhcmRzIGFwcGxpZXMgYWxsIGdpdmVuIHVwZGF0ZSBmdW5jdGlvbnMgb25lIGFmdGVyIGFub3RoZXIgdG8gdGhlIHJlc3VsdGluZ1xyXG4gKiBmb3JtIHN0YXRlLiBIb3dldmVyLCB0aGUgdXBkYXRlIGZ1bmN0aW9ucyBhcmUgb25seSBhcHBsaWVkIGlmIHRoZSBmb3JtIHN0YXRlIGNoYW5nZWRcclxuICogYXMgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBhY3Rpb24uIElmIHlvdSBuZWVkIHRoZSB1cGRhdGUgZnVuY3Rpb25zIHRvIGJlIGFwcGxpZWRcclxuICogcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBzdGF0ZSBjaGFuZ2VkIChlLmcuIGJlY2F1c2UgdGhlIHVwZGF0ZSBmdW5jdGlvbiBjbG9zZXNcclxuICogb3ZlciB2YXJpYWJsZXMgdGhhdCBtYXkgY2hhbmdlIGluZGVwZW5kZW50bHkgb2YgdGhlIGZvcm0gc3RhdGUpIHlvdSBjYW4gc2ltcGx5IGFwcGx5XHJcbiAqIHRoZSB1cGRhdGUgbWFudWFsbHkgKGUuZy4gYHVwZGF0ZUZ1bmN0aW9uKGZvcm1TdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikpYCkuXHJcbiAqXHJcbiAqIFRoZSBmb2xsb3dpbmcgKGNvbnRyaXZlZCkgZXhhbXBsZSB1c2VzIHRoaXMgZnVuY3Rpb24gdG8gY3JlYXRlIGEgcmVkdWNlciB0aGF0IGFmdGVyXHJcbiAqIGVhY2ggYWN0aW9uIHZhbGlkYXRlcyB0aGUgY2hpbGQgY29udHJvbCBgbmFtZWAgdG8gYmUgcmVxdWlyZWQgYW5kIHNldHMgdGhlIGNoaWxkXHJcbiAqIGNvbnRyb2wgYGVtYWlsYCdzIHZhbHVlIHRvIGJlIGAnJ2AgaWYgdGhlIG5hbWUgaXMgaW52YWxpZC5cclxuICpcclxuYGBgdHlwZXNjcmlwdFxyXG5pbnRlcmZhY2UgRm9ybVZhbHVlIHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgZW1haWw6IHN0cmluZztcclxufVxyXG5cclxuY29uc3QgdXBkYXRlRm9ybVN0YXRlID0gdXBkYXRlR3JvdXA8Rm9ybVZhbHVlPihcclxuICB7XHJcbiAgICBuYW1lOiB2YWxpZGF0ZShyZXF1aXJlZCksXHJcbiAgfSxcclxuICB7XHJcbiAgICBlbWFpbDogKGVtYWlsLCBwYXJlbnRHcm91cCkgPT5cclxuICAgICAgcGFyZW50R3JvdXAuY29udHJvbHMubmFtZS5pc0ludmFsaWRcclxuICAgICAgICA/IHNldFZhbHVlKCcnLCBlbWFpbClcclxuICAgICAgICA6IGVtYWlsLFxyXG4gIH0sXHJcbik7XHJcblxyXG5jb25zdCByZWR1Y2VyID0gY3JlYXRlRm9ybVN0YXRlUmVkdWNlcldpdGhVcGRhdGU8Rm9ybVZhbHVlPih1cGRhdGVGb3JtU3RhdGUpO1xyXG5gYGBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb3JtU3RhdGVSZWR1Y2VyV2l0aFVwZGF0ZTxUVmFsdWU+KFxyXG4gIHVwZGF0ZUZuT3JVcGRhdGVGbkFycjogUHJvamVjdEZuPEZvcm1TdGF0ZTxUVmFsdWU+PiB8IFByb2plY3RGbjxGb3JtU3RhdGU8VFZhbHVlPj5bXSxcclxuICAuLi51cGRhdGVGbkFycjogUHJvamVjdEZuPEZvcm1TdGF0ZTxUVmFsdWU+PltdXHJcbik6IEFjdGlvblJlZHVjZXI8Rm9ybVN0YXRlPFRWYWx1ZT4+IHtcclxuICB1cGRhdGVGbkFyciA9IFsuLi4oQXJyYXkuaXNBcnJheSh1cGRhdGVGbk9yVXBkYXRlRm5BcnIpID8gdXBkYXRlRm5PclVwZGF0ZUZuQXJyIDogW3VwZGF0ZUZuT3JVcGRhdGVGbkFycl0pLCAuLi51cGRhdGVGbkFycl07XHJcbiAgcmV0dXJuIChzdGF0ZTogRm9ybVN0YXRlPFRWYWx1ZT4gfCB1bmRlZmluZWQsIGFjdGlvbjogQWN0aW9uKTogRm9ybVN0YXRlPFRWYWx1ZT4gPT4ge1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSBmb3JtU3RhdGVSZWR1Y2VyKHN0YXRlIGFzIEFic3RyYWN0Q29udHJvbFN0YXRlPFRWYWx1ZT4sIGFjdGlvbik7XHJcbiAgICByZXR1cm4gbmV3U3RhdGUgPT09IHN0YXRlID8gc3RhdGUgOiB1cGRhdGVGbkFyci5yZWR1Y2UoKHMsIGYpID0+IGYocyksIG5ld1N0YXRlKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWR1Y2VOZXN0ZWRGb3JtU3RhdGU8VFN0YXRlPihzdGF0ZTogVFN0YXRlLCBrZXk6IGtleW9mIFRTdGF0ZSwgYWN0aW9uOiBBY3Rpb24pOiBUU3RhdGUge1xyXG4gIGNvbnN0IHZhbHVlID0gc3RhdGVba2V5XTtcclxuXHJcbiAgaWYgKCFpc0Zvcm1TdGF0ZSh2YWx1ZSkpIHtcclxuICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIFtrZXldOiBmb3JtU3RhdGVSZWR1Y2VyKHZhbHVlLCBhY3Rpb24pLFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlZHVjZU5lc3RlZEZvcm1TdGF0ZXM8VFN0YXRlPihzdGF0ZTogVFN0YXRlLCBhY3Rpb246IEFjdGlvbik6IFRTdGF0ZSB7XHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHN0YXRlKS5yZWR1Y2UoKHMsIGtleSkgPT4gcmVkdWNlTmVzdGVkRm9ybVN0YXRlKHMsIGtleSBhcyBrZXlvZiBUU3RhdGUsIGFjdGlvbiksIHN0YXRlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIG5ncngncyBgY3JlYXRlUmVkdWNlcmBcclxuICogZnVuY3Rpb24gKGF2YWlsYWJsZSBzdGFydGluZyB3aXRoIG5ncnggdmVyc2lvbiA4KS4gQnkgZG9pbmcgdGhpcyBhbGwgZm9ybVxyXG4gKiBzdGF0ZSBwcm9wZXJ0aWVzIG9uIHRoZSBzdGF0ZSB3aWxsIGJlIHVwZGF0ZWQgd2hlbmV2ZXIgbmVjZXNzYXJ5IChpLmUuXHJcbiAqIHdoZW5ldmVyIGFuIG5ncngtZm9ybXMgYWN0aW9uIGlzIGRpc3BhdGNoZWQpLlxyXG4gKlxyXG4gKiBUbyBtYW51YWxseSB1cGRhdGUgYSBmb3JtIHN0YXRlIChlLmcuIHRvIHZhbGlkYXRlIGl0KSB1c2VcclxuICogYHdyYXBSZWR1Y2VyV2l0aEZvcm1TdGF0ZVVwZGF0ZWAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb25OZ3J4Rm9ybXM8VFN0YXRlID0gYW55PigpOiB7IHJlZHVjZXI6IEFjdGlvblJlZHVjZXI8VFN0YXRlPjsgdHlwZXM6IHN0cmluZ1tdIH0ge1xyXG4gIHJldHVybiB7XHJcbiAgICByZWR1Y2VyOiAoc3RhdGUsIGFjdGlvbikgPT4gcmVkdWNlTmVzdGVkRm9ybVN0YXRlcyhzdGF0ZSEsIGFjdGlvbiksXHJcbiAgICB0eXBlczogQUxMX05HUlhfRk9STVNfQUNUSU9OX1RZUEVTLFxyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uQ29uc3RydWN0b3Ige1xyXG4gIG5ldyguLi5hcmdzOiBhbnlbXSk6IEFjdGlvbnM8YW55PjtcclxuICByZWFkb25seSBUWVBFOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIENyZWF0ZWRBY3Rpb248VEFjdGlvbkNvbnM+ID0gVEFjdGlvbkNvbnMgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBpbmZlciBUQWN0aW9uID8gVEFjdGlvbiA6IG5ldmVyO1xyXG5cclxuLyoqXHJcbiAqIERlZmluZSBhIHJlZHVjZXIgZm9yIGEgbmdyeC1mb3JtcyBhY3Rpb24uIFRoaXMgZnVuY3Rpb25zIHdvcmtzIHRoZSBzYW1lIGFzXHJcbiAqIG5ncngncyBgb25gIGV4Y2VwdCB0aGF0IHlvdSBwcm92aWRlIHRoZSBuZ3J4LWZvcm1zIGFjdGlvbiBjbGFzcyBpbnN0ZWFkIG9mXHJcbiAqIHlvdXIgYWN0aW9uIGNyZWF0b3IgYXMgYSBwYXJhbWV0ZXIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb25OZ3J4Rm9ybXNBY3Rpb248XHJcbiAgVEFjdGlvbkNvbnMgZXh0ZW5kcyBBY3Rpb25Db25zdHJ1Y3RvcixcclxuICBUU3RhdGVcclxuPihcclxuICBhY3Rpb25Db25zOiBUQWN0aW9uQ29ucyxcclxuICByZWR1Y2VyOiAoc3RhdGU6IFRTdGF0ZSwgYWN0aW9uOiBDcmVhdGVkQWN0aW9uPFRBY3Rpb25Db25zPikgPT4gVFN0YXRlLFxyXG4pOiB7IHJlZHVjZXI6IEFjdGlvblJlZHVjZXI8VFN0YXRlPjsgdHlwZXM6IHN0cmluZ1tdIH0ge1xyXG4gIHJldHVybiB7XHJcbiAgICByZWR1Y2VyOiAoc3RhdGUsIGFjdGlvbikgPT4gcmVkdWNlcihyZWR1Y2VOZXN0ZWRGb3JtU3RhdGVzKHN0YXRlISwgYWN0aW9uKSwgYWN0aW9uIGFzIGFueSksXHJcbiAgICB0eXBlczogW2FjdGlvbkNvbnMuVFlQRV0sXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gd3JhcHMgYSByZWR1Y2VyIGFuZCByZXR1cm5zIGFub3RoZXIgcmVkdWNlciB0aGF0IGZpcnN0IGNhbGxzXHJcbiAqIHRoZSBnaXZlbiByZWR1Y2VyIGFuZCB0aGVuIGNhbGxzIHRoZSBnaXZlbiB1cGRhdGUgZnVuY3Rpb24gZm9yIHRoZSBmb3JtIHN0YXRlXHJcbiAqIHRoYXQgaXMgc3BlY2lmaWVkIGJ5IHRoZSBmb3JtIHN0YXRlIGxvY2F0b3IgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIFRoZSB1cGRhdGUgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBmb3JtIHN0YXRlIGFuZCB0aGUgdXBkYXRlZCBjb250YWluaW5nIHN0YXRlXHJcbiAqIGFzIHBhcmFtZXRlcnMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gd3JhcFJlZHVjZXJXaXRoRm9ybVN0YXRlVXBkYXRlPFRTdGF0ZSwgVEZvcm1TdGF0ZSBleHRlbmRzIEFic3RyYWN0Q29udHJvbFN0YXRlPGFueT4+KFxyXG4gIHJlZHVjZXI6IEFjdGlvblJlZHVjZXI8VFN0YXRlPixcclxuICBmb3JtU3RhdGVMb2NhdG9yOiAoc3RhdGU6IFRTdGF0ZSkgPT4gVEZvcm1TdGF0ZSxcclxuICB1cGRhdGVGbjogKGZvcm1TdGF0ZTogVEZvcm1TdGF0ZSwgc3RhdGU6IFRTdGF0ZSkgPT4gVEZvcm1TdGF0ZSxcclxuKTogQWN0aW9uUmVkdWNlcjxUU3RhdGU+IHtcclxuICByZXR1cm4gKHN0YXRlLCBhY3Rpb24pID0+IHtcclxuICAgIGNvbnN0IHVwZGF0ZWRTdGF0ZSA9IHJlZHVjZXIoc3RhdGUsIGFjdGlvbik7XHJcblxyXG4gICAgY29uc3QgZm9ybVN0YXRlID0gZm9ybVN0YXRlTG9jYXRvcih1cGRhdGVkU3RhdGUpO1xyXG4gICAgY29uc3QgZm9ybVN0YXRlS2V5ID0gT2JqZWN0LmtleXModXBkYXRlZFN0YXRlKS5maW5kKGtleSA9PiB1cGRhdGVkU3RhdGVba2V5IGFzIGtleW9mIFRTdGF0ZV0gYXMgYW55ID09PSBmb3JtU3RhdGUpITtcclxuXHJcbiAgICBjb25zdCB1cGRhdGVkRm9ybVN0YXRlID0gdXBkYXRlRm4oZm9ybVN0YXRlLCB1cGRhdGVkU3RhdGUpO1xyXG5cclxuICAgIGlmICh1cGRhdGVkRm9ybVN0YXRlID09PSBmb3JtU3RhdGUpIHtcclxuICAgICAgcmV0dXJuIHVwZGF0ZWRTdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAuLi51cGRhdGVkU3RhdGUsXHJcbiAgICAgIFtmb3JtU3RhdGVLZXldOiB1cGRhdGVkRm9ybVN0YXRlLFxyXG4gICAgfTtcclxuICB9O1xyXG59XHJcbiJdfQ==
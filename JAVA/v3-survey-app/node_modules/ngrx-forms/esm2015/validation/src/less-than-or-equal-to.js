import { unbox } from 'ngrx-forms';
/**
 * A validation function that requires the value to be less than or equal to a number.
 * Considers `null` and `undefined` as valid. Combine this function with the `required`
 * validation function if `null` or `undefined` should be considered invalid.
 *
 * The validation error returned by this validation function has the following shape:
 *
```typescript
{
  lessThanOrEqualTo: {
    comparand: number;
    actual: number;
  };
}
```
 *
 * Usually you would use this validation function in conjunction with the `validate`
 * update function to perform synchronous validation in your reducer:
 *
```typescript
updateGroup<MyFormValue>({
  amount: validate(lessThanOrEqualTo(10)),
})
```
 *
 * Note that this function is generic to allow the compiler to properly infer the type
 * of the `validate` function for both optional and non-optional controls.
 */
export function lessThanOrEqualTo(comparand) {
    // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)
    if (comparand === null || comparand === undefined) {
        throw new Error(`The lessThanOrEqualTo Validation function requires the comparand parameter to be a non-null number, got ${comparand}!`);
    }
    return (value) => {
        value = unbox(value);
        if (value === null || value === undefined) {
            return {};
        }
        if (value <= comparand) {
            return {};
        }
        return {
            lessThanOrEqualTo: {
                comparand,
                actual: value,
            },
        };
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGVzcy10aGFuLW9yLWVxdWFsLXRvLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmdyeC1mb3Jtcy92YWxpZGF0aW9uLyIsInNvdXJjZXMiOlsic3JjL2xlc3MtdGhhbi1vci1lcXVhbC10by50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQVMsS0FBSyxFQUFvQixNQUFNLFlBQVksQ0FBQztBQWM1RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMkJHO0FBQ0gsTUFBTSxVQUFVLGlCQUFpQixDQUFDLFNBQWlCO0lBQ2pELGlHQUFpRztJQUNqRyxJQUFJLFNBQVMsS0FBSyxJQUFJLElBQUksU0FBUyxLQUFLLFNBQVMsRUFBRTtRQUNqRCxNQUFNLElBQUksS0FBSyxDQUFDLDJHQUEyRyxTQUFTLEdBQUcsQ0FBQyxDQUFDO0tBQzFJO0lBRUQsT0FBTyxDQUFzRCxLQUFRLEVBQW9CLEVBQUU7UUFDekYsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQW1DLENBQUM7UUFFdkQsSUFBSSxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUU7WUFDekMsT0FBTyxFQUFFLENBQUM7U0FDWDtRQUVELElBQUksS0FBSyxJQUFJLFNBQVMsRUFBRTtZQUN0QixPQUFPLEVBQUUsQ0FBQztTQUNYO1FBRUQsT0FBTztZQUNMLGlCQUFpQixFQUFFO2dCQUNqQixTQUFTO2dCQUNULE1BQU0sRUFBRSxLQUFlO2FBQ3hCO1NBQ0YsQ0FBQztJQUNKLENBQUMsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCb3hlZCwgdW5ib3gsIFZhbGlkYXRpb25FcnJvcnMgfSBmcm9tICduZ3J4LWZvcm1zJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTGVzc1RoYW5PckVxdWFsVG9WYWxpZGF0aW9uRXJyb3Ige1xyXG4gIGNvbXBhcmFuZDogbnVtYmVyO1xyXG4gIGFjdHVhbDogbnVtYmVyO1xyXG59XHJcblxyXG4vLyBAdHMtaWdub3JlXHJcbmRlY2xhcmUgbW9kdWxlICduZ3J4LWZvcm1zL3NyYy9zdGF0ZScge1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvbkVycm9ycyB7XHJcbiAgICBsZXNzVGhhbk9yRXF1YWxUbz86IExlc3NUaGFuT3JFcXVhbFRvVmFsaWRhdGlvbkVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgdmFsaWRhdGlvbiBmdW5jdGlvbiB0aGF0IHJlcXVpcmVzIHRoZSB2YWx1ZSB0byBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYSBudW1iZXIuXHJcbiAqIENvbnNpZGVycyBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFzIHZhbGlkLiBDb21iaW5lIHRoaXMgZnVuY3Rpb24gd2l0aCB0aGUgYHJlcXVpcmVkYFxyXG4gKiB2YWxpZGF0aW9uIGZ1bmN0aW9uIGlmIGBudWxsYCBvciBgdW5kZWZpbmVkYCBzaG91bGQgYmUgY29uc2lkZXJlZCBpbnZhbGlkLlxyXG4gKlxyXG4gKiBUaGUgdmFsaWRhdGlvbiBlcnJvciByZXR1cm5lZCBieSB0aGlzIHZhbGlkYXRpb24gZnVuY3Rpb24gaGFzIHRoZSBmb2xsb3dpbmcgc2hhcGU6XHJcbiAqXHJcbmBgYHR5cGVzY3JpcHRcclxue1xyXG4gIGxlc3NUaGFuT3JFcXVhbFRvOiB7XHJcbiAgICBjb21wYXJhbmQ6IG51bWJlcjtcclxuICAgIGFjdHVhbDogbnVtYmVyO1xyXG4gIH07XHJcbn1cclxuYGBgXHJcbiAqXHJcbiAqIFVzdWFsbHkgeW91IHdvdWxkIHVzZSB0aGlzIHZhbGlkYXRpb24gZnVuY3Rpb24gaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYHZhbGlkYXRlYFxyXG4gKiB1cGRhdGUgZnVuY3Rpb24gdG8gcGVyZm9ybSBzeW5jaHJvbm91cyB2YWxpZGF0aW9uIGluIHlvdXIgcmVkdWNlcjpcclxuICpcclxuYGBgdHlwZXNjcmlwdFxyXG51cGRhdGVHcm91cDxNeUZvcm1WYWx1ZT4oe1xyXG4gIGFtb3VudDogdmFsaWRhdGUobGVzc1RoYW5PckVxdWFsVG8oMTApKSxcclxufSlcclxuYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIGdlbmVyaWMgdG8gYWxsb3cgdGhlIGNvbXBpbGVyIHRvIHByb3Blcmx5IGluZmVyIHRoZSB0eXBlXHJcbiAqIG9mIHRoZSBgdmFsaWRhdGVgIGZ1bmN0aW9uIGZvciBib3RoIG9wdGlvbmFsIGFuZCBub24tb3B0aW9uYWwgY29udHJvbHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsVG8oY29tcGFyYW5kOiBudW1iZXIpIHtcclxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6c3RyaWN0LXR5cGUtcHJlZGljYXRlcyAoZ3VhcmQgZm9yIHVzZXJzIHdpdGhvdXQgc3RyaWN0IHR5cGUgY2hlY2tpbmcpXHJcbiAgaWYgKGNvbXBhcmFuZCA9PT0gbnVsbCB8fCBjb21wYXJhbmQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbGVzc1RoYW5PckVxdWFsVG8gVmFsaWRhdGlvbiBmdW5jdGlvbiByZXF1aXJlcyB0aGUgY29tcGFyYW5kIHBhcmFtZXRlciB0byBiZSBhIG5vbi1udWxsIG51bWJlciwgZ290ICR7Y29tcGFyYW5kfSFgKTtcclxuICB9XHJcblxyXG4gIHJldHVybiA8VCBleHRlbmRzIG51bWJlciB8IEJveGVkPG51bWJlcj4gfCBudWxsIHwgdW5kZWZpbmVkPih2YWx1ZTogVCk6IFZhbGlkYXRpb25FcnJvcnMgPT4ge1xyXG4gICAgdmFsdWUgPSB1bmJveCh2YWx1ZSkgYXMgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCBhcyBUO1xyXG5cclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsdWUgPD0gY29tcGFyYW5kKSB7XHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsZXNzVGhhbk9yRXF1YWxUbzoge1xyXG4gICAgICAgIGNvbXBhcmFuZCxcclxuICAgICAgICBhY3R1YWw6IHZhbHVlIGFzIG51bWJlcixcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfTtcclxufVxyXG4iXX0=
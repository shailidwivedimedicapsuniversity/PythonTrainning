import { unbox } from 'ngrx-forms';
/**
 * A validation function that requires a value to match a regex.
 * Considers `null`, `undefined`, and `''` as valid. Combine this function with the
 * `required` validation function if these values should be considered invalid.
 *
 * The validation error returned by this validation function has the following shape:
 *
```typescript
{
  pattern: {
    pattern: string;
    actual: string;
  };
}
```
 *
 * Usually you would use this validation function in conjunction with the `validate`
 * update function to perform synchronous validation in your reducer:
 *
```typescript
updateGroup<MyFormValue>({
  numberWithPeriodsOrCommas: validate(pattern(/^[0-9.,]+$/)),
})
```
 *
 * Note that this function is generic to allow the compiler to properly infer the type
 * of the `validate` function for both optional and non-optional controls.
 */
export function pattern(patternParam) {
    // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)
    if (patternParam === null || patternParam === undefined) {
        throw new Error(`The pattern Validation function requires the pattern parameter to be a non-null string or regular expression, got ${patternParam}!`);
    }
    return (value) => {
        value = unbox(value);
        if (value === null || value === undefined || value.length === 0) {
            return {};
        }
        if (patternParam.test(value)) {
            return {};
        }
        return {
            pattern: {
                pattern: patternParam.toString(),
                actual: value,
            },
        };
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGF0dGVybi5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25ncngtZm9ybXMvdmFsaWRhdGlvbi8iLCJzb3VyY2VzIjpbInNyYy9wYXR0ZXJuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBUyxLQUFLLEVBQW9CLE1BQU0sWUFBWSxDQUFDO0FBYzVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EyQkc7QUFDSCxNQUFNLFVBQVUsT0FBTyxDQUFDLFlBQW9CO0lBQzFDLGlHQUFpRztJQUNqRyxJQUFJLFlBQVksS0FBSyxJQUFJLElBQUksWUFBWSxLQUFLLFNBQVMsRUFBRTtRQUN2RCxNQUFNLElBQUksS0FBSyxDQUFDLHFIQUFxSCxZQUFZLEdBQUcsQ0FBQyxDQUFDO0tBQ3ZKO0lBRUQsT0FBTyxDQUFzRCxLQUFRLEVBQW9CLEVBQUU7UUFDekYsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQW1DLENBQUM7UUFFdkQsSUFBSSxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxTQUFTLElBQUssS0FBZ0IsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQzNFLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFFRCxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBZSxDQUFDLEVBQUU7WUFDdEMsT0FBTyxFQUFFLENBQUM7U0FDWDtRQUVELE9BQU87WUFDTCxPQUFPLEVBQUU7Z0JBQ1AsT0FBTyxFQUFFLFlBQVksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2hDLE1BQU0sRUFBRSxLQUFlO2FBQ3hCO1NBQ0YsQ0FBQztJQUNKLENBQUMsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCb3hlZCwgdW5ib3gsIFZhbGlkYXRpb25FcnJvcnMgfSBmcm9tICduZ3J4LWZvcm1zJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGF0dGVyblZhbGlkYXRpb25FcnJvciB7XHJcbiAgcGF0dGVybjogc3RyaW5nO1xyXG4gIGFjdHVhbDogc3RyaW5nO1xyXG59XHJcblxyXG4vLyBAdHMtaWdub3JlXHJcbmRlY2xhcmUgbW9kdWxlICduZ3J4LWZvcm1zL3NyYy9zdGF0ZScge1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvbkVycm9ycyB7XHJcbiAgICBwYXR0ZXJuPzogUGF0dGVyblZhbGlkYXRpb25FcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHZhbGlkYXRpb24gZnVuY3Rpb24gdGhhdCByZXF1aXJlcyBhIHZhbHVlIHRvIG1hdGNoIGEgcmVnZXguXHJcbiAqIENvbnNpZGVycyBgbnVsbGAsIGB1bmRlZmluZWRgLCBhbmQgYCcnYCBhcyB2YWxpZC4gQ29tYmluZSB0aGlzIGZ1bmN0aW9uIHdpdGggdGhlXHJcbiAqIGByZXF1aXJlZGAgdmFsaWRhdGlvbiBmdW5jdGlvbiBpZiB0aGVzZSB2YWx1ZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW52YWxpZC5cclxuICpcclxuICogVGhlIHZhbGlkYXRpb24gZXJyb3IgcmV0dXJuZWQgYnkgdGhpcyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGhhcyB0aGUgZm9sbG93aW5nIHNoYXBlOlxyXG4gKlxyXG5gYGB0eXBlc2NyaXB0XHJcbntcclxuICBwYXR0ZXJuOiB7XHJcbiAgICBwYXR0ZXJuOiBzdHJpbmc7XHJcbiAgICBhY3R1YWw6IHN0cmluZztcclxuICB9O1xyXG59XHJcbmBgYFxyXG4gKlxyXG4gKiBVc3VhbGx5IHlvdSB3b3VsZCB1c2UgdGhpcyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGB2YWxpZGF0ZWBcclxuICogdXBkYXRlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gc3luY2hyb25vdXMgdmFsaWRhdGlvbiBpbiB5b3VyIHJlZHVjZXI6XHJcbiAqXHJcbmBgYHR5cGVzY3JpcHRcclxudXBkYXRlR3JvdXA8TXlGb3JtVmFsdWU+KHtcclxuICBudW1iZXJXaXRoUGVyaW9kc09yQ29tbWFzOiB2YWxpZGF0ZShwYXR0ZXJuKC9eWzAtOS4sXSskLykpLFxyXG59KVxyXG5gYGBcclxuICpcclxuICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgZ2VuZXJpYyB0byBhbGxvdyB0aGUgY29tcGlsZXIgdG8gcHJvcGVybHkgaW5mZXIgdGhlIHR5cGVcclxuICogb2YgdGhlIGB2YWxpZGF0ZWAgZnVuY3Rpb24gZm9yIGJvdGggb3B0aW9uYWwgYW5kIG5vbi1vcHRpb25hbCBjb250cm9scy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXR0ZXJuKHBhdHRlcm5QYXJhbTogUmVnRXhwKSB7XHJcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnN0cmljdC10eXBlLXByZWRpY2F0ZXMgKGd1YXJkIGZvciB1c2VycyB3aXRob3V0IHN0cmljdCB0eXBlIGNoZWNraW5nKVxyXG4gIGlmIChwYXR0ZXJuUGFyYW0gPT09IG51bGwgfHwgcGF0dGVyblBhcmFtID09PSB1bmRlZmluZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHBhdHRlcm4gVmFsaWRhdGlvbiBmdW5jdGlvbiByZXF1aXJlcyB0aGUgcGF0dGVybiBwYXJhbWV0ZXIgdG8gYmUgYSBub24tbnVsbCBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uLCBnb3QgJHtwYXR0ZXJuUGFyYW19IWApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIDxUIGV4dGVuZHMgc3RyaW5nIHwgQm94ZWQ8c3RyaW5nPiB8IG51bGwgfCB1bmRlZmluZWQ+KHZhbHVlOiBUKTogVmFsaWRhdGlvbkVycm9ycyA9PiB7XHJcbiAgICB2YWx1ZSA9IHVuYm94KHZhbHVlKSBhcyBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkIGFzIFQ7XHJcblxyXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgKHZhbHVlIGFzIHN0cmluZykubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGF0dGVyblBhcmFtLnRlc3QodmFsdWUgYXMgc3RyaW5nKSkge1xyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGF0dGVybjoge1xyXG4gICAgICAgIHBhdHRlcm46IHBhdHRlcm5QYXJhbS50b1N0cmluZygpLFxyXG4gICAgICAgIGFjdHVhbDogdmFsdWUgYXMgc3RyaW5nLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9O1xyXG59XHJcbiJdfQ==
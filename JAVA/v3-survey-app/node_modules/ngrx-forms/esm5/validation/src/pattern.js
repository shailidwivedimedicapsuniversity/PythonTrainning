import { unbox } from 'ngrx-forms';
/**
 * A validation function that requires a value to match a regex.
 * Considers `null`, `undefined`, and `''` as valid. Combine this function with the
 * `required` validation function if these values should be considered invalid.
 *
 * The validation error returned by this validation function has the following shape:
 *
```typescript
{
  pattern: {
    pattern: string;
    actual: string;
  };
}
```
 *
 * Usually you would use this validation function in conjunction with the `validate`
 * update function to perform synchronous validation in your reducer:
 *
```typescript
updateGroup<MyFormValue>({
  numberWithPeriodsOrCommas: validate(pattern(/^[0-9.,]+$/)),
})
```
 *
 * Note that this function is generic to allow the compiler to properly infer the type
 * of the `validate` function for both optional and non-optional controls.
 */
export function pattern(patternParam) {
    // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)
    if (patternParam === null || patternParam === undefined) {
        throw new Error("The pattern Validation function requires the pattern parameter to be a non-null string or regular expression, got " + patternParam + "!");
    }
    return function (value) {
        value = unbox(value);
        if (value === null || value === undefined || value.length === 0) {
            return {};
        }
        if (patternParam.test(value)) {
            return {};
        }
        return {
            pattern: {
                pattern: patternParam.toString(),
                actual: value,
            },
        };
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGF0dGVybi5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25ncngtZm9ybXMvdmFsaWRhdGlvbi8iLCJzb3VyY2VzIjpbInNyYy9wYXR0ZXJuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBUyxLQUFLLEVBQW9CLE1BQU0sWUFBWSxDQUFDO0FBYzVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EyQkc7QUFDSCxNQUFNLFVBQVUsT0FBTyxDQUFDLFlBQW9CO0lBQzFDLGlHQUFpRztJQUNqRyxJQUFJLFlBQVksS0FBSyxJQUFJLElBQUksWUFBWSxLQUFLLFNBQVMsRUFBRTtRQUN2RCxNQUFNLElBQUksS0FBSyxDQUFDLHVIQUFxSCxZQUFZLE1BQUcsQ0FBQyxDQUFDO0tBQ3ZKO0lBRUQsT0FBTyxVQUFzRCxLQUFRO1FBQ25FLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFtQyxDQUFDO1FBRXZELElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFLLEtBQWdCLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMzRSxPQUFPLEVBQUUsQ0FBQztTQUNYO1FBRUQsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQWUsQ0FBQyxFQUFFO1lBQ3RDLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFFRCxPQUFPO1lBQ0wsT0FBTyxFQUFFO2dCQUNQLE9BQU8sRUFBRSxZQUFZLENBQUMsUUFBUSxFQUFFO2dCQUNoQyxNQUFNLEVBQUUsS0FBZTthQUN4QjtTQUNGLENBQUM7SUFDSixDQUFDLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQm94ZWQsIHVuYm94LCBWYWxpZGF0aW9uRXJyb3JzIH0gZnJvbSAnbmdyeC1mb3Jtcyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFBhdHRlcm5WYWxpZGF0aW9uRXJyb3Ige1xyXG4gIHBhdHRlcm46IHN0cmluZztcclxuICBhY3R1YWw6IHN0cmluZztcclxufVxyXG5cclxuLy8gQHRzLWlnbm9yZVxyXG5kZWNsYXJlIG1vZHVsZSAnbmdyeC1mb3Jtcy9zcmMvc3RhdGUnIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25FcnJvcnMge1xyXG4gICAgcGF0dGVybj86IFBhdHRlcm5WYWxpZGF0aW9uRXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQSB2YWxpZGF0aW9uIGZ1bmN0aW9uIHRoYXQgcmVxdWlyZXMgYSB2YWx1ZSB0byBtYXRjaCBhIHJlZ2V4LlxyXG4gKiBDb25zaWRlcnMgYG51bGxgLCBgdW5kZWZpbmVkYCwgYW5kIGAnJ2AgYXMgdmFsaWQuIENvbWJpbmUgdGhpcyBmdW5jdGlvbiB3aXRoIHRoZVxyXG4gKiBgcmVxdWlyZWRgIHZhbGlkYXRpb24gZnVuY3Rpb24gaWYgdGhlc2UgdmFsdWVzIHNob3VsZCBiZSBjb25zaWRlcmVkIGludmFsaWQuXHJcbiAqXHJcbiAqIFRoZSB2YWxpZGF0aW9uIGVycm9yIHJldHVybmVkIGJ5IHRoaXMgdmFsaWRhdGlvbiBmdW5jdGlvbiBoYXMgdGhlIGZvbGxvd2luZyBzaGFwZTpcclxuICpcclxuYGBgdHlwZXNjcmlwdFxyXG57XHJcbiAgcGF0dGVybjoge1xyXG4gICAgcGF0dGVybjogc3RyaW5nO1xyXG4gICAgYWN0dWFsOiBzdHJpbmc7XHJcbiAgfTtcclxufVxyXG5gYGBcclxuICpcclxuICogVXN1YWxseSB5b3Ugd291bGQgdXNlIHRoaXMgdmFsaWRhdGlvbiBmdW5jdGlvbiBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgdmFsaWRhdGVgXHJcbiAqIHVwZGF0ZSBmdW5jdGlvbiB0byBwZXJmb3JtIHN5bmNocm9ub3VzIHZhbGlkYXRpb24gaW4geW91ciByZWR1Y2VyOlxyXG4gKlxyXG5gYGB0eXBlc2NyaXB0XHJcbnVwZGF0ZUdyb3VwPE15Rm9ybVZhbHVlPih7XHJcbiAgbnVtYmVyV2l0aFBlcmlvZHNPckNvbW1hczogdmFsaWRhdGUocGF0dGVybigvXlswLTkuLF0rJC8pKSxcclxufSlcclxuYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIGdlbmVyaWMgdG8gYWxsb3cgdGhlIGNvbXBpbGVyIHRvIHByb3Blcmx5IGluZmVyIHRoZSB0eXBlXHJcbiAqIG9mIHRoZSBgdmFsaWRhdGVgIGZ1bmN0aW9uIGZvciBib3RoIG9wdGlvbmFsIGFuZCBub24tb3B0aW9uYWwgY29udHJvbHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGF0dGVybihwYXR0ZXJuUGFyYW06IFJlZ0V4cCkge1xyXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpzdHJpY3QtdHlwZS1wcmVkaWNhdGVzIChndWFyZCBmb3IgdXNlcnMgd2l0aG91dCBzdHJpY3QgdHlwZSBjaGVja2luZylcclxuICBpZiAocGF0dGVyblBhcmFtID09PSBudWxsIHx8IHBhdHRlcm5QYXJhbSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwYXR0ZXJuIFZhbGlkYXRpb24gZnVuY3Rpb24gcmVxdWlyZXMgdGhlIHBhdHRlcm4gcGFyYW1ldGVyIHRvIGJlIGEgbm9uLW51bGwgc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbiwgZ290ICR7cGF0dGVyblBhcmFtfSFgKTtcclxuICB9XHJcblxyXG4gIHJldHVybiA8VCBleHRlbmRzIHN0cmluZyB8IEJveGVkPHN0cmluZz4gfCBudWxsIHwgdW5kZWZpbmVkPih2YWx1ZTogVCk6IFZhbGlkYXRpb25FcnJvcnMgPT4ge1xyXG4gICAgdmFsdWUgPSB1bmJveCh2YWx1ZSkgYXMgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCBhcyBUO1xyXG5cclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSBhcyBzdHJpbmcpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBhdHRlcm5QYXJhbS50ZXN0KHZhbHVlIGFzIHN0cmluZykpIHtcclxuICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHBhdHRlcm46IHtcclxuICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuUGFyYW0udG9TdHJpbmcoKSxcclxuICAgICAgICBhY3R1YWw6IHZhbHVlIGFzIHN0cmluZyxcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfTtcclxufVxyXG4iXX0=
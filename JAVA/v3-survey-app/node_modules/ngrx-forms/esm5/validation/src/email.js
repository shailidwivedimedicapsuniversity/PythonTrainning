import { unbox } from 'ngrx-forms';
// this regex is taken from the @angular/forms source code
// tslint:disable-next-line:max-line-length
export var NGRX_FORMS_EMAIL_VALIDATION_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
/**
 * A validation function that requires a value to be a valid e-mail address.
 * Considers `null`, `undefined`, and `''` as valid. Combine this function with the
 * `required` validation function if these values should be considered invalid.
 *
 * The validation error returned by this validation function has the following shape:
 *
```typescript
{
  email: {
    pattern: string;
    actual: string;
  };
}
```
 *
 * Usually you would use this validation function in conjunction with the `validate`
 * update function to perform synchronous validation in your reducer:
 *
```typescript
updateGroup<MyFormValue>({
  userMailAddress: validate(email),
})
```
 *
 * Note that this function is generic to allow the compiler to properly infer the type
 * of the `validate` function for both optional and non-optional controls.
 */
export function email(value) {
    value = unbox(value);
    if (value === null || value === undefined || value.length === 0) {
        return {};
    }
    if (NGRX_FORMS_EMAIL_VALIDATION_REGEXP.test(value)) {
        return {};
    }
    return {
        email: {
            pattern: NGRX_FORMS_EMAIL_VALIDATION_REGEXP.toString(),
            actual: value,
        },
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1haWwuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3J4LWZvcm1zL3ZhbGlkYXRpb24vIiwic291cmNlcyI6WyJzcmMvZW1haWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFTLEtBQUssRUFBb0IsTUFBTSxZQUFZLENBQUM7QUFFNUQsMERBQTBEO0FBQzFELDJDQUEyQztBQUMzQyxNQUFNLENBQUMsSUFBTSxrQ0FBa0MsR0FBRyw0TEFBNEwsQ0FBQztBQWMvTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMkJHO0FBQ0gsTUFBTSxVQUFVLEtBQUssQ0FBc0QsS0FBUTtJQUNqRixLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBbUMsQ0FBQztJQUV2RCxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLFNBQVMsSUFBSyxLQUFnQixDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDM0UsT0FBTyxFQUFFLENBQUM7S0FDWDtJQUVELElBQUksa0NBQWtDLENBQUMsSUFBSSxDQUFDLEtBQWUsQ0FBQyxFQUFFO1FBQzVELE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFFRCxPQUFPO1FBQ0wsS0FBSyxFQUFFO1lBQ0wsT0FBTyxFQUFFLGtDQUFrQyxDQUFDLFFBQVEsRUFBRTtZQUN0RCxNQUFNLEVBQUUsS0FBZTtTQUN4QjtLQUNGLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQm94ZWQsIHVuYm94LCBWYWxpZGF0aW9uRXJyb3JzIH0gZnJvbSAnbmdyeC1mb3Jtcyc7XHJcblxyXG4vLyB0aGlzIHJlZ2V4IGlzIHRha2VuIGZyb20gdGhlIEBhbmd1bGFyL2Zvcm1zIHNvdXJjZSBjb2RlXHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcclxuZXhwb3J0IGNvbnN0IE5HUlhfRk9STVNfRU1BSUxfVkFMSURBVElPTl9SRUdFWFAgPSAvXig/PS57MSwyNTR9JCkoPz0uezEsNjR9QClbLSEjJCUmJyorLzAtOT0/QS1aXl9gYS16e3x9fl0rKFxcLlstISMkJSYnKisvMC05PT9BLVpeX2BhLXp7fH1+XSspKkBbQS1aYS16MC05XShbQS1aYS16MC05LV17MCw2MX1bQS1aYS16MC05XSk/KFxcLltBLVphLXowLTldKFtBLVphLXowLTktXXswLDYxfVtBLVphLXowLTldKT8pKiQvO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFbWFpbFZhbGlkYXRpb25FcnJvciB7XHJcbiAgcGF0dGVybjogc3RyaW5nO1xyXG4gIGFjdHVhbDogc3RyaW5nO1xyXG59XHJcblxyXG4vLyBAdHMtaWdub3JlXHJcbmRlY2xhcmUgbW9kdWxlICduZ3J4LWZvcm1zL3NyYy9zdGF0ZScge1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvbkVycm9ycyB7XHJcbiAgICBlbWFpbD86IEVtYWlsVmFsaWRhdGlvbkVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgdmFsaWRhdGlvbiBmdW5jdGlvbiB0aGF0IHJlcXVpcmVzIGEgdmFsdWUgdG8gYmUgYSB2YWxpZCBlLW1haWwgYWRkcmVzcy5cclxuICogQ29uc2lkZXJzIGBudWxsYCwgYHVuZGVmaW5lZGAsIGFuZCBgJydgIGFzIHZhbGlkLiBDb21iaW5lIHRoaXMgZnVuY3Rpb24gd2l0aCB0aGVcclxuICogYHJlcXVpcmVkYCB2YWxpZGF0aW9uIGZ1bmN0aW9uIGlmIHRoZXNlIHZhbHVlcyBzaG91bGQgYmUgY29uc2lkZXJlZCBpbnZhbGlkLlxyXG4gKlxyXG4gKiBUaGUgdmFsaWRhdGlvbiBlcnJvciByZXR1cm5lZCBieSB0aGlzIHZhbGlkYXRpb24gZnVuY3Rpb24gaGFzIHRoZSBmb2xsb3dpbmcgc2hhcGU6XHJcbiAqXHJcbmBgYHR5cGVzY3JpcHRcclxue1xyXG4gIGVtYWlsOiB7XHJcbiAgICBwYXR0ZXJuOiBzdHJpbmc7XHJcbiAgICBhY3R1YWw6IHN0cmluZztcclxuICB9O1xyXG59XHJcbmBgYFxyXG4gKlxyXG4gKiBVc3VhbGx5IHlvdSB3b3VsZCB1c2UgdGhpcyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGB2YWxpZGF0ZWBcclxuICogdXBkYXRlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gc3luY2hyb25vdXMgdmFsaWRhdGlvbiBpbiB5b3VyIHJlZHVjZXI6XHJcbiAqXHJcbmBgYHR5cGVzY3JpcHRcclxudXBkYXRlR3JvdXA8TXlGb3JtVmFsdWU+KHtcclxuICB1c2VyTWFpbEFkZHJlc3M6IHZhbGlkYXRlKGVtYWlsKSxcclxufSlcclxuYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIGdlbmVyaWMgdG8gYWxsb3cgdGhlIGNvbXBpbGVyIHRvIHByb3Blcmx5IGluZmVyIHRoZSB0eXBlXHJcbiAqIG9mIHRoZSBgdmFsaWRhdGVgIGZ1bmN0aW9uIGZvciBib3RoIG9wdGlvbmFsIGFuZCBub24tb3B0aW9uYWwgY29udHJvbHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZW1haWw8VCBleHRlbmRzIHN0cmluZyB8IEJveGVkPHN0cmluZz4gfCBudWxsIHwgdW5kZWZpbmVkPih2YWx1ZTogVCk6IFZhbGlkYXRpb25FcnJvcnMge1xyXG4gIHZhbHVlID0gdW5ib3godmFsdWUpIGFzIHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQgYXMgVDtcclxuXHJcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgKHZhbHVlIGFzIHN0cmluZykubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfVxyXG5cclxuICBpZiAoTkdSWF9GT1JNU19FTUFJTF9WQUxJREFUSU9OX1JFR0VYUC50ZXN0KHZhbHVlIGFzIHN0cmluZykpIHtcclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBlbWFpbDoge1xyXG4gICAgICBwYXR0ZXJuOiBOR1JYX0ZPUk1TX0VNQUlMX1ZBTElEQVRJT05fUkVHRVhQLnRvU3RyaW5nKCksXHJcbiAgICAgIGFjdHVhbDogdmFsdWUgYXMgc3RyaW5nLFxyXG4gICAgfSxcclxuICB9O1xyXG59XHJcbiJdfQ==
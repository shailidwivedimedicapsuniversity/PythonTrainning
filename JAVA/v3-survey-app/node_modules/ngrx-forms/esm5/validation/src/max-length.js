import { unbox } from 'ngrx-forms';
/**
 * A validation function that requires a `string` or `array` value to have a maximum length.
 * Considers `null` and `undefined` as valid. Combine this function with the `required`
 * validation function if `null` or `undefined` should be considered invalid.
 *
 * The validation error returned by this validation function has the following shape:
 *
```typescript
{
  maxLength: {
    maxLength: number;
    value: string;
    actualLength: number;
  };
}
```
 *
 * Usually you would use this validation function in conjunction with the `validate`
 * update function to perform synchronous validation in your reducer:
 *
```typescript
updateGroup<MyFormValue>({
  name: validate(maxLength(10)),
})
```
 *
 * Note that this function is generic to allow the compiler to properly infer the type
 * of the `validate` function for both optional and non-optional controls.
 */
export function maxLength(maxLengthParam) {
    // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)
    if (maxLengthParam === null || maxLengthParam === undefined) {
        throw new Error("The maxLength Validation function requires the maxLength parameter to be a non-null number, got " + maxLengthParam + "!");
    }
    return function (value) {
        value = unbox(value);
        if (value === null || value === undefined) {
            return {};
        }
        var length = value.length;
        if (length <= maxLengthParam) {
            return {};
        }
        return {
            maxLength: {
                maxLength: maxLengthParam,
                value: value,
                actualLength: length,
            },
        };
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF4LWxlbmd0aC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25ncngtZm9ybXMvdmFsaWRhdGlvbi8iLCJzb3VyY2VzIjpbInNyYy9tYXgtbGVuZ3RoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBUyxLQUFLLEVBQW9CLE1BQU0sWUFBWSxDQUFDO0FBZTVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNEJHO0FBQ0gsTUFBTSxVQUFVLFNBQVMsQ0FBQyxjQUFzQjtJQUM5QyxpR0FBaUc7SUFDakcsSUFBSSxjQUFjLEtBQUssSUFBSSxJQUFJLGNBQWMsS0FBSyxTQUFTLEVBQUU7UUFDM0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxxR0FBbUcsY0FBYyxNQUFHLENBQUMsQ0FBQztLQUN2STtJQUVELE9BQU8sVUFBNkUsS0FBUTtRQUMxRixLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXJCLElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ3pDLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFFRCxJQUFNLE1BQU0sR0FBSSxLQUF3QixDQUFDLE1BQU0sQ0FBQztRQUVoRCxJQUFJLE1BQU0sSUFBSSxjQUFjLEVBQUU7WUFDNUIsT0FBTyxFQUFFLENBQUM7U0FDWDtRQUVELE9BQU87WUFDTCxTQUFTLEVBQUU7Z0JBQ1QsU0FBUyxFQUFFLGNBQWM7Z0JBQ3pCLEtBQUssRUFBRSxLQUFlO2dCQUN0QixZQUFZLEVBQUUsTUFBTTthQUNyQjtTQUNGLENBQUM7SUFDSixDQUFDLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQm94ZWQsIHVuYm94LCBWYWxpZGF0aW9uRXJyb3JzIH0gZnJvbSAnbmdyeC1mb3Jtcyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1heExlbmd0aFZhbGlkYXRpb25FcnJvciB7XHJcbiAgbWF4TGVuZ3RoOiBudW1iZXI7XHJcbiAgdmFsdWU6IHN0cmluZztcclxuICBhY3R1YWxMZW5ndGg6IG51bWJlcjtcclxufVxyXG5cclxuLy8gQHRzLWlnbm9yZVxyXG5kZWNsYXJlIG1vZHVsZSAnbmdyeC1mb3Jtcy9zcmMvc3RhdGUnIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25FcnJvcnMge1xyXG4gICAgbWF4TGVuZ3RoPzogTWF4TGVuZ3RoVmFsaWRhdGlvbkVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgdmFsaWRhdGlvbiBmdW5jdGlvbiB0aGF0IHJlcXVpcmVzIGEgYHN0cmluZ2Agb3IgYGFycmF5YCB2YWx1ZSB0byBoYXZlIGEgbWF4aW11bSBsZW5ndGguXHJcbiAqIENvbnNpZGVycyBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFzIHZhbGlkLiBDb21iaW5lIHRoaXMgZnVuY3Rpb24gd2l0aCB0aGUgYHJlcXVpcmVkYFxyXG4gKiB2YWxpZGF0aW9uIGZ1bmN0aW9uIGlmIGBudWxsYCBvciBgdW5kZWZpbmVkYCBzaG91bGQgYmUgY29uc2lkZXJlZCBpbnZhbGlkLlxyXG4gKlxyXG4gKiBUaGUgdmFsaWRhdGlvbiBlcnJvciByZXR1cm5lZCBieSB0aGlzIHZhbGlkYXRpb24gZnVuY3Rpb24gaGFzIHRoZSBmb2xsb3dpbmcgc2hhcGU6XHJcbiAqXHJcbmBgYHR5cGVzY3JpcHRcclxue1xyXG4gIG1heExlbmd0aDoge1xyXG4gICAgbWF4TGVuZ3RoOiBudW1iZXI7XHJcbiAgICB2YWx1ZTogc3RyaW5nO1xyXG4gICAgYWN0dWFsTGVuZ3RoOiBudW1iZXI7XHJcbiAgfTtcclxufVxyXG5gYGBcclxuICpcclxuICogVXN1YWxseSB5b3Ugd291bGQgdXNlIHRoaXMgdmFsaWRhdGlvbiBmdW5jdGlvbiBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgdmFsaWRhdGVgXHJcbiAqIHVwZGF0ZSBmdW5jdGlvbiB0byBwZXJmb3JtIHN5bmNocm9ub3VzIHZhbGlkYXRpb24gaW4geW91ciByZWR1Y2VyOlxyXG4gKlxyXG5gYGB0eXBlc2NyaXB0XHJcbnVwZGF0ZUdyb3VwPE15Rm9ybVZhbHVlPih7XHJcbiAgbmFtZTogdmFsaWRhdGUobWF4TGVuZ3RoKDEwKSksXHJcbn0pXHJcbmBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyBnZW5lcmljIHRvIGFsbG93IHRoZSBjb21waWxlciB0byBwcm9wZXJseSBpbmZlciB0aGUgdHlwZVxyXG4gKiBvZiB0aGUgYHZhbGlkYXRlYCBmdW5jdGlvbiBmb3IgYm90aCBvcHRpb25hbCBhbmQgbm9uLW9wdGlvbmFsIGNvbnRyb2xzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1heExlbmd0aChtYXhMZW5ndGhQYXJhbTogbnVtYmVyKSB7XHJcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnN0cmljdC10eXBlLXByZWRpY2F0ZXMgKGd1YXJkIGZvciB1c2VycyB3aXRob3V0IHN0cmljdCB0eXBlIGNoZWNraW5nKVxyXG4gIGlmIChtYXhMZW5ndGhQYXJhbSA9PT0gbnVsbCB8fCBtYXhMZW5ndGhQYXJhbSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtYXhMZW5ndGggVmFsaWRhdGlvbiBmdW5jdGlvbiByZXF1aXJlcyB0aGUgbWF4TGVuZ3RoIHBhcmFtZXRlciB0byBiZSBhIG5vbi1udWxsIG51bWJlciwgZ290ICR7bWF4TGVuZ3RoUGFyYW19IWApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIDxUIGV4dGVuZHMgc3RyaW5nIHwgQm94ZWQ8c3RyaW5nPiB8IGFueVtdIHwgQm94ZWQ8YW55W10+IHwgbnVsbCB8IHVuZGVmaW5lZD4odmFsdWU6IFQpOiBWYWxpZGF0aW9uRXJyb3JzID0+IHtcclxuICAgIHZhbHVlID0gdW5ib3godmFsdWUpO1xyXG5cclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsZW5ndGggPSAodmFsdWUgYXMgc3RyaW5nIHwgYW55W10pLmxlbmd0aDtcclxuXHJcbiAgICBpZiAobGVuZ3RoIDw9IG1heExlbmd0aFBhcmFtKSB7XHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBtYXhMZW5ndGg6IHtcclxuICAgICAgICBtYXhMZW5ndGg6IG1heExlbmd0aFBhcmFtLFxyXG4gICAgICAgIHZhbHVlOiB2YWx1ZSBhcyBzdHJpbmcsXHJcbiAgICAgICAgYWN0dWFsTGVuZ3RoOiBsZW5ndGgsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH07XHJcbn1cclxuIl19
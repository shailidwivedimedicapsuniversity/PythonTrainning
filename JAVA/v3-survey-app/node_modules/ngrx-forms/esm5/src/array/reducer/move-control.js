import * as tslib_1 from "tslib";
import { MoveArrayControlAction } from '../../actions';
import { computeArrayState } from '../../state';
import { childReducer, updateIdRecursive } from './util';
export function move(array, fromIndex, toIndex) {
    var item = array[fromIndex];
    var length = array.length;
    if (fromIndex > toIndex) {
        return tslib_1.__spread(array.slice(0, toIndex), [
            item
        ], array.slice(toIndex, fromIndex), array.slice(fromIndex + 1, length));
    }
    else {
        var targetIndex = toIndex + 1;
        return tslib_1.__spread(array.slice(0, fromIndex), array.slice(fromIndex + 1, targetIndex), [
            item
        ], array.slice(targetIndex, length));
    }
}
export function moveControlReducer(state, action) {
    if (action.type !== MoveArrayControlAction.TYPE) {
        return state;
    }
    if (action.controlId !== state.id) {
        return childReducer(state, action);
    }
    var fromIndex = action.fromIndex;
    var toIndex = action.toIndex;
    if (fromIndex === toIndex) {
        return state;
    }
    if (fromIndex < 0 || toIndex < 0) {
        throw new Error("fromIndex " + fromIndex + " or toIndex " + fromIndex + " was negative");
    }
    if (fromIndex >= state.controls.length || toIndex >= state.controls.length) {
        throw new Error("fromIndex " + fromIndex + " or toIndex " + toIndex + " is out of bounds with the length of the controls " + state.controls.length);
    }
    var controls = move(state.controls, fromIndex, toIndex);
    controls = controls.map(function (c, i) { return updateIdRecursive(c, state.id + "." + i); });
    return computeArrayState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
        wasOrShouldBeDirty: true,
        wasOrShouldBeEnabled: state.isEnabled,
        wasOrShouldBeTouched: state.isTouched,
        wasOrShouldBeSubmitted: state.isSubmitted,
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW92ZS1jb250cm9sLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmdyeC1mb3Jtcy8iLCJzb3VyY2VzIjpbInNyYy9hcnJheS9yZWR1Y2VyL21vdmUtY29udHJvbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFXLHNCQUFzQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxpQkFBaUIsRUFBa0IsTUFBTSxhQUFhLENBQUM7QUFDaEUsT0FBTyxFQUFFLFlBQVksRUFBRSxpQkFBaUIsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUV6RCxNQUFNLFVBQVUsSUFBSSxDQUFDLEtBQXFCLEVBQUUsU0FBaUIsRUFBRSxPQUFlO0lBQzVFLElBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM5QixJQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO0lBQzVCLElBQUksU0FBUyxHQUFHLE9BQU8sRUFBRTtRQUN2Qix3QkFDSyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUM7WUFDMUIsSUFBSTtXQUNELEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxFQUMvQixLQUFLLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUUsTUFBTSxDQUFDLEVBQ3JDO0tBQ0g7U0FBTTtRQUNMLElBQU0sV0FBVyxHQUFHLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFDaEMsd0JBQ0ssS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLEVBQ3pCLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsRUFBRSxXQUFXLENBQUM7WUFDMUMsSUFBSTtXQUNELEtBQUssQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxFQUNuQztLQUNIO0FBQ0gsQ0FBQztBQUVELE1BQU0sVUFBVSxrQkFBa0IsQ0FDaEMsS0FBNkIsRUFDN0IsTUFBeUI7SUFFekIsSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLHNCQUFzQixDQUFDLElBQUksRUFBRTtRQUMvQyxPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsSUFBSSxNQUFNLENBQUMsU0FBUyxLQUFLLEtBQUssQ0FBQyxFQUFFLEVBQUU7UUFDakMsT0FBTyxZQUFZLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0tBQ3BDO0lBRUQsSUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztJQUNuQyxJQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO0lBRS9CLElBQUksU0FBUyxLQUFLLE9BQU8sRUFBRTtRQUN6QixPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsSUFBSSxTQUFTLEdBQUcsQ0FBQyxJQUFJLE9BQU8sR0FBRyxDQUFDLEVBQUU7UUFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxlQUFhLFNBQVMsb0JBQWUsU0FBUyxrQkFBZSxDQUFDLENBQUM7S0FDaEY7SUFFRCxJQUFJLFNBQVMsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxPQUFPLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUU7UUFDMUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxlQUFhLFNBQVMsb0JBQWUsT0FBTywwREFBcUQsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFRLENBQUMsQ0FBQztLQUMzSTtJQUVELElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUV4RCxRQUFRLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFDLENBQUMsRUFBRSxDQUFDLElBQUssT0FBQSxpQkFBaUIsQ0FBQyxDQUFDLEVBQUssS0FBSyxDQUFDLEVBQUUsU0FBSSxDQUFHLENBQUMsRUFBeEMsQ0FBd0MsQ0FBQyxDQUFDO0lBRTVFLE9BQU8saUJBQWlCLENBQ3RCLEtBQUssQ0FBQyxFQUFFLEVBQ1IsUUFBUSxFQUNSLEtBQUssQ0FBQyxLQUFLLEVBQ1gsS0FBSyxDQUFDLE1BQU0sRUFDWixLQUFLLENBQUMsa0JBQWtCLEVBQ3hCLEtBQUssQ0FBQyxxQkFBcUIsRUFDM0I7UUFDRSxrQkFBa0IsRUFBRSxJQUFJO1FBQ3hCLG9CQUFvQixFQUFFLEtBQUssQ0FBQyxTQUFTO1FBQ3JDLG9CQUFvQixFQUFFLEtBQUssQ0FBQyxTQUFTO1FBQ3JDLHNCQUFzQixFQUFFLEtBQUssQ0FBQyxXQUFXO0tBQzFDLENBQ0YsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBY3Rpb25zLCBNb3ZlQXJyYXlDb250cm9sQWN0aW9uIH0gZnJvbSAnLi4vLi4vYWN0aW9ucyc7XHJcbmltcG9ydCB7IGNvbXB1dGVBcnJheVN0YXRlLCBGb3JtQXJyYXlTdGF0ZSB9IGZyb20gJy4uLy4uL3N0YXRlJztcclxuaW1wb3J0IHsgY2hpbGRSZWR1Y2VyLCB1cGRhdGVJZFJlY3Vyc2l2ZSB9IGZyb20gJy4vdXRpbCc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbW92ZShhcnJheTogcmVhZG9ubHkgYW55W10sIGZyb21JbmRleDogbnVtYmVyLCB0b0luZGV4OiBudW1iZXIpIHtcclxuICBjb25zdCBpdGVtID0gYXJyYXlbZnJvbUluZGV4XTtcclxuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcbiAgaWYgKGZyb21JbmRleCA+IHRvSW5kZXgpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIC4uLmFycmF5LnNsaWNlKDAsIHRvSW5kZXgpLFxyXG4gICAgICBpdGVtLFxyXG4gICAgICAuLi5hcnJheS5zbGljZSh0b0luZGV4LCBmcm9tSW5kZXgpLFxyXG4gICAgICAuLi5hcnJheS5zbGljZShmcm9tSW5kZXggKyAxLCBsZW5ndGgpLFxyXG4gICAgXTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSB0b0luZGV4ICsgMTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIC4uLmFycmF5LnNsaWNlKDAsIGZyb21JbmRleCksXHJcbiAgICAgIC4uLmFycmF5LnNsaWNlKGZyb21JbmRleCArIDEsIHRhcmdldEluZGV4KSxcclxuICAgICAgaXRlbSxcclxuICAgICAgLi4uYXJyYXkuc2xpY2UodGFyZ2V0SW5kZXgsIGxlbmd0aCksXHJcbiAgICBdO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVDb250cm9sUmVkdWNlcjxUVmFsdWU+KFxyXG4gIHN0YXRlOiBGb3JtQXJyYXlTdGF0ZTxUVmFsdWU+LFxyXG4gIGFjdGlvbjogQWN0aW9uczxUVmFsdWVbXT4sXHJcbik6IEZvcm1BcnJheVN0YXRlPFRWYWx1ZT4ge1xyXG4gIGlmIChhY3Rpb24udHlwZSAhPT0gTW92ZUFycmF5Q29udHJvbEFjdGlvbi5UWVBFKSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG4gIGlmIChhY3Rpb24uY29udHJvbElkICE9PSBzdGF0ZS5pZCkge1xyXG4gICAgcmV0dXJuIGNoaWxkUmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGZyb21JbmRleCA9IGFjdGlvbi5mcm9tSW5kZXg7XHJcbiAgY29uc3QgdG9JbmRleCA9IGFjdGlvbi50b0luZGV4O1xyXG5cclxuICBpZiAoZnJvbUluZGV4ID09PSB0b0luZGV4KSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG5cclxuICBpZiAoZnJvbUluZGV4IDwgMCB8fCB0b0luZGV4IDwgMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBmcm9tSW5kZXggJHtmcm9tSW5kZXh9IG9yIHRvSW5kZXggJHtmcm9tSW5kZXh9IHdhcyBuZWdhdGl2ZWApO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZyb21JbmRleCA+PSBzdGF0ZS5jb250cm9scy5sZW5ndGggfHwgdG9JbmRleCA+PSBzdGF0ZS5jb250cm9scy5sZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgZnJvbUluZGV4ICR7ZnJvbUluZGV4fSBvciB0b0luZGV4ICR7dG9JbmRleH0gaXMgb3V0IG9mIGJvdW5kcyB3aXRoIHRoZSBsZW5ndGggb2YgdGhlIGNvbnRyb2xzICR7c3RhdGUuY29udHJvbHMubGVuZ3RofWApO1xyXG4gIH1cclxuXHJcbiAgbGV0IGNvbnRyb2xzID0gbW92ZShzdGF0ZS5jb250cm9scywgZnJvbUluZGV4LCB0b0luZGV4KTtcclxuXHJcbiAgY29udHJvbHMgPSBjb250cm9scy5tYXAoKGMsIGkpID0+IHVwZGF0ZUlkUmVjdXJzaXZlKGMsIGAke3N0YXRlLmlkfS4ke2l9YCkpO1xyXG5cclxuICByZXR1cm4gY29tcHV0ZUFycmF5U3RhdGUoXHJcbiAgICBzdGF0ZS5pZCxcclxuICAgIGNvbnRyb2xzLFxyXG4gICAgc3RhdGUudmFsdWUsXHJcbiAgICBzdGF0ZS5lcnJvcnMsXHJcbiAgICBzdGF0ZS5wZW5kaW5nVmFsaWRhdGlvbnMsXHJcbiAgICBzdGF0ZS51c2VyRGVmaW5lZFByb3BlcnRpZXMsXHJcbiAgICB7XHJcbiAgICAgIHdhc09yU2hvdWxkQmVEaXJ0eTogdHJ1ZSxcclxuICAgICAgd2FzT3JTaG91bGRCZUVuYWJsZWQ6IHN0YXRlLmlzRW5hYmxlZCxcclxuICAgICAgd2FzT3JTaG91bGRCZVRvdWNoZWQ6IHN0YXRlLmlzVG91Y2hlZCxcclxuICAgICAgd2FzT3JTaG91bGRCZVN1Ym1pdHRlZDogc3RhdGUuaXNTdWJtaXR0ZWQsXHJcbiAgICB9XHJcbiAgKTtcclxufVxyXG4iXX0=
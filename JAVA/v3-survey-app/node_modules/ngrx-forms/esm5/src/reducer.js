import * as tslib_1 from "tslib";
import { ALL_NGRX_FORMS_ACTION_TYPES } from './actions';
import { formArrayReducer } from './array/reducer';
import { formControlReducer } from './control/reducer';
import { formGroupReducer } from './group/reducer';
import { isArrayState, isFormState, isGroupState } from './state';
export function formStateReducer(state, action) {
    if (!state) {
        throw new Error('The form state must be defined!');
    }
    if (!isFormState(state)) {
        throw new Error("state must be a form state, got " + state);
    }
    if (isGroupState(state)) {
        return formGroupReducer(state, action);
    }
    if (isArrayState(state)) {
        return formArrayReducer(state, action);
    }
    return formControlReducer(state, action);
}
/**
 * This function creates a reducer function that first applies an action to the state
 * and afterwards applies all given update functions one after another to the resulting
 * form state. However, the update functions are only applied if the form state changed
 * as result of applying the action. If you need the update functions to be applied
 * regardless of whether the state changed (e.g. because the update function closes
 * over variables that may change independently of the form state) you can simply apply
 * the update manually (e.g. `updateFunction(formStateReducer(state, action))`).
 *
 * The following (contrived) example uses this function to create a reducer that after
 * each action validates the child control `name` to be required and sets the child
 * control `email`'s value to be `''` if the name is invalid.
 *
```typescript
interface FormValue {
  name: string;
  email: string;
}

const updateFormState = updateGroup<FormValue>(
  {
    name: validate(required),
  },
  {
    email: (email, parentGroup) =>
      parentGroup.controls.name.isInvalid
        ? setValue('', email)
        : email,
  },
);

const reducer = createFormStateReducerWithUpdate<FormValue>(updateFormState);
```
 */
export function createFormStateReducerWithUpdate(updateFnOrUpdateFnArr) {
    var updateFnArr = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        updateFnArr[_i - 1] = arguments[_i];
    }
    updateFnArr = tslib_1.__spread((Array.isArray(updateFnOrUpdateFnArr) ? updateFnOrUpdateFnArr : [updateFnOrUpdateFnArr]), updateFnArr);
    return function (state, action) {
        var newState = formStateReducer(state, action);
        return newState === state ? state : updateFnArr.reduce(function (s, f) { return f(s); }, newState);
    };
}
function reduceNestedFormState(state, key, action) {
    var _a;
    var value = state[key];
    if (!isFormState(value)) {
        return state;
    }
    return tslib_1.__assign({}, state, (_a = {}, _a[key] = formStateReducer(value, action), _a));
}
function reduceNestedFormStates(state, action) {
    return Object.keys(state).reduce(function (s, key) { return reduceNestedFormState(s, key, action); }, state);
}
/**
 * This function returns an object that can be passed to ngrx's `createReducer`
 * function (available starting with ngrx version 8). By doing this all form
 * state properties on the state will be updated whenever necessary (i.e.
 * whenever an ngrx-forms action is dispatched).
 *
 * To manually update a form state (e.g. to validate it) use
 * `wrapReducerWithFormStateUpdate`.
 */
export function onNgrxForms() {
    return {
        reducer: function (state, action) { return reduceNestedFormStates(state, action); },
        types: ALL_NGRX_FORMS_ACTION_TYPES,
    };
}
/**
 * Define a reducer for a ngrx-forms action. This functions works the same as
 * ngrx's `on` except that you provide the ngrx-forms action class instead of
 * your action creator as a parameter.
 */
export function onNgrxFormsAction(actionCons, reducer) {
    return {
        reducer: function (state, action) { return reducer(reduceNestedFormStates(state, action), action); },
        types: [actionCons.TYPE],
    };
}
/**
 * This function wraps a reducer and returns another reducer that first calls
 * the given reducer and then calls the given update function for the form state
 * that is specified by the form state locator function.
 *
 * The update function is passed the form state and the updated containing state
 * as parameters.
 */
export function wrapReducerWithFormStateUpdate(reducer, formStateLocator, updateFn) {
    return function (state, action) {
        var _a;
        var updatedState = reducer(state, action);
        var formState = formStateLocator(updatedState);
        var formStateKey = Object.keys(updatedState).find(function (key) { return updatedState[key] === formState; });
        var updatedFormState = updateFn(formState, updatedState);
        if (updatedFormState === formState) {
            return updatedState;
        }
        return tslib_1.__assign({}, updatedState, (_a = {}, _a[formStateKey] = updatedFormState, _a));
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVkdWNlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25ncngtZm9ybXMvIiwic291cmNlcyI6WyJzcmMvcmVkdWNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBRUEsT0FBTyxFQUFXLDJCQUEyQixFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ2pFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ25ELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ25ELE9BQU8sRUFBcUQsWUFBWSxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFHckgsTUFBTSxVQUFVLGdCQUFnQixDQUM5QixLQUFtRSxFQUNuRSxNQUFjO0lBRWQsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztLQUNwRDtJQUVELElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBbUMsS0FBTyxDQUFDLENBQUM7S0FDN0Q7SUFFRCxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUN2QixPQUFPLGdCQUFnQixDQUFDLEtBQUssRUFBRSxNQUFNLENBQVEsQ0FBQztLQUMvQztJQUVELElBQUksWUFBWSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3ZCLE9BQU8sZ0JBQWdCLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBUSxDQUFDO0tBQy9DO0lBRUQsT0FBTyxrQkFBa0IsQ0FBQyxLQUE4QixFQUFFLE1BQU0sQ0FBUSxDQUFDO0FBQzNFLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBaUNHO0FBQ0gsTUFBTSxVQUFVLGdDQUFnQyxDQUM5QyxxQkFBb0Y7SUFDcEYscUJBQThDO1NBQTlDLFVBQThDLEVBQTlDLHFCQUE4QyxFQUE5QyxJQUE4QztRQUE5QyxvQ0FBOEM7O0lBRTlDLFdBQVcsb0JBQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLENBQUMsRUFBSyxXQUFXLENBQUMsQ0FBQztJQUM1SCxPQUFPLFVBQUMsS0FBb0MsRUFBRSxNQUFjO1FBQzFELElBQU0sUUFBUSxHQUFHLGdCQUFnQixDQUFDLEtBQXFDLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDakYsT0FBTyxRQUFRLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQyxJQUFLLE9BQUEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFKLENBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNuRixDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQsU0FBUyxxQkFBcUIsQ0FBUyxLQUFhLEVBQUUsR0FBaUIsRUFBRSxNQUFjOztJQUNyRixJQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFekIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUN2QixPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsNEJBQ0ssS0FBSyxlQUNQLEdBQUcsSUFBRyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLE9BQ3RDO0FBQ0osQ0FBQztBQUVELFNBQVMsc0JBQXNCLENBQVMsS0FBYSxFQUFFLE1BQWM7SUFDbkUsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFDLENBQUMsRUFBRSxHQUFHLElBQUssT0FBQSxxQkFBcUIsQ0FBQyxDQUFDLEVBQUUsR0FBbUIsRUFBRSxNQUFNLENBQUMsRUFBckQsQ0FBcUQsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUM3RyxDQUFDO0FBRUQ7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFNLFVBQVUsV0FBVztJQUN6QixPQUFPO1FBQ0wsT0FBTyxFQUFFLFVBQUMsS0FBSyxFQUFFLE1BQU0sSUFBSyxPQUFBLHNCQUFzQixDQUFDLEtBQU0sRUFBRSxNQUFNLENBQUMsRUFBdEMsQ0FBc0M7UUFDbEUsS0FBSyxFQUFFLDJCQUEyQjtLQUNuQyxDQUFDO0FBQ0osQ0FBQztBQVNEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsaUJBQWlCLENBSS9CLFVBQXVCLEVBQ3ZCLE9BQXNFO0lBRXRFLE9BQU87UUFDTCxPQUFPLEVBQUUsVUFBQyxLQUFLLEVBQUUsTUFBTSxJQUFLLE9BQUEsT0FBTyxDQUFDLHNCQUFzQixDQUFDLEtBQU0sRUFBRSxNQUFNLENBQUMsRUFBRSxNQUFhLENBQUMsRUFBOUQsQ0FBOEQ7UUFDMUYsS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztLQUN6QixDQUFDO0FBQ0osQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsOEJBQThCLENBQzVDLE9BQThCLEVBQzlCLGdCQUErQyxFQUMvQyxRQUE4RDtJQUU5RCxPQUFPLFVBQUMsS0FBSyxFQUFFLE1BQU07O1FBQ25CLElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFNUMsSUFBTSxTQUFTLEdBQUcsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDakQsSUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBQSxHQUFHLElBQUksT0FBQSxZQUFZLENBQUMsR0FBbUIsQ0FBUSxLQUFLLFNBQVMsRUFBdEQsQ0FBc0QsQ0FBRSxDQUFDO1FBRXBILElBQU0sZ0JBQWdCLEdBQUcsUUFBUSxDQUFDLFNBQVMsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUUzRCxJQUFJLGdCQUFnQixLQUFLLFNBQVMsRUFBRTtZQUNsQyxPQUFPLFlBQVksQ0FBQztTQUNyQjtRQUVELDRCQUNLLFlBQVksZUFDZCxZQUFZLElBQUcsZ0JBQWdCLE9BQ2hDO0lBQ0osQ0FBQyxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFjdGlvbiwgQWN0aW9uUmVkdWNlciB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcclxuXHJcbmltcG9ydCB7IEFjdGlvbnMsIEFMTF9OR1JYX0ZPUk1TX0FDVElPTl9UWVBFUyB9IGZyb20gJy4vYWN0aW9ucyc7XHJcbmltcG9ydCB7IGZvcm1BcnJheVJlZHVjZXIgfSBmcm9tICcuL2FycmF5L3JlZHVjZXInO1xyXG5pbXBvcnQgeyBmb3JtQ29udHJvbFJlZHVjZXIgfSBmcm9tICcuL2NvbnRyb2wvcmVkdWNlcic7XHJcbmltcG9ydCB7IGZvcm1Hcm91cFJlZHVjZXIgfSBmcm9tICcuL2dyb3VwL3JlZHVjZXInO1xyXG5pbXBvcnQgeyBBYnN0cmFjdENvbnRyb2xTdGF0ZSwgRm9ybUNvbnRyb2xTdGF0ZSwgRm9ybVN0YXRlLCBpc0FycmF5U3RhdGUsIGlzRm9ybVN0YXRlLCBpc0dyb3VwU3RhdGUgfSBmcm9tICcuL3N0YXRlJztcclxuaW1wb3J0IHsgUHJvamVjdEZuIH0gZnJvbSAnLi91cGRhdGUtZnVuY3Rpb24vdXRpbCc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybVN0YXRlUmVkdWNlcjxUVmFsdWU+KFxyXG4gIHN0YXRlOiBGb3JtU3RhdGU8VFZhbHVlPiB8IEFic3RyYWN0Q29udHJvbFN0YXRlPFRWYWx1ZT4gfCB1bmRlZmluZWQsXHJcbiAgYWN0aW9uOiBBY3Rpb24sXHJcbik6IEZvcm1TdGF0ZTxUVmFsdWU+IHtcclxuICBpZiAoIXN0YXRlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmb3JtIHN0YXRlIG11c3QgYmUgZGVmaW5lZCEnKTtcclxuICB9XHJcblxyXG4gIGlmICghaXNGb3JtU3RhdGUoc3RhdGUpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHN0YXRlIG11c3QgYmUgYSBmb3JtIHN0YXRlLCBnb3QgJHtzdGF0ZX1gKTtcclxuICB9XHJcblxyXG4gIGlmIChpc0dyb3VwU3RhdGUoc3RhdGUpKSB7XHJcbiAgICByZXR1cm4gZm9ybUdyb3VwUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSBhcyBhbnk7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNBcnJheVN0YXRlKHN0YXRlKSkge1xyXG4gICAgcmV0dXJuIGZvcm1BcnJheVJlZHVjZXIoc3RhdGUsIGFjdGlvbikgYXMgYW55O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZvcm1Db250cm9sUmVkdWNlcihzdGF0ZSBhcyBGb3JtQ29udHJvbFN0YXRlPGFueT4sIGFjdGlvbikgYXMgYW55O1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGZpcnN0IGFwcGxpZXMgYW4gYWN0aW9uIHRvIHRoZSBzdGF0ZVxyXG4gKiBhbmQgYWZ0ZXJ3YXJkcyBhcHBsaWVzIGFsbCBnaXZlbiB1cGRhdGUgZnVuY3Rpb25zIG9uZSBhZnRlciBhbm90aGVyIHRvIHRoZSByZXN1bHRpbmdcclxuICogZm9ybSBzdGF0ZS4gSG93ZXZlciwgdGhlIHVwZGF0ZSBmdW5jdGlvbnMgYXJlIG9ubHkgYXBwbGllZCBpZiB0aGUgZm9ybSBzdGF0ZSBjaGFuZ2VkXHJcbiAqIGFzIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgYWN0aW9uLiBJZiB5b3UgbmVlZCB0aGUgdXBkYXRlIGZ1bmN0aW9ucyB0byBiZSBhcHBsaWVkXHJcbiAqIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgc3RhdGUgY2hhbmdlZCAoZS5nLiBiZWNhdXNlIHRoZSB1cGRhdGUgZnVuY3Rpb24gY2xvc2VzXHJcbiAqIG92ZXIgdmFyaWFibGVzIHRoYXQgbWF5IGNoYW5nZSBpbmRlcGVuZGVudGx5IG9mIHRoZSBmb3JtIHN0YXRlKSB5b3UgY2FuIHNpbXBseSBhcHBseVxyXG4gKiB0aGUgdXBkYXRlIG1hbnVhbGx5IChlLmcuIGB1cGRhdGVGdW5jdGlvbihmb3JtU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pKWApLlxyXG4gKlxyXG4gKiBUaGUgZm9sbG93aW5nIChjb250cml2ZWQpIGV4YW1wbGUgdXNlcyB0aGlzIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHJlZHVjZXIgdGhhdCBhZnRlclxyXG4gKiBlYWNoIGFjdGlvbiB2YWxpZGF0ZXMgdGhlIGNoaWxkIGNvbnRyb2wgYG5hbWVgIHRvIGJlIHJlcXVpcmVkIGFuZCBzZXRzIHRoZSBjaGlsZFxyXG4gKiBjb250cm9sIGBlbWFpbGAncyB2YWx1ZSB0byBiZSBgJydgIGlmIHRoZSBuYW1lIGlzIGludmFsaWQuXHJcbiAqXHJcbmBgYHR5cGVzY3JpcHRcclxuaW50ZXJmYWNlIEZvcm1WYWx1ZSB7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGVtYWlsOiBzdHJpbmc7XHJcbn1cclxuXHJcbmNvbnN0IHVwZGF0ZUZvcm1TdGF0ZSA9IHVwZGF0ZUdyb3VwPEZvcm1WYWx1ZT4oXHJcbiAge1xyXG4gICAgbmFtZTogdmFsaWRhdGUocmVxdWlyZWQpLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgZW1haWw6IChlbWFpbCwgcGFyZW50R3JvdXApID0+XHJcbiAgICAgIHBhcmVudEdyb3VwLmNvbnRyb2xzLm5hbWUuaXNJbnZhbGlkXHJcbiAgICAgICAgPyBzZXRWYWx1ZSgnJywgZW1haWwpXHJcbiAgICAgICAgOiBlbWFpbCxcclxuICB9LFxyXG4pO1xyXG5cclxuY29uc3QgcmVkdWNlciA9IGNyZWF0ZUZvcm1TdGF0ZVJlZHVjZXJXaXRoVXBkYXRlPEZvcm1WYWx1ZT4odXBkYXRlRm9ybVN0YXRlKTtcclxuYGBgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9ybVN0YXRlUmVkdWNlcldpdGhVcGRhdGU8VFZhbHVlPihcclxuICB1cGRhdGVGbk9yVXBkYXRlRm5BcnI6IFByb2plY3RGbjxGb3JtU3RhdGU8VFZhbHVlPj4gfCBQcm9qZWN0Rm48Rm9ybVN0YXRlPFRWYWx1ZT4+W10sXHJcbiAgLi4udXBkYXRlRm5BcnI6IFByb2plY3RGbjxGb3JtU3RhdGU8VFZhbHVlPj5bXVxyXG4pOiBBY3Rpb25SZWR1Y2VyPEZvcm1TdGF0ZTxUVmFsdWU+PiB7XHJcbiAgdXBkYXRlRm5BcnIgPSBbLi4uKEFycmF5LmlzQXJyYXkodXBkYXRlRm5PclVwZGF0ZUZuQXJyKSA/IHVwZGF0ZUZuT3JVcGRhdGVGbkFyciA6IFt1cGRhdGVGbk9yVXBkYXRlRm5BcnJdKSwgLi4udXBkYXRlRm5BcnJdO1xyXG4gIHJldHVybiAoc3RhdGU6IEZvcm1TdGF0ZTxUVmFsdWU+IHwgdW5kZWZpbmVkLCBhY3Rpb246IEFjdGlvbik6IEZvcm1TdGF0ZTxUVmFsdWU+ID0+IHtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gZm9ybVN0YXRlUmVkdWNlcihzdGF0ZSBhcyBBYnN0cmFjdENvbnRyb2xTdGF0ZTxUVmFsdWU+LCBhY3Rpb24pO1xyXG4gICAgcmV0dXJuIG5ld1N0YXRlID09PSBzdGF0ZSA/IHN0YXRlIDogdXBkYXRlRm5BcnIucmVkdWNlKChzLCBmKSA9PiBmKHMpLCBuZXdTdGF0ZSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVkdWNlTmVzdGVkRm9ybVN0YXRlPFRTdGF0ZT4oc3RhdGU6IFRTdGF0ZSwga2V5OiBrZXlvZiBUU3RhdGUsIGFjdGlvbjogQWN0aW9uKTogVFN0YXRlIHtcclxuICBjb25zdCB2YWx1ZSA9IHN0YXRlW2tleV07XHJcblxyXG4gIGlmICghaXNGb3JtU3RhdGUodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgLi4uc3RhdGUsXHJcbiAgICBba2V5XTogZm9ybVN0YXRlUmVkdWNlcih2YWx1ZSwgYWN0aW9uKSxcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWR1Y2VOZXN0ZWRGb3JtU3RhdGVzPFRTdGF0ZT4oc3RhdGU6IFRTdGF0ZSwgYWN0aW9uOiBBY3Rpb24pOiBUU3RhdGUge1xyXG4gIHJldHVybiBPYmplY3Qua2V5cyhzdGF0ZSkucmVkdWNlKChzLCBrZXkpID0+IHJlZHVjZU5lc3RlZEZvcm1TdGF0ZShzLCBrZXkgYXMga2V5b2YgVFN0YXRlLCBhY3Rpb24pLCBzdGF0ZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byBuZ3J4J3MgYGNyZWF0ZVJlZHVjZXJgXHJcbiAqIGZ1bmN0aW9uIChhdmFpbGFibGUgc3RhcnRpbmcgd2l0aCBuZ3J4IHZlcnNpb24gOCkuIEJ5IGRvaW5nIHRoaXMgYWxsIGZvcm1cclxuICogc3RhdGUgcHJvcGVydGllcyBvbiB0aGUgc3RhdGUgd2lsbCBiZSB1cGRhdGVkIHdoZW5ldmVyIG5lY2Vzc2FyeSAoaS5lLlxyXG4gKiB3aGVuZXZlciBhbiBuZ3J4LWZvcm1zIGFjdGlvbiBpcyBkaXNwYXRjaGVkKS5cclxuICpcclxuICogVG8gbWFudWFsbHkgdXBkYXRlIGEgZm9ybSBzdGF0ZSAoZS5nLiB0byB2YWxpZGF0ZSBpdCkgdXNlXHJcbiAqIGB3cmFwUmVkdWNlcldpdGhGb3JtU3RhdGVVcGRhdGVgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9uTmdyeEZvcm1zPFRTdGF0ZSA9IGFueT4oKTogeyByZWR1Y2VyOiBBY3Rpb25SZWR1Y2VyPFRTdGF0ZT47IHR5cGVzOiBzdHJpbmdbXSB9IHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVkdWNlcjogKHN0YXRlLCBhY3Rpb24pID0+IHJlZHVjZU5lc3RlZEZvcm1TdGF0ZXMoc3RhdGUhLCBhY3Rpb24pLFxyXG4gICAgdHlwZXM6IEFMTF9OR1JYX0ZPUk1TX0FDVElPTl9UWVBFUyxcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkNvbnN0cnVjdG9yIHtcclxuICBuZXcoLi4uYXJnczogYW55W10pOiBBY3Rpb25zPGFueT47XHJcbiAgcmVhZG9ubHkgVFlQRTogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBDcmVhdGVkQWN0aW9uPFRBY3Rpb25Db25zPiA9IFRBY3Rpb25Db25zIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gaW5mZXIgVEFjdGlvbiA/IFRBY3Rpb24gOiBuZXZlcjtcclxuXHJcbi8qKlxyXG4gKiBEZWZpbmUgYSByZWR1Y2VyIGZvciBhIG5ncngtZm9ybXMgYWN0aW9uLiBUaGlzIGZ1bmN0aW9ucyB3b3JrcyB0aGUgc2FtZSBhc1xyXG4gKiBuZ3J4J3MgYG9uYCBleGNlcHQgdGhhdCB5b3UgcHJvdmlkZSB0aGUgbmdyeC1mb3JtcyBhY3Rpb24gY2xhc3MgaW5zdGVhZCBvZlxyXG4gKiB5b3VyIGFjdGlvbiBjcmVhdG9yIGFzIGEgcGFyYW1ldGVyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9uTmdyeEZvcm1zQWN0aW9uPFxyXG4gIFRBY3Rpb25Db25zIGV4dGVuZHMgQWN0aW9uQ29uc3RydWN0b3IsXHJcbiAgVFN0YXRlXHJcbj4oXHJcbiAgYWN0aW9uQ29uczogVEFjdGlvbkNvbnMsXHJcbiAgcmVkdWNlcjogKHN0YXRlOiBUU3RhdGUsIGFjdGlvbjogQ3JlYXRlZEFjdGlvbjxUQWN0aW9uQ29ucz4pID0+IFRTdGF0ZSxcclxuKTogeyByZWR1Y2VyOiBBY3Rpb25SZWR1Y2VyPFRTdGF0ZT47IHR5cGVzOiBzdHJpbmdbXSB9IHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVkdWNlcjogKHN0YXRlLCBhY3Rpb24pID0+IHJlZHVjZXIocmVkdWNlTmVzdGVkRm9ybVN0YXRlcyhzdGF0ZSEsIGFjdGlvbiksIGFjdGlvbiBhcyBhbnkpLFxyXG4gICAgdHlwZXM6IFthY3Rpb25Db25zLlRZUEVdLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHdyYXBzIGEgcmVkdWNlciBhbmQgcmV0dXJucyBhbm90aGVyIHJlZHVjZXIgdGhhdCBmaXJzdCBjYWxsc1xyXG4gKiB0aGUgZ2l2ZW4gcmVkdWNlciBhbmQgdGhlbiBjYWxscyB0aGUgZ2l2ZW4gdXBkYXRlIGZ1bmN0aW9uIGZvciB0aGUgZm9ybSBzdGF0ZVxyXG4gKiB0aGF0IGlzIHNwZWNpZmllZCBieSB0aGUgZm9ybSBzdGF0ZSBsb2NhdG9yIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBUaGUgdXBkYXRlIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgZm9ybSBzdGF0ZSBhbmQgdGhlIHVwZGF0ZWQgY29udGFpbmluZyBzdGF0ZVxyXG4gKiBhcyBwYXJhbWV0ZXJzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBSZWR1Y2VyV2l0aEZvcm1TdGF0ZVVwZGF0ZTxUU3RhdGUsIFRGb3JtU3RhdGUgZXh0ZW5kcyBBYnN0cmFjdENvbnRyb2xTdGF0ZTxhbnk+PihcclxuICByZWR1Y2VyOiBBY3Rpb25SZWR1Y2VyPFRTdGF0ZT4sXHJcbiAgZm9ybVN0YXRlTG9jYXRvcjogKHN0YXRlOiBUU3RhdGUpID0+IFRGb3JtU3RhdGUsXHJcbiAgdXBkYXRlRm46IChmb3JtU3RhdGU6IFRGb3JtU3RhdGUsIHN0YXRlOiBUU3RhdGUpID0+IFRGb3JtU3RhdGUsXHJcbik6IEFjdGlvblJlZHVjZXI8VFN0YXRlPiB7XHJcbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XHJcbiAgICBjb25zdCB1cGRhdGVkU3RhdGUgPSByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xyXG5cclxuICAgIGNvbnN0IGZvcm1TdGF0ZSA9IGZvcm1TdGF0ZUxvY2F0b3IodXBkYXRlZFN0YXRlKTtcclxuICAgIGNvbnN0IGZvcm1TdGF0ZUtleSA9IE9iamVjdC5rZXlzKHVwZGF0ZWRTdGF0ZSkuZmluZChrZXkgPT4gdXBkYXRlZFN0YXRlW2tleSBhcyBrZXlvZiBUU3RhdGVdIGFzIGFueSA9PT0gZm9ybVN0YXRlKSE7XHJcblxyXG4gICAgY29uc3QgdXBkYXRlZEZvcm1TdGF0ZSA9IHVwZGF0ZUZuKGZvcm1TdGF0ZSwgdXBkYXRlZFN0YXRlKTtcclxuXHJcbiAgICBpZiAodXBkYXRlZEZvcm1TdGF0ZSA9PT0gZm9ybVN0YXRlKSB7XHJcbiAgICAgIHJldHVybiB1cGRhdGVkU3RhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLi4udXBkYXRlZFN0YXRlLFxyXG4gICAgICBbZm9ybVN0YXRlS2V5XTogdXBkYXRlZEZvcm1TdGF0ZSxcclxuICAgIH07XHJcbiAgfTtcclxufVxyXG4iXX0=
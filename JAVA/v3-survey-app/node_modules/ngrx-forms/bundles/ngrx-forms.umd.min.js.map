{"version":3,"sources":["../../node_modules/tslib/tslib.es6.js","ng://ngrx-forms/src/actions.ts","ng://ngrx-forms/src/boxing.ts","ng://ngrx-forms/src/util.ts","ng://ngrx-forms/src/state.ts","ng://ngrx-forms/src/control/reducer.ts","ng://ngrx-forms/src/control/reducer/reset.ts","ng://ngrx-forms/src/control/reducer/set-user-defined-property.ts","ng://ngrx-forms/src/control/reducer/mark-as-unsubmitted.ts","ng://ngrx-forms/src/control/reducer/mark-as-submitted.ts","ng://ngrx-forms/src/control/reducer/mark-as-untouched.ts","ng://ngrx-forms/src/control/reducer/mark-as-touched.ts","ng://ngrx-forms/src/control/reducer/mark-as-pristine.ts","ng://ngrx-forms/src/control/reducer/mark-as-dirty.ts","ng://ngrx-forms/src/control/reducer/unfocus.ts","ng://ngrx-forms/src/control/reducer/focus.ts","ng://ngrx-forms/src/control/reducer/disable.ts","ng://ngrx-forms/src/control/reducer/enable.ts","ng://ngrx-forms/src/control/reducer/clear-async-error.ts","ng://ngrx-forms/src/control/reducer/set-async-error.ts","ng://ngrx-forms/src/control/reducer/start-async-validation.ts","ng://ngrx-forms/src/control/reducer/set-errors.ts","ng://ngrx-forms/src/control/reducer/set-value.ts","ng://ngrx-forms/src/array/reducer/util.ts","ng://ngrx-forms/src/array/reducer/move-control.ts","ng://ngrx-forms/src/array/reducer/swap-control.ts","ng://ngrx-forms/src/array/reducer.ts","ng://ngrx-forms/src/array/reducer/remove-control.ts","ng://ngrx-forms/src/array/reducer/add-control.ts","ng://ngrx-forms/src/array/reducer/reset.ts","ng://ngrx-forms/src/array/reducer/set-user-defined-property.ts","ng://ngrx-forms/src/array/reducer/mark-as-unsubmitted.ts","ng://ngrx-forms/src/array/reducer/mark-as-submitted.ts","ng://ngrx-forms/src/array/reducer/mark-as-untouched.ts","ng://ngrx-forms/src/array/reducer/mark-as-touched.ts","ng://ngrx-forms/src/array/reducer/mark-as-pristine.ts","ng://ngrx-forms/src/array/reducer/mark-as-dirty.ts","ng://ngrx-forms/src/array/reducer/disable.ts","ng://ngrx-forms/src/array/reducer/enable.ts","ng://ngrx-forms/src/array/reducer/clear-async-error.ts","ng://ngrx-forms/src/array/reducer/set-async-error.ts","ng://ngrx-forms/src/array/reducer/start-async-validation.ts","ng://ngrx-forms/src/array/reducer/set-errors.ts","ng://ngrx-forms/src/array/reducer/set-value.ts","ng://ngrx-forms/src/reducer.ts","ng://ngrx-forms/src/group/reducer/util.ts","ng://ngrx-forms/src/group/reducer.ts","ng://ngrx-forms/src/group/reducer/reset.ts","ng://ngrx-forms/src/group/reducer/set-user-defined-property.ts","ng://ngrx-forms/src/group/reducer/remove-control.ts","ng://ngrx-forms/src/group/reducer/add-control.ts","ng://ngrx-forms/src/group/reducer/mark-as-unsubmitted.ts","ng://ngrx-forms/src/group/reducer/mark-as-submitted.ts","ng://ngrx-forms/src/group/reducer/mark-as-untouched.ts","ng://ngrx-forms/src/group/reducer/mark-as-touched.ts","ng://ngrx-forms/src/group/reducer/mark-as-pristine.ts","ng://ngrx-forms/src/group/reducer/mark-as-dirty.ts","ng://ngrx-forms/src/group/reducer/disable.ts","ng://ngrx-forms/src/group/reducer/enable.ts","ng://ngrx-forms/src/group/reducer/clear-async-error.ts","ng://ngrx-forms/src/group/reducer/set-async-error.ts","ng://ngrx-forms/src/group/reducer/start-async-validation.ts","ng://ngrx-forms/src/group/reducer/set-errors.ts","ng://ngrx-forms/src/group/reducer/set-value.ts","ng://ngrx-forms/src/update-function/util.ts","ng://ngrx-forms/src/update-function/update-array.ts","ng://ngrx-forms/src/update-function/update-group.ts","ng://ngrx-forms/src/view-adapter/view-adapter.ts","ng://ngrx-forms/src/view-adapter/checkbox.ts","ng://ngrx-forms/src/view-adapter/default.ts","ng://ngrx-forms/src/view-adapter/number.ts","ng://ngrx-forms/src/view-adapter/select.ts","ng://ngrx-forms/src/view-adapter/select-multiple.ts","ng://ngrx-forms/src/view-adapter/option.ts","ng://ngrx-forms/src/view-adapter/radio.ts","ng://ngrx-forms/src/view-adapter/range.ts","ng://ngrx-forms/src/view-adapter/util.ts","ng://ngrx-forms/src/control/directive.ts","ng://ngrx-forms/src/control/value-converter.ts","ng://ngrx-forms/src/control/local-state-directive.ts","ng://ngrx-forms/src/group/directive.ts","ng://ngrx-forms/src/group/local-state-directive.ts","ng://ngrx-forms/src/status-css-classes.directive.ts","ng://ngrx-forms/src/module.ts","ng://ngrx-forms/src/update-function/add-array-control.ts","ng://ngrx-forms/src/update-function/add-group-control.ts","ng://ngrx-forms/src/update-function/clear-async-error.ts","ng://ngrx-forms/src/update-function/disable.ts","ng://ngrx-forms/src/update-function/enable.ts","ng://ngrx-forms/src/update-function/focus.ts","ng://ngrx-forms/src/update-function/mark-as-dirty.ts","ng://ngrx-forms/src/update-function/mark-as-pristine.ts","ng://ngrx-forms/src/update-function/mark-as-submitted.ts","ng://ngrx-forms/src/update-function/mark-as-touched.ts","ng://ngrx-forms/src/update-function/mark-as-unsubmitted.ts","ng://ngrx-forms/src/update-function/mark-as-untouched.ts","ng://ngrx-forms/src/update-function/remove-array-control.ts","ng://ngrx-forms/src/update-function/remove-group-control.ts","ng://ngrx-forms/src/update-function/reset.ts","ng://ngrx-forms/src/update-function/set-async-error.ts","ng://ngrx-forms/src/update-function/set-errors.ts","ng://ngrx-forms/src/update-function/set-user-defined-property.ts","ng://ngrx-forms/src/update-function/set-value.ts","ng://ngrx-forms/src/update-function/start-async-validation.ts","ng://ngrx-forms/src/update-function/unfocus.ts","ng://ngrx-forms/src/update-function/update-recursive.ts","ng://ngrx-forms/src/update-function/validate.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__decorate","decorators","target","key","desc","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","__metadata","metadataKey","metadataValue","metadata","__values","o","m","Symbol","iterator","next","value","done","__read","e","ar","push","error","__spread","concat","SetValueAction","controlId","type","TYPE","SetErrorsAction","errors","SetAsyncErrorAction","name","ClearAsyncErrorAction","StartAsyncValidationAction","MarkAsDirtyAction","MarkAsPristineAction","EnableAction","DisableAction","MarkAsTouchedAction","MarkAsUntouchedAction","FocusAction","UnfocusAction","MarkAsSubmittedAction","MarkAsUnsubmittedAction","AddArrayControlAction","index","AddGroupControlAction","RemoveArrayControlAction","SwapArrayControlAction","fromIndex","toIndex","MoveArrayControlAction","RemoveGroupControlAction","SetUserDefinedPropertyAction","ResetAction","isNgrxFormsAction","action","startsWith","ALL_NGRX_FORMS_ACTION_TYPES","isBoxed","__boxed","box","unbox","indexOf","isArray","map","keys","reduce","a","k","_a","isEmpty","obj","deepEquals","_1","_2","l","leftChain","rightChain","_3","_i","compare2Objects","x","y","isNaN","Date","RegExp","String","Number","toString","isPrototypeOf","pop","Error","isFormState","state","isArrayState","controls","isGroupState","createChildState","id","childValue","createFormControlState","createFormArrayState","createFormGroupState","verifyFormControlValueIsValid","errorMsg","JSON","stringify","serialized","parse","pendingValidations","isValidationPending","isValid","isInvalid","isEnabled","isDisabled","isDirty","isPristine","isTouched","isUntouched","isSubmitted","isUnsubmitted","isFocused","isUnfocused","userDefinedProperties","computeGroupState","flags","originalValue","hasChanged","newValue","res","getFormGroupValue","originalErrors","groupErrors","filter","newErrors","controlErrors","getFormGroupErrors","wasOrShouldBeDirty","some","wasOrShouldBeEnabled","wasOrShouldBeTouched","wasOrShouldBeSubmitted","initialValue","_c","_b","computeArrayState","inferredControls","getFormArrayValue","getFormArrayErrors","formControlReducerInternal","resetReducer","setUserDefinedPropertyReducer","markAsUnsubmittedReducer","markAsSubmittedReducer","markAsUntouchedReducer","markAsTouchedReducer","markAsPristineReducer","markAsDirtyReducer","unfocusReducer","focusReducer","disableReducer","enableReducer","v","clearAsyncErrorReducer","setAsyncErrorReducer","startAsyncValidationReducer","asyncErrors","setErrorsReducer","setValueReducer","formControlReducer","dispatchActionPerChild","actionCreator","newControls","newState","formStateReducer","childReducer","callChildReducers","updateIdRecursive","newId","agg","updateIdRecursiveForGroup","updateIdRecursiveForArray","moveControlReducer","array","item","slice","targetIndex","move","swapControlReducer","j","formArrayReducerInternal","_","removeControlReducer","undefined","splice","addControlReducer","childAndAsyncErrors","formArrayReducer","formGroupReducer","reduceNestedFormStates","reduceNestedFormState","formGroupReducerInternal","abstractControlReducer","ensureState","updateArraySingle","filterFn","updateFn","control","idx","newControl","updateArrayControlsState","updateArray","stateOrFunctionOrFunctionArray","updateFnOrUpdateFnArr","rest","updateFnArr_2","updateFnArr","updateGroupSingle","updateFns","updateGroupControlsState","updateGroup","stateOrUpdateFnOrUpdateFnArray","updateFnArr_1","NGRX_FORM_VIEW_ADAPTER","InjectionToken","NgrxCheckboxViewAdapter","renderer","elementRef","nativeIdWasSet","onChange","onTouched","nativeId","nativeElement","setProperty","ngAfterViewInit","setViewValue","setOnChangeCallback","fn","setOnTouchedCallback","setIsDisabled","handleInput","checked","tslib_1.__decorate","HostListener","Input","NgrxCheckboxViewAdapter_1","Directive","selector","providers","provide","useExisting","forwardRef","multi","Renderer2","ElementRef","NgrxDefaultViewAdapter","platformId","navigator","isComposing","isCompositionSupported","isPlatformBrowser","test","userAgent","toLowerCase","isAndroid","window","normalizedValue","compositionStart","compositionEnd","NgrxDefaultViewAdapter_1","tslib_1.__param","Optional","Inject","PLATFORM_ID","NgrxNumberViewAdapter","parseFloat","NgrxNumberViewAdapter_1","NgrxSelectViewAdapter","optionMap","idCounter","selectedId","onChangeFn","getOptionId","createOptionId","updateOptionValue","deregisterOption","tslib_1.__values","from","NgrxSelectViewAdapter_1","NULL_VIEW_ADAPTER","NULL_RENDERER","NgrxSelectOption","element","viewAdapter","isInitialized","ngOnDestroy","Host","NgrxSelectMultipleViewAdapter","options","optionValues","selectedIds","_this","forEach","isSelected","registerOption","option","NgrxSelectMultipleViewAdapter_1","NgrxSelectMultipleOption","selected","ngOnInit","NgrxFallbackSelectOption","multipleViewAdapter","NgrxRadioViewAdapter","nativeNameWasSet","val","latestValue","isChecked","nativeName","NgrxRadioViewAdapter_1","NgrxRangeViewAdapter","NgrxRangeViewAdapter_1","BUILTIN_ADAPTERS","selectViewAdapter","viewAdapters","defaultAdapter","builtinAdapter","customAdapter","NGRX_UPDATE_ON_TYPE","NgrxValueConverters","default","convertViewToStateValue","convertStateToViewValue","dateToISOString","date","toISOString","objectToJSON","ControlValueAccessorAdapter","valueAccessor","writeValue","registerOnChange","registerOnTouched","setDisabledState","NgrxFormControlDirective","el","dom","actionsSubject","valueAccessors","focusTrackingIsEnabled","ngrxUpdateOn","CHANGE","ngrxValueConverter","oldState","updateViewIfControlIdChanged","updateViewIfValueChanged","updateViewIfIsDisabledChanged","updateViewIfIsFocusedChanged","stateValue","viewValue","focus","blur","dispatchAction","dispatchSetValueAction","NEVER","BLUR","onFocusChange","isControlFocused","activeElement","HostBinding","DOCUMENT","ActionsSubject","Self","NG_VALUE_ACCESSOR","NgrxLocalFormControlDirective","_super","ngrxFormsAction","EventEmitter","tslib_1.__extends","emit","Output","NgrxFormDirective","onSubmit","event","preventDefault","NgrxLocalFormDirective","NGRX_STATUS_CLASS_NAMES","NgrxStatusCssClassesDirective","exportsAndDeclarations","NgrxFormsModule","NgModule","declarations","exports","addArrayControl","valueOrState","indexOrValue","addGroupControl","nameOrState","valueOrName","clearAsyncError","fns","f","reducer","types","actionCons","removeArrayControl","indexOrState","removeGroupControl","setAsyncError","nameOrValue","setErrors","errorsOrErrorsArrayOrState","errorsOrErrorsArray","errorsArray_1","err","errorsArray","setUserDefinedProperty","setValue","startAsyncValidation","updateArrayWithFilter","stateOrFilterFunction","filterFunctionOrFunctionOrFunctionArray","filterFn_1","updateRecursive","updateRecursiveSingle","parent","validate","functionOrFunctionArr","functionArr","validationFn","formStateLocator","updatedState","formState","formStateKey","find","updatedFormState"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Action } from '@ngrx/store';\r\nimport { KeyValue, NgrxFormControlId, ValidationErrors } from './state';\r\n\r\n// NOTE: the explicit type declaration for the `TYPE` properties is required\r\n// for the output declarations to properly use the literal string type instead\r\n// of just `string`\r\n\r\nexport class SetValueAction<TValue> implements Action {\r\n  static readonly TYPE: 'ngrx/forms/SET_VALUE' = 'ngrx/forms/SET_VALUE';\r\n  readonly type = SetValueAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n    public readonly value: TValue,\r\n  ) { }\r\n}\r\n\r\nexport class SetErrorsAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/SET_ERRORS' = 'ngrx/forms/SET_ERRORS';\r\n  readonly type = SetErrorsAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n    public readonly errors: ValidationErrors,\r\n  ) { }\r\n}\r\n\r\nexport class SetAsyncErrorAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/SET_ASYNC_ERROR' = 'ngrx/forms/SET_ASYNC_ERROR';\r\n  readonly type = SetAsyncErrorAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n    public readonly name: string,\r\n    public readonly value: any,\r\n  ) { }\r\n}\r\n\r\nexport class ClearAsyncErrorAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/CLEAR_ASYNC_ERROR' = 'ngrx/forms/CLEAR_ASYNC_ERROR';\r\n  readonly type = ClearAsyncErrorAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n    public readonly name: string,\r\n  ) { }\r\n}\r\n\r\nexport class StartAsyncValidationAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/START_ASYNC_VALIDATION' = 'ngrx/forms/START_ASYNC_VALIDATION';\r\n  readonly type = StartAsyncValidationAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n    public readonly name: string,\r\n  ) { }\r\n}\r\n\r\nexport class MarkAsDirtyAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/MARK_AS_DIRTY' = 'ngrx/forms/MARK_AS_DIRTY';\r\n  readonly type = MarkAsDirtyAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n  ) { }\r\n}\r\n\r\nexport class MarkAsPristineAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/MARK_AS_PRISTINE' = 'ngrx/forms/MARK_AS_PRISTINE';\r\n  readonly type = MarkAsPristineAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n  ) { }\r\n}\r\n\r\nexport class EnableAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/ENABLE' = 'ngrx/forms/ENABLE';\r\n  readonly type = EnableAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n  ) { }\r\n}\r\n\r\nexport class DisableAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/DISABLE' = 'ngrx/forms/DISABLE';\r\n  readonly type = DisableAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n  ) { }\r\n}\r\n\r\nexport class MarkAsTouchedAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/MARK_AS_TOUCHED' = 'ngrx/forms/MARK_AS_TOUCHED';\r\n  readonly type = MarkAsTouchedAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n  ) { }\r\n}\r\n\r\nexport class MarkAsUntouchedAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/MARK_AS_UNTOUCHED' = 'ngrx/forms/MARK_AS_UNTOUCHED';\r\n  readonly type = MarkAsUntouchedAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n  ) { }\r\n}\r\n\r\nexport class FocusAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/FOCUS' = 'ngrx/forms/FOCUS';\r\n  readonly type = FocusAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n  ) { }\r\n}\r\n\r\nexport class UnfocusAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/UNFOCUS' = 'ngrx/forms/UNFOCUS';\r\n  readonly type = UnfocusAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n  ) { }\r\n}\r\n\r\nexport class MarkAsSubmittedAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/MARK_AS_SUBMITTED' = 'ngrx/forms/MARK_AS_SUBMITTED';\r\n  readonly type = MarkAsSubmittedAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n  ) { }\r\n}\r\n\r\nexport class MarkAsUnsubmittedAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/MARK_AS_UNSUBMITTED' = 'ngrx/forms/MARK_AS_UNSUBMITTED';\r\n  readonly type = MarkAsUnsubmittedAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n  ) { }\r\n}\r\n\r\nexport class AddArrayControlAction<TValue> implements Action {\r\n  static readonly TYPE: 'ngrx/forms/ADD_ARRAY_CONTROL' = 'ngrx/forms/ADD_ARRAY_CONTROL';\r\n  readonly type = AddArrayControlAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n    public readonly value: TValue,\r\n    public readonly index?: number,\r\n  ) { }\r\n}\r\n\r\nexport class AddGroupControlAction<TValue extends KeyValue, TControlKey extends keyof TValue = keyof TValue> implements Action {\r\n  static readonly TYPE: 'ngrx/forms/ADD_GROUP_CONTROL' = 'ngrx/forms/ADD_GROUP_CONTROL';\r\n  readonly type = AddGroupControlAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n    public readonly name: keyof TValue,\r\n    public readonly value: TValue[TControlKey],\r\n  ) { }\r\n}\r\n\r\nexport class RemoveArrayControlAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/REMOVE_ARRAY_CONTROL' = 'ngrx/forms/REMOVE_ARRAY_CONTROL';\r\n  readonly type = RemoveArrayControlAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n    public readonly index: number,\r\n  ) { }\r\n}\r\n\r\nexport class SwapArrayControlAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/SWAP_ARRAY_CONTROL' = 'ngrx/forms/SWAP_ARRAY_CONTROL';\r\n  readonly type = SwapArrayControlAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n    public readonly fromIndex: number,\r\n    public readonly toIndex: number\r\n  ) { }\r\n}\r\n\r\nexport class MoveArrayControlAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/MOVE_ARRAY_CONTROL' = 'ngrx/forms/MOVE_ARRAY_CONTROL';\r\n  readonly type = MoveArrayControlAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n    public readonly fromIndex: number,\r\n    public readonly toIndex: number\r\n  ) { }\r\n}\r\n\r\nexport class RemoveGroupControlAction<TValue> implements Action {\r\n  static readonly TYPE: 'ngrx/forms/REMOVE_CONTROL' = 'ngrx/forms/REMOVE_CONTROL';\r\n  readonly type = RemoveGroupControlAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n    public readonly name: keyof TValue,\r\n  ) { }\r\n}\r\n\r\nexport class SetUserDefinedPropertyAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/SET_USER_DEFINED_PROPERTY' = 'ngrx/forms/SET_USER_DEFINED_PROPERTY';\r\n  readonly type = SetUserDefinedPropertyAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n    public readonly name: string,\r\n    public readonly value: any,\r\n  ) { }\r\n}\r\n\r\nexport class ResetAction implements Action {\r\n  static readonly TYPE: 'ngrx/forms/RESET' = 'ngrx/forms/RESET';\r\n  readonly type = ResetAction.TYPE;\r\n\r\n  constructor(\r\n    public readonly controlId: NgrxFormControlId,\r\n  ) { }\r\n}\r\n\r\nexport type Actions<TValue> =\r\n  | SetValueAction<TValue>\r\n  | SetErrorsAction\r\n  | SetAsyncErrorAction\r\n  | ClearAsyncErrorAction\r\n  | StartAsyncValidationAction\r\n  | MarkAsDirtyAction\r\n  | MarkAsPristineAction\r\n  | EnableAction\r\n  | DisableAction\r\n  | MarkAsTouchedAction\r\n  | MarkAsUntouchedAction\r\n  | FocusAction\r\n  | UnfocusAction\r\n  | MarkAsSubmittedAction\r\n  | MarkAsUnsubmittedAction\r\n  | AddGroupControlAction<TValue>\r\n  | RemoveGroupControlAction<TValue>\r\n  | AddArrayControlAction<any>\r\n  | RemoveArrayControlAction\r\n  | SetUserDefinedPropertyAction\r\n  | ResetAction\r\n  | SwapArrayControlAction\r\n  | MoveArrayControlAction\r\n  ;\r\n\r\nexport function isNgrxFormsAction(action: Action) {\r\n  return !!action.type && action.type.startsWith('ngrx/forms/');\r\n}\r\n\r\nexport const ALL_NGRX_FORMS_ACTION_TYPES: Actions<any>['type'][] = [\r\n  SetValueAction.TYPE,\r\n  SetErrorsAction.TYPE,\r\n  SetAsyncErrorAction.TYPE,\r\n  ClearAsyncErrorAction.TYPE,\r\n  StartAsyncValidationAction.TYPE,\r\n  MarkAsDirtyAction.TYPE,\r\n  MarkAsPristineAction.TYPE,\r\n  EnableAction.TYPE,\r\n  DisableAction.TYPE,\r\n  MarkAsTouchedAction.TYPE,\r\n  MarkAsUntouchedAction.TYPE,\r\n  FocusAction.TYPE,\r\n  UnfocusAction.TYPE,\r\n  MarkAsSubmittedAction.TYPE,\r\n  MarkAsUnsubmittedAction.TYPE,\r\n  AddGroupControlAction.TYPE,\r\n  RemoveGroupControlAction.TYPE,\r\n  AddArrayControlAction.TYPE,\r\n  RemoveArrayControlAction.TYPE,\r\n  SetUserDefinedPropertyAction.TYPE,\r\n  ResetAction.TYPE,\r\n  SwapArrayControlAction.TYPE,\r\n  MoveArrayControlAction.TYPE,\r\n];\r\n","export interface Boxed<T> {\r\n  __boxed: '';\r\n  value: T;\r\n}\r\n\r\nexport type UnboxedObject<T> = {\r\n  [prop in keyof T]: Unboxed<T[prop]>;\r\n};\r\n\r\nexport type Unboxed<T> =\r\n  // (ab)use 'symbol' to catch 'any' typing\r\n  T extends Boxed<symbol> ? any\r\n  : T extends Boxed<infer U> ? U\r\n  : T extends symbol[] ? any\r\n  : T extends symbol ? any\r\n  : T extends undefined ? undefined\r\n  : T extends null ? null\r\n  : T extends string ? string\r\n  : T extends number ? number\r\n  : T extends boolean ? boolean\r\n  : UnboxedObject<T>;\r\n\r\nexport function isBoxed<T = any>(value: any): value is Boxed<T> {\r\n  return !!value && (value as Boxed<any>).__boxed === '';\r\n}\r\n\r\nexport function box<T>(value: T): Boxed<T> {\r\n  return {\r\n    __boxed: '',\r\n    value,\r\n  };\r\n}\r\n\r\nexport function unbox<T>(value: T): Unboxed<T> {\r\n  if (['string', 'boolean', 'number', 'undefined'].indexOf(typeof value) >= 0 || value === null) {\r\n    return value as unknown as Unboxed<T>;\r\n  }\r\n\r\n  if (isBoxed<T>(value)) {\r\n    return value.value as unknown as Unboxed<T>;\r\n  }\r\n\r\n  if (Array.isArray(value)) {\r\n    return (value as any).map(unbox) as Unboxed<T>;\r\n  }\r\n\r\n  return Object.keys(value as any).reduce(\r\n    (a, k) => Object.assign(a, { [k]: unbox(value[k as keyof T] as any) }),\r\n    {} as any,\r\n  ) as Unboxed<T>;\r\n}\r\n","export function isEmpty(obj: object) {\r\n  return Object.keys(obj).length === 0;\r\n}\r\n\r\nexport function deepEquals<T>(_1: T, _2: T, ..._3: T[]) {\r\n  let i: any;\r\n  let l: any;\r\n  let leftChain: any;\r\n  let rightChain: any;\r\n\r\n  function compare2Objects(x: any, y: any) {\r\n    let p;\r\n\r\n    // remember that NaN === NaN returns false\r\n    // and isNaN(undefined) returns true\r\n    if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number') {\r\n      return true;\r\n    }\r\n\r\n    // Compare primitives and functions.\r\n    // Check if both arguments link to the same object.\r\n    // Especially useful on the step where we compare prototypes\r\n    if (x === y) {\r\n      return true;\r\n    }\r\n\r\n    // Works in case when functions are created in constructor.\r\n    // Comparing dates is a common scenario. Another built-ins?\r\n    // We can even handle functions passed across iframes\r\n    if ((typeof x === 'function' && typeof y === 'function') ||\r\n      (x instanceof Date && y instanceof Date) ||\r\n      (x instanceof RegExp && y instanceof RegExp) ||\r\n      (x instanceof String && y instanceof String) ||\r\n      (x instanceof Number && y instanceof Number)) {\r\n      return x.toString() === y.toString();\r\n    }\r\n\r\n    // At last checking prototypes as good as we can\r\n    if (!(x instanceof Object && y instanceof Object)) {\r\n      return false;\r\n    }\r\n\r\n    if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) {\r\n      return false;\r\n    }\r\n\r\n    if (x.constructor !== y.constructor) {\r\n      return false;\r\n    }\r\n\r\n    // Check for infinitive linking loops\r\n    if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) {\r\n      return false;\r\n    }\r\n\r\n    // Quick checking of one object being a subset of another.\r\n    for (p in y) {\r\n      if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\r\n        return false;\r\n      } else if (typeof y[p] !== typeof x[p]) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // tslint:disable:forin\r\n    for (p in x) {\r\n      if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\r\n        return false;\r\n      }\r\n\r\n      switch (typeof (x[p])) {\r\n        case 'object':\r\n        case 'function':\r\n\r\n          leftChain.push(x);\r\n          rightChain.push(y);\r\n\r\n          if (!compare2Objects(x[p], y[p])) {\r\n            return false;\r\n          }\r\n\r\n          leftChain.pop();\r\n          rightChain.pop();\r\n          break;\r\n\r\n        default:\r\n          if (x[p] !== y[p]) {\r\n            return false;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  if (arguments.length <= 1) {\r\n    throw new Error('Need two or more arguments to compare');\r\n  }\r\n\r\n  for (i = 1, l = arguments.length; i < l; i++) {\r\n    leftChain = [];\r\n    rightChain = [];\r\n\r\n    if (!compare2Objects(arguments[0], arguments[i])) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n","import { Boxed, isBoxed } from './boxing';\r\nimport { deepEquals, isEmpty } from './util';\r\n\r\nexport type FormControlValueTypes = Boxed<any> | string | number | boolean | null | undefined;\r\nexport type NgrxFormControlId = string;\r\n\r\n/**\r\n * This type represents a collection of named errors.\r\n */\r\nexport interface ValidationErrors { readonly [key: string]: any; }\r\nexport interface KeyValue { [key: string]: any; }\r\n\r\n/**\r\n * Base interface for all types of form states.\r\n */\r\nexport interface AbstractControlState<TValue> {\r\n  /**\r\n   * The unique ID of the form state. Usually this is the name or index\r\n   * of the control in the form value prefixed by the ID of the containing\r\n   * group or array, e.g. `MY_FORM.someTextInput` or `MY_FORM.0`.\r\n   */\r\n  readonly id: string;\r\n\r\n  /**\r\n   * The value of the form state.\r\n   */\r\n  readonly value: TValue;\r\n\r\n  /**\r\n   * This property is `true` if the state does not have any errors.\r\n   */\r\n  readonly isValid: boolean;\r\n\r\n  /**\r\n   * This property is `true` if the state has at least one error.\r\n   */\r\n  readonly isInvalid: boolean;\r\n\r\n  /**\r\n   * The errors of the state. This property always has a value.\r\n   * If the state has no errors the property is set to `{}`.\r\n   */\r\n  readonly errors: ValidationErrors;\r\n\r\n  /**\r\n   * The names of all asynchronous validations currently running\r\n   * for the state.\r\n   */\r\n  readonly pendingValidations: readonly string[];\r\n\r\n  /**\r\n   * This property indicates whether the control is currently being\r\n   * asynchronously validated.\r\n   */\r\n  readonly isValidationPending: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the state is enabled. When it\r\n   * is `false` the `errors` are always `{}` (i.e. the state is\r\n   * always valid if disabled) and `pendingValidations` is always `[]`\r\n   * (i.e. all pending validations are cancelled).\r\n   */\r\n  readonly isEnabled: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the state is disabled. When it\r\n   * is `true` the `errors` are always `{}` (i.e. the state is\r\n   * always valid if disabled) and `pendingValidations` is always `[]`\r\n   * (i.e. all pending validations are cancelled).\r\n   */\r\n  readonly isDisabled: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` as soon as the state's value changes.\r\n   */\r\n  readonly isDirty: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the state's value never changed.\r\n   */\r\n  readonly isPristine: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` as soon as the state is touched.\r\n   */\r\n  readonly isTouched: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the state is not touched.\r\n   */\r\n  readonly isUntouched: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` as soon as the state is submitted.\r\n   */\r\n  readonly isSubmitted: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the state is not submitted.\r\n   */\r\n  readonly isUnsubmitted: boolean;\r\n\r\n  /**\r\n   * This property is a container for user-defined metadata (e.g. if\r\n   * you wanted to count the number of times a state's value has been\r\n   * changed, what keys were pressed on an input, or how often a form\r\n   * has been submitted etc.). While it is possible to store this kind\r\n   * of information outside of **ngrx-forms** in your own state the\r\n   * `userDefinedProperties` allow you to store your own metadata\r\n   * directly in the state.\r\n   */\r\n  readonly userDefinedProperties: KeyValue;\r\n}\r\n\r\n/**\r\n * State associated with a form control, i.e. an HTML form\r\n * element in the view (e.g. `input`, `select`, `textarea` etc.).\r\n */\r\nexport interface FormControlState<TValue extends FormControlValueTypes> extends AbstractControlState<TValue> {\r\n  /**\r\n   * The value of the form state. Form controls only support values of\r\n   * type `string`, `number`, `boolean`, `null`, and `undefined` to\r\n   * keep the state string serializable.\r\n   */\r\n  readonly value: TValue;\r\n\r\n  /**\r\n   * This property is `true` if the form control does not have any errors.\r\n   */\r\n  readonly isValid: boolean;\r\n\r\n  /**\r\n   * This property is `true` if the form control has at least one error.\r\n   */\r\n  readonly isInvalid: boolean;\r\n\r\n  /**\r\n   * The errors of the form control. This property always has a value.\r\n   * If the control has no errors the property is set to `{}`.\r\n   */\r\n  readonly errors: ValidationErrors;\r\n\r\n  /**\r\n   * The names of all asynchronous validations currently running for the\r\n   * form control.\r\n   */\r\n  readonly pendingValidations: readonly string[];\r\n\r\n  /**\r\n   * This property indicates whether the control is currently being\r\n   * asynchronously validated (i.e. this is `true` if and only if\r\n   * `pendingValidations` is not empty).\r\n   */\r\n  readonly isValidationPending: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the form control is enabled.\r\n   * When it is `false` the `errors` are always `{}` (i.e. the form\r\n   * control is always valid if disabled) and `pendingValidations`\r\n   * is always `[]` (i.e. all pending validations are cancelled).\r\n   */\r\n  readonly isEnabled: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the form control is disabled.\r\n   * When it is `true` the `errors` are always `{}` (i.e. the form\r\n   * control is always valid if disabled) and `pendingValidations`\r\n   * is always `[]` (i.e. all pending validations are cancelled).\r\n   */\r\n  readonly isDisabled: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` as soon as the underlying\r\n   * `FormViewAdapter` or `ControlValueAccessor` reports a new\r\n   * value for the first time.\r\n   */\r\n  readonly isDirty: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the underlying\r\n   * `FormViewAdapter` or `ControlValueAccessor` has never\r\n   * reported a new value.\r\n   */\r\n  readonly isPristine: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` based on the rules of the\r\n   * underlying `FormViewAdapter` (usually on `blur` for most form\r\n   * elements).\r\n   */\r\n  readonly isTouched: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the control is not touched.\r\n   */\r\n  readonly isUntouched: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` as soon as the group or array\r\n   * containing this form control is submitted. A form control can\r\n   * never be submitted on its own.\r\n   */\r\n  readonly isSubmitted: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the state is not submitted.\r\n   */\r\n  readonly isUnsubmitted: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` if the form control currently\r\n   * has focus. This feature is opt-in. To enable it you have to\r\n   * enable it for a given form element like this:\r\n   *\r\n```html\r\n<input [ngrxFormControlState]=\"state\"\r\n      [ngrxEnableFocusTracking]=\"true\" />\r\n```\r\n   */\r\n  readonly isFocused: boolean;\r\n\r\n  /**\r\n   * This property is `true` if the control currently does not have\r\n   * focus or focus tracking is not enabled for the form control.\r\n   */\r\n  readonly isUnfocused: boolean;\r\n}\r\n\r\n/**\r\n * This type represents the child control states of a form group.\r\n */\r\nexport type FormGroupControls<TValue> = {\r\n  readonly [controlId in keyof TValue]: FormState<TValue[controlId]>;\r\n};\r\n\r\n/**\r\n * Form groups are collections of named controls. Just like controls\r\n * groups are represented as plain state objects. The state of a\r\n * group is determined almost fully by its child states.\r\n */\r\nexport interface FormGroupState<TValue extends KeyValue> extends AbstractControlState<TValue> {\r\n  /**\r\n   * The aggregated value of the form group. The value is computed by\r\n   * aggregating the values of all children, e.g.\r\n   *\r\n```typescript\r\n{\r\n  child1: 'some value',\r\n  child2: {\r\n    nestedChild: 10,\r\n  },\r\n}\r\n```\r\n   */\r\n  readonly value: TValue;\r\n\r\n  /**\r\n   * This property is `true` if the form group does not have any errors\r\n   * itself and none of its children have any errors.\r\n   */\r\n  readonly isValid: boolean;\r\n\r\n  /**\r\n   * This property is `true` if the form group or any of its children\r\n   * have at least one error.\r\n   */\r\n  readonly isInvalid: boolean;\r\n\r\n  /**\r\n   * The errors of the form group. This property is computed by merging\r\n   * the errors of the group with the errors of all its children where\r\n   * the child errors are a property of the `errors` object prefixed with\r\n   * an underscore, e.g.\r\n   *\r\n```\r\n{\r\n  groupError: true,\r\n  _child: {\r\n    childError: true,\r\n  },\r\n}\r\n```\r\n   *\r\n   * If neither the group nor any children have errors the property is\r\n   * set to `{}`.\r\n   */\r\n  readonly errors: ValidationErrors;\r\n\r\n  /**\r\n   * The names of all asynchronous validations currently running for the\r\n   * form group.\r\n   */\r\n  readonly pendingValidations: readonly string[];\r\n\r\n  /**\r\n   * This property indicates whether the group or any of its children\r\n   * are currently being asynchronously validated.\r\n   */\r\n  readonly isValidationPending: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the form group is enabled. It is\r\n   * `true` if and only if at least one of its child states is\r\n   * enabled. When it is `false` the `errors` are always `{}` (i.e.\r\n   * the form group is always valid if disabled) and `pendingValidations`\r\n   * is always `[]` (i.e. all pending validations are cancelled).\r\n   */\r\n  readonly isEnabled: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the form group is disabled. It is\r\n   * `true` if and only if all of its child state are disabled. When\r\n   * it is `true` the `errors` are always `{}` (i.e. the form group\r\n   * is always valid if disabled) and `pendingValidations` is always\r\n   * `[]` (i.e. all pending validations are cancelled).\r\n   */\r\n  readonly isDisabled: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if at least one of the form\r\n   * group's child states is marked as dirty.\r\n   */\r\n  readonly isDirty: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if all of the form group's\r\n   * child states are pristine.\r\n   */\r\n  readonly isPristine: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if at least one of the form\r\n   * group's child states is marked as touched.\r\n   */\r\n  readonly isTouched: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if all of the form group's\r\n   * child states are untouched.\r\n   */\r\n  readonly isUntouched: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` as soon as the form group is\r\n   * submitted. This is tracked by the `NgrxFormDirective`, which\r\n   * needs to be applied to a form like this:\r\n   *\r\n```html\r\n<form [ngrxFormState]=\"groupState\">\r\n</form>\r\n```\r\n   *\r\n   * Note that applying this directive to a form prevents normal form\r\n   * submission since that does not make much sense for ngrx forms.\r\n   */\r\n  readonly isSubmitted: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the state is not submitted.\r\n   */\r\n  readonly isUnsubmitted: boolean;\r\n\r\n  /**\r\n   * This property contains all child states of the form group. As\r\n   * you may have noticed the type of each child state is\r\n   * `AbstractControlState` which sometimes forces you to cast the\r\n   * state explicitly. It is not possible to improve this typing\r\n   * until [conditional mapped types](https://github.com/Microsoft/TypeScript/issues/12424)\r\n   * are added to TypeScript.\r\n   */\r\n  readonly controls: FormGroupControls<TValue>;\r\n}\r\n\r\n/**\r\n * Form arrays are collections of controls. They are represented as\r\n * plain state arrays. The state of an array is determined almost\r\n * fully by its child states.\r\n */\r\nexport interface FormArrayState<TValue> extends AbstractControlState<readonly TValue[]> {\r\n  /**\r\n   * The aggregated value of the form array. The value is computed by\r\n   * aggregating the values of all children into an array.\r\n   */\r\n  readonly value: TValue[];\r\n\r\n  /**\r\n   * This property is `true` if the form array does not have any errors\r\n   * itself and none of its children have any errors.\r\n   */\r\n  readonly isValid: boolean;\r\n\r\n  /**\r\n   * This property is `true` if the form array or any of its children\r\n   * have at least one error.\r\n   */\r\n  readonly isInvalid: boolean;\r\n\r\n  /**\r\n   * The errors of the form array. This property is computed by merging\r\n   * the errors of the array with the errors of all its children where\r\n   * the child errors are a property of the `errors` object prefixed with\r\n   * an underscore, e.g.\r\n   *\r\n```\r\n{\r\n  arrayError: true,\r\n  _0: {\r\n    childError: true,\r\n  },\r\n}\r\n```\r\n   *\r\n   * If neither the array nor any children have errors the property is\r\n   * set to `{}`.\r\n   */\r\n  readonly errors: ValidationErrors;\r\n\r\n  /**\r\n   * The names of all asynchronous validations currently running for the\r\n   * form array.\r\n   */\r\n  readonly pendingValidations: readonly string[];\r\n\r\n  /**\r\n   * This property indicates whether the array or any of its children\r\n   * are currently being asynchronously validated.\r\n   */\r\n  readonly isValidationPending: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the form array is enabled. It is\r\n   * `true` if and only if at least one of its child states is\r\n   * enabled. When it is `false` the `errors` are always `{}` (i.e.\r\n   * the form array is always valid if disabled) and `pendingValidations`\r\n   * is always `[]` (i.e. all pending validations are cancelled).\r\n   */\r\n  readonly isEnabled: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the form array is disabled. It is\r\n   * `true` if and only if all of its child states are disabled. When\r\n   * it is `true` the `errors` are always `{}` (i.e. the form array\r\n   * is always valid if disabled) and `pendingValidations` is always\r\n   * `[]` (i.e. all pending validations are cancelled).\r\n   */\r\n  readonly isDisabled: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if at least one of the form\r\n   * array's child states is marked as dirty.\r\n   */\r\n  readonly isDirty: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if all of the form array's\r\n   * child states are pristine.\r\n   */\r\n  readonly isPristine: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if at least one of the form\r\n   * array's child states is marked as touched.\r\n   */\r\n  readonly isTouched: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if all of the form array's\r\n   * child states are untouched.\r\n   */\r\n  readonly isUntouched: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` as soon as the form array is\r\n   * submitted. This is tracked by the `NgrxFormDirective`, which\r\n   * needs to be applied to a form like this:\r\n   *\r\n```html\r\n<form [ngrxFormState]=\"arrayState\">\r\n</form>\r\n```\r\n   *\r\n   * Note that applying this directive to a form prevents normal form\r\n   * submission since that does not make much sense for ngrx forms.\r\n   */\r\n  readonly isSubmitted: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the state is not submitted.\r\n   */\r\n  readonly isUnsubmitted: boolean;\r\n\r\n  /**\r\n   * This property contains all child states of the form array. As\r\n   * you may have noticed the type of each child state is\r\n   * `AbstractControlState` which sometimes forces you to cast the\r\n   * state explicitly. It is not possible to improve this typing\r\n   * until [conditional mapped types](https://github.com/Microsoft/TypeScript/issues/12424)\r\n   * are added to TypeScript.\r\n   */\r\n  readonly controls: readonly FormState<TValue>[];\r\n}\r\n\r\n/**\r\n * This is a helper type that allows working around the distributiveness\r\n * of conditional types.\r\n */\r\nexport interface InferenceWrapper<T> {\r\n  t: T;\r\n}\r\n\r\n/**\r\n * This is a helper type that infers the correct form state type based\r\n * on the boxed type contained in the inference wrapper.\r\n */\r\nexport type InferredBoxedFormState<T extends InferenceWrapper<any>> =\r\n  T extends InferenceWrapper<Boxed<infer U>> ? FormControlState<Boxed<U>>\r\n  : T extends InferenceWrapper<Boxed<infer U> | undefined> ? FormControlState<Boxed<U> | undefined>\r\n  : T extends InferenceWrapper<Boxed<infer U> | null> ? FormControlState<Boxed<U> | null>\r\n  : T extends InferenceWrapper<Boxed<infer U> | undefined | null> ? FormControlState<Boxed<U> | undefined | null>\r\n  : never\r\n  ;\r\n\r\n/**\r\n * This is a helper type that infers the correct form state type based\r\n * on the string type contained in the inference wrapper.\r\n */\r\nexport type InferredStringFormState<T extends InferenceWrapper<any>> =\r\n  T extends InferenceWrapper<string> ? FormControlState<string>\r\n  : T extends InferenceWrapper<string | undefined> ? FormControlState<string | undefined>\r\n  : T extends InferenceWrapper<string | null> ? FormControlState<string | null>\r\n  : T extends InferenceWrapper<string | undefined | null> ? FormControlState<string | undefined | null>\r\n  : never\r\n  ;\r\n\r\n/**\r\n * This is a helper type that infers the correct form state type based\r\n * on the number type contained in the inference wrapper.\r\n */\r\nexport type InferredNumberFormState<T extends InferenceWrapper<any>> =\r\n  T extends InferenceWrapper<number> ? FormControlState<number>\r\n  : T extends InferenceWrapper<number | undefined> ? FormControlState<number | undefined>\r\n  : T extends InferenceWrapper<number | null> ? FormControlState<number | null>\r\n  : T extends InferenceWrapper<number | undefined | null> ? FormControlState<number | undefined | null>\r\n  : never\r\n  ;\r\n\r\n/**\r\n * This is a helper type that infers the correct form state type based\r\n * on the boolean type contained in the inference wrapper.\r\n */\r\nexport type InferredBooleanFormState<T extends InferenceWrapper<any>> =\r\n  T extends InferenceWrapper<boolean> ? FormControlState<boolean>\r\n  : T extends InferenceWrapper<boolean | undefined> ? FormControlState<boolean | undefined>\r\n  : T extends InferenceWrapper<boolean | null> ? FormControlState<boolean | null>\r\n  : T extends InferenceWrapper<boolean | undefined | null> ? FormControlState<boolean | undefined | null>\r\n  : never\r\n  ;\r\n\r\n/**\r\n * This is a helper type that infers the correct form state type based\r\n * on the type contained in the inference wrapper.\r\n */\r\nexport type InferredFormState<T extends InferenceWrapper<any>> =\r\n  // (ab)use 'symbol' to catch 'any' typing\r\n  T extends InferenceWrapper<symbol> ? AbstractControlState<any>\r\n  : T extends InferenceWrapper<undefined> ? AbstractControlState<any>\r\n  : T extends InferenceWrapper<null> ? AbstractControlState<any>\r\n\r\n  // control\r\n  : T extends InferenceWrapper<Boxed<any> | undefined | null> ? InferredBoxedFormState<T>\r\n  : T extends InferenceWrapper<string | undefined | null> ? InferredStringFormState<T>\r\n  : T extends InferenceWrapper<number | undefined | null> ? InferredNumberFormState<T>\r\n  : T extends InferenceWrapper<boolean | undefined | null> ? InferredBooleanFormState<T>\r\n\r\n  // array\r\n  : T extends InferenceWrapper<readonly (infer U)[] | undefined | null> ? FormArrayState<U>\r\n\r\n  // group\r\n  : T extends InferenceWrapper<infer U | undefined | null> ? FormGroupState<U>\r\n\r\n  // fallback type (this case should never (no pun intended) be hit)\r\n  : never\r\n  ;\r\n\r\n/**\r\n * This is a type that can infer the concrete type of a form state based\r\n * on the given type parameter.\r\n */\r\nexport type FormState<T> = InferredFormState<InferenceWrapper<T>>;\r\n\r\n/**\r\n * This function determines if a value is a form state.\r\n */\r\nexport function isFormState<TValue = any>(state: any): state is FormState<TValue> {\r\n  return !!state && state.hasOwnProperty('id') && state.hasOwnProperty('value') && state.hasOwnProperty('errors');\r\n}\r\n\r\n/**\r\n * This function determines if a value is an array state.\r\n */\r\nexport function isArrayState<TValue = any>(state: any): state is FormArrayState<TValue> {\r\n  return isFormState(state) && state.hasOwnProperty('controls') && Array.isArray((state as any).controls);\r\n}\r\n\r\n/**\r\n * This function determines if a value is a group state.\r\n */\r\nexport function isGroupState<TValue = any>(state: any): state is FormGroupState<TValue> {\r\n  return isFormState(state) && state.hasOwnProperty('controls') && !Array.isArray((state as any).controls) && typeof (state as any).controls !== 'function';\r\n}\r\n\r\nexport function createChildState<TValue>(id: string, childValue: TValue): FormState<TValue> {\r\n  if (isBoxed(childValue)) {\r\n    return createFormControlState<any>(id, childValue) as FormState<TValue>;\r\n  }\r\n\r\n  if (childValue !== null && Array.isArray(childValue)) {\r\n    return createFormArrayState(id, childValue) as FormState<TValue>;\r\n  }\r\n\r\n  if (childValue !== null && typeof childValue === 'object') {\r\n    return createFormGroupState(id, childValue) as FormState<TValue>;\r\n  }\r\n\r\n  return createFormControlState<any>(id, childValue) as FormState<TValue>;\r\n}\r\n\r\nexport function verifyFormControlValueIsValid<TValue>(value: TValue) {\r\n  if (value === null || ['string', 'number', 'boolean', 'undefined'].indexOf(typeof value) >= 0) {\r\n    return value;\r\n  }\r\n\r\n  if (!isBoxed(value)) {\r\n    const errorMsg = 'Form control states only support undefined, null, string, number, and boolean values as well as boxed values';\r\n    throw new Error(`${errorMsg}; got ${JSON.stringify(value)} of type ${typeof value}`); // `;\r\n  }\r\n\r\n  if (value.value === null || ['string', 'number', 'boolean', 'undefined'].indexOf(typeof value.value) >= 0) {\r\n    return value;\r\n  }\r\n\r\n  const serialized = JSON.stringify(value);\r\n  const deserialized = JSON.parse(serialized);\r\n\r\n  if (deepEquals(value, deserialized)) {\r\n    return value;\r\n  }\r\n\r\n  throw new Error(`A form control value must be serializable (i.e. value === JSON.parse(JSON.stringify(value))), got: ${JSON.stringify(value)}`);\r\n}\r\n\r\n/**\r\n * This function creates a form control state with an ID and a value.\r\n */\r\nexport function createFormControlState<TValue extends FormControlValueTypes>(\r\n  id: NgrxFormControlId,\r\n  value: TValue,\r\n): FormControlState<TValue> {\r\n  return {\r\n    id,\r\n    value: verifyFormControlValueIsValid(value),\r\n    errors: {},\r\n    pendingValidations: [],\r\n    isValidationPending: false,\r\n    isValid: true,\r\n    isInvalid: false,\r\n    isEnabled: true,\r\n    isDisabled: false,\r\n    isDirty: false,\r\n    isPristine: true,\r\n    isTouched: false,\r\n    isUntouched: true,\r\n    isSubmitted: false,\r\n    isUnsubmitted: true,\r\n    isFocused: false,\r\n    isUnfocused: true,\r\n    userDefinedProperties: {},\r\n  };\r\n}\r\n\r\nexport function getFormGroupValue<TValue extends KeyValue>(\r\n  controls: FormGroupControls<TValue>,\r\n  originalValue: TValue,\r\n): TValue {\r\n  let hasChanged = Object.keys(originalValue).length !== Object.keys(controls).length;\r\n  const newValue = Object.keys(controls).reduce((res, key: keyof TValue) => {\r\n    hasChanged = hasChanged || originalValue[key] !== controls[key].value;\r\n    res[key] = controls[key].value;\r\n    return res;\r\n  }, {} as TValue);\r\n\r\n  return hasChanged ? newValue : originalValue;\r\n}\r\n\r\nexport function getFormGroupErrors<TValue extends KeyValue>(\r\n  controls: FormGroupControls<TValue>,\r\n  originalErrors: ValidationErrors,\r\n): ValidationErrors {\r\n  let hasChanged = false;\r\n  const groupErrors =\r\n    Object.keys(originalErrors)\r\n      .filter(key => !key.startsWith('_'))\r\n      .reduce((res, key) => Object.assign(res, { [key]: originalErrors[key] }), {} as ValidationErrors);\r\n\r\n  const newErrors = Object.keys(controls).reduce((res, key: any) => {\r\n    const controlErrors = controls[key].errors;\r\n    if (!isEmpty(controlErrors)) {\r\n      hasChanged = hasChanged || originalErrors[`_${key}`] !== controlErrors;\r\n      Object.assign(res, { [`_${key}`]: controls[key].errors });\r\n    } else {\r\n      hasChanged = hasChanged || originalErrors.hasOwnProperty(`_${key}`);\r\n    }\r\n\r\n    return res;\r\n  }, groupErrors);\r\n\r\n  hasChanged = hasChanged || Object.keys(originalErrors).length !== Object.keys(newErrors).length;\r\n\r\n  return hasChanged ? newErrors : originalErrors;\r\n}\r\n\r\nexport function computeGroupState<TValue extends KeyValue>(\r\n  id: string,\r\n  controls: FormGroupControls<TValue>,\r\n  value: TValue,\r\n  errors: ValidationErrors,\r\n  pendingValidations: readonly string[],\r\n  userDefinedProperties: KeyValue,\r\n  flags: {\r\n    wasOrShouldBeDirty?: boolean;\r\n    wasOrShouldBeEnabled?: boolean;\r\n    wasOrShouldBeTouched?: boolean;\r\n    wasOrShouldBeSubmitted?: boolean;\r\n  },\r\n): FormGroupState<TValue> {\r\n  value = getFormGroupValue<TValue>(controls, value);\r\n  errors = getFormGroupErrors(controls, errors);\r\n  const isValid = isEmpty(errors);\r\n  const isDirty = flags.wasOrShouldBeDirty || Object.keys(controls).some(key => controls[key].isDirty);\r\n  const isEnabled = flags.wasOrShouldBeEnabled || Object.keys(controls).some(key => controls[key].isEnabled);\r\n  const isTouched = flags.wasOrShouldBeTouched || Object.keys(controls).some(key => controls[key].isTouched);\r\n  const isSubmitted = flags.wasOrShouldBeSubmitted || Object.keys(controls).some(key => controls[key].isSubmitted);\r\n  const isValidationPending = pendingValidations.length > 0 || Object.keys(controls).some(key => controls[key].isValidationPending);\r\n  return {\r\n    id,\r\n    value,\r\n    errors,\r\n    pendingValidations,\r\n    isValidationPending,\r\n    isValid,\r\n    isInvalid: !isValid,\r\n    isEnabled,\r\n    isDisabled: !isEnabled,\r\n    isDirty,\r\n    isPristine: !isDirty,\r\n    isTouched,\r\n    isUntouched: !isTouched,\r\n    isSubmitted,\r\n    isUnsubmitted: !isSubmitted,\r\n    userDefinedProperties,\r\n    controls,\r\n  };\r\n}\r\n\r\n/**\r\n * This function creates a form group state with an ID and a value.\r\n * From the value the shape of the group state is inferred, i.e.\r\n * object properties are inferred as form groups, array properties\r\n * are inferred as form arrays, and primitive properties are inferred\r\n * as form controls.\r\n */\r\nexport function createFormGroupState<TValue extends KeyValue>(\r\n  id: NgrxFormControlId,\r\n  initialValue: TValue,\r\n): FormGroupState<TValue> {\r\n  const controls = Object.keys(initialValue)\r\n    .map((key: keyof TValue) => [key, createChildState(`${id}.${key}`, initialValue[key])] as [string, FormState<any>])\r\n    .reduce((res, [controlId, state]) => Object.assign(res, { [controlId]: state }), {} as FormGroupControls<TValue>);\r\n\r\n  return computeGroupState(id, controls, initialValue, {}, [], {}, { wasOrShouldBeEnabled: true });\r\n}\r\n\r\nfunction getFormArrayValue<TValue>(\r\n  controls: readonly AbstractControlState<TValue>[],\r\n  originalValue: TValue[],\r\n): TValue[] {\r\n  let hasChanged = Object.keys(originalValue).length !== Object.keys(controls).length;\r\n  const newValue = controls.map((state, i) => {\r\n    hasChanged = hasChanged || originalValue[i] !== state.value;\r\n    return state.value;\r\n  });\r\n\r\n  return hasChanged ? newValue : originalValue;\r\n}\r\n\r\nfunction getFormArrayErrors<TValue>(\r\n  controls: readonly AbstractControlState<TValue>[],\r\n  originalErrors: ValidationErrors,\r\n): ValidationErrors {\r\n  let hasChanged = false;\r\n  const groupErrors =\r\n    Object.keys(originalErrors)\r\n      .filter(key => !key.startsWith('_'))\r\n      .reduce((res, key) => Object.assign(res, { [key]: originalErrors[key] }), {} as ValidationErrors);\r\n\r\n  const newErrors = controls.reduce((res, state, i) => {\r\n    const controlErrors = state.errors;\r\n    if (!isEmpty(controlErrors)) {\r\n      hasChanged = hasChanged || originalErrors[`_${i}`] !== controlErrors;\r\n      Object.assign(res, { [`_${i}`]: controlErrors });\r\n    } else {\r\n      hasChanged = hasChanged || originalErrors.hasOwnProperty(`_${i}`);\r\n    }\r\n\r\n    return res;\r\n  }, groupErrors);\r\n\r\n  hasChanged = hasChanged || Object.keys(originalErrors).length !== Object.keys(newErrors).length;\r\n\r\n  return hasChanged ? newErrors : originalErrors;\r\n}\r\n\r\nexport function computeArrayState<TValue>(\r\n  id: string,\r\n  inferredControls: readonly FormState<TValue>[],\r\n  value: TValue[],\r\n  errors: ValidationErrors,\r\n  pendingValidations: readonly string[],\r\n  userDefinedProperties: KeyValue,\r\n  flags: {\r\n    wasOrShouldBeDirty?: boolean;\r\n    wasOrShouldBeEnabled?: boolean;\r\n    wasOrShouldBeTouched?: boolean;\r\n    wasOrShouldBeSubmitted?: boolean;\r\n  },\r\n): FormArrayState<TValue> {\r\n  const controls = inferredControls as readonly AbstractControlState<any>[];\r\n\r\n  value = getFormArrayValue<TValue>(controls, value);\r\n  errors = getFormArrayErrors(controls, errors);\r\n  const isValid = isEmpty(errors);\r\n  const isDirty = flags.wasOrShouldBeDirty || controls.some(state => state.isDirty);\r\n  const isEnabled = flags.wasOrShouldBeEnabled || controls.some(state => state.isEnabled);\r\n  const isTouched = flags.wasOrShouldBeTouched || controls.some(state => state.isTouched);\r\n  const isSubmitted = flags.wasOrShouldBeSubmitted || controls.some(state => state.isSubmitted);\r\n  const isValidationPending = pendingValidations.length > 0 || controls.some(state => state.isValidationPending);\r\n  return {\r\n    id,\r\n    value,\r\n    errors,\r\n    pendingValidations,\r\n    isValidationPending,\r\n    isValid,\r\n    isInvalid: !isValid,\r\n    isEnabled,\r\n    isDisabled: !isEnabled,\r\n    isDirty,\r\n    isPristine: !isDirty,\r\n    isTouched,\r\n    isUntouched: !isTouched,\r\n    isSubmitted,\r\n    isUnsubmitted: !isSubmitted,\r\n    userDefinedProperties,\r\n    controls: inferredControls,\r\n  };\r\n}\r\n\r\n/**\r\n * This function creates a form array state with an ID and a value.\r\n * From the value the shape of the array state is inferred, i.e.\r\n * object values are inferred as form groups, array values\r\n * are inferred as form arrays, and primitive values are inferred\r\n * as form controls.\r\n */\r\nexport function createFormArrayState<TValue>(\r\n  id: NgrxFormControlId,\r\n  initialValue: TValue[],\r\n): FormArrayState<TValue> {\r\n  const controls = initialValue\r\n    .map((value, i) => createChildState(`${id}.${i}`, value));\r\n\r\n  return computeArrayState(id, controls, initialValue, {}, [], {}, { wasOrShouldBeEnabled: true });\r\n}\r\n","import { Action } from '@ngrx/store';\r\n\r\nimport { Actions } from '../actions';\r\nimport { FormControlState, FormControlValueTypes, isArrayState, isGroupState } from '../state';\r\nimport { clearAsyncErrorReducer } from './reducer/clear-async-error';\r\nimport { disableReducer } from './reducer/disable';\r\nimport { enableReducer } from './reducer/enable';\r\nimport { focusReducer } from './reducer/focus';\r\nimport { markAsDirtyReducer } from './reducer/mark-as-dirty';\r\nimport { markAsPristineReducer } from './reducer/mark-as-pristine';\r\nimport { markAsSubmittedReducer } from './reducer/mark-as-submitted';\r\nimport { markAsTouchedReducer } from './reducer/mark-as-touched';\r\nimport { markAsUnsubmittedReducer } from './reducer/mark-as-unsubmitted';\r\nimport { markAsUntouchedReducer } from './reducer/mark-as-untouched';\r\nimport { resetReducer } from './reducer/reset';\r\nimport { setAsyncErrorReducer } from './reducer/set-async-error';\r\nimport { setErrorsReducer } from './reducer/set-errors';\r\nimport { setUserDefinedPropertyReducer } from './reducer/set-user-defined-property';\r\nimport { setValueReducer } from './reducer/set-value';\r\nimport { startAsyncValidationReducer } from './reducer/start-async-validation';\r\nimport { unfocusReducer } from './reducer/unfocus';\r\n\r\nexport function formControlReducerInternal<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (isGroupState(state) || isArrayState(state)) {\r\n    throw new Error('The state must be a control state');\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return state;\r\n  }\r\n\r\n  state = setValueReducer(state, action);\r\n  state = setErrorsReducer(state, action);\r\n  state = startAsyncValidationReducer(state, action);\r\n  state = setAsyncErrorReducer(state, action);\r\n  state = clearAsyncErrorReducer(state, action);\r\n  state = enableReducer(state, action);\r\n  state = disableReducer(state, action);\r\n  state = focusReducer(state, action);\r\n  state = unfocusReducer(state, action);\r\n  state = markAsDirtyReducer(state, action);\r\n  state = markAsPristineReducer(state, action);\r\n  state = markAsTouchedReducer(state, action);\r\n  state = markAsUntouchedReducer(state, action);\r\n  state = markAsSubmittedReducer(state, action);\r\n  state = markAsUnsubmittedReducer(state, action);\r\n  state = setUserDefinedPropertyReducer(state, action);\r\n  state = resetReducer(state, action);\r\n\r\n  return state;\r\n}\r\n\r\n/**\r\n * This reducer function updates a form control state with actions.\r\n */\r\nexport function formControlReducer<TValue extends FormControlValueTypes>(state: FormControlState<TValue> | undefined, action: Action) {\r\n  if (!state) {\r\n    throw new Error('The control state must be defined!');\r\n  }\r\n\r\n  return formControlReducerInternal(state, action as any);\r\n}\r\n","import { Actions, ResetAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../../state';\r\n\r\nexport function resetReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== ResetAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.isPristine && state.isUntouched && state.isUnsubmitted) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    isDirty: false,\r\n    isPristine: true,\r\n    isTouched: false,\r\n    isUntouched: true,\r\n    isSubmitted: false,\r\n    isUnsubmitted: true,\r\n  };\r\n}\r\n","import { Actions, SetUserDefinedPropertyAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../../state';\r\n\r\nexport function setUserDefinedPropertyReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== SetUserDefinedPropertyAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.userDefinedProperties[action.name] === action.value) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    userDefinedProperties: {\r\n      ...state.userDefinedProperties,\r\n      [action.name]: action.value,\r\n    },\r\n  };\r\n}\r\n","import { Actions, MarkAsUnsubmittedAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../../state';\r\n\r\nexport function markAsUnsubmittedReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== MarkAsUnsubmittedAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.isUnsubmitted) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    isSubmitted: false,\r\n    isUnsubmitted: true,\r\n  };\r\n}\r\n","import { Actions, MarkAsSubmittedAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../../state';\r\n\r\nexport function markAsSubmittedReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== MarkAsSubmittedAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.isSubmitted) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    isSubmitted: true,\r\n    isUnsubmitted: false,\r\n  };\r\n}\r\n","import { Actions, MarkAsUntouchedAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../../state';\r\n\r\nexport function markAsUntouchedReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== MarkAsUntouchedAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.isUntouched) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    isTouched: false,\r\n    isUntouched: true,\r\n  };\r\n}\r\n","import { Actions, MarkAsTouchedAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../../state';\r\n\r\nexport function markAsTouchedReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== MarkAsTouchedAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.isTouched) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    isTouched: true,\r\n    isUntouched: false,\r\n  };\r\n}\r\n","import { Actions, MarkAsPristineAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../../state';\r\n\r\nexport function markAsPristineReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== MarkAsPristineAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.isPristine) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    isDirty: false,\r\n    isPristine: true,\r\n  };\r\n}\r\n","import { Actions, MarkAsDirtyAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../../state';\r\n\r\nexport function markAsDirtyReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== MarkAsDirtyAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.isDirty) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    isDirty: true,\r\n    isPristine: false,\r\n  };\r\n}\r\n","import { Actions, UnfocusAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../../state';\r\n\r\nexport function unfocusReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== UnfocusAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.isUnfocused) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    isFocused: false,\r\n    isUnfocused: true,\r\n  };\r\n}\r\n","import { Actions, FocusAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../../state';\r\n\r\nexport function focusReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== FocusAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.isFocused) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    isFocused: true,\r\n    isUnfocused: false,\r\n  };\r\n}\r\n","import { Actions, DisableAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../../state';\r\n\r\nexport function disableReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== DisableAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.isDisabled) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    isEnabled: false,\r\n    isDisabled: true,\r\n    isValid: true,\r\n    isInvalid: false,\r\n    errors: {},\r\n    pendingValidations: [],\r\n    isValidationPending: false,\r\n  };\r\n}\r\n","import { Actions, EnableAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../../state';\r\n\r\nexport function enableReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== EnableAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.isEnabled) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    isEnabled: true,\r\n    isDisabled: false,\r\n  };\r\n}\r\n","import { Actions, ClearAsyncErrorAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../../state';\r\nimport { isEmpty } from '../../util';\r\n\r\nexport function clearAsyncErrorReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== ClearAsyncErrorAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  const name = `$${action.name}`;\r\n\r\n  let errors = state.errors;\r\n\r\n  if (errors.hasOwnProperty(name)) {\r\n    errors = { ...state.errors };\r\n    delete (errors as any)[name];\r\n  }\r\n\r\n  const pendingValidations = state.pendingValidations.filter(v => v !== action.name);\r\n  const isValid = isEmpty(errors);\r\n\r\n  if (errors === state.errors && isValid === state.isValid && pendingValidations.length === state.pendingValidations.length) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    isValid,\r\n    isInvalid: !isValid,\r\n    errors,\r\n    pendingValidations,\r\n    isValidationPending: pendingValidations.length > 0,\r\n  };\r\n}\r\n","import { Actions, SetAsyncErrorAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../../state';\r\nimport { deepEquals } from '../../util';\r\n\r\nexport function setAsyncErrorReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== SetAsyncErrorAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.isDisabled) {\r\n    return state;\r\n  }\r\n\r\n  const name = `$${action.name}`;\r\n  let value = action.value;\r\n\r\n  if (deepEquals(state.errors[name], action.value)) {\r\n    value = state.errors[name];\r\n  }\r\n\r\n  const errors = { ...state.errors, [name]: value };\r\n  const pendingValidations = state.pendingValidations.filter(v => v !== action.name);\r\n\r\n  return {\r\n    ...state,\r\n    isValid: false,\r\n    isInvalid: true,\r\n    errors,\r\n    pendingValidations,\r\n    isValidationPending: pendingValidations.length > 0,\r\n  };\r\n}\r\n","import { Actions, StartAsyncValidationAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../../state';\r\n\r\nexport function startAsyncValidationReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== StartAsyncValidationAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.pendingValidations.indexOf(action.name) >= 0) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    pendingValidations: [...state.pendingValidations, action.name],\r\n    isValidationPending: true,\r\n  };\r\n}\r\n","import { Actions, SetErrorsAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes, ValidationErrors } from '../../state';\r\nimport { deepEquals, isEmpty } from '../../util';\r\n\r\nexport function setErrorsReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== SetErrorsAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.isDisabled) {\r\n    return state;\r\n  }\r\n\r\n  if (state.errors === action.errors) {\r\n    return state;\r\n  }\r\n\r\n  if (deepEquals(state.errors, action.errors)) {\r\n    return state;\r\n  }\r\n\r\n  if (!action.errors || typeof (action.errors as any) !== 'object' || Array.isArray(action.errors)) {\r\n    throw new Error(`Control errors must be an object; got ${action.errors}`); // `;\r\n  }\r\n\r\n  if (Object.keys(action.errors).some(key => key.startsWith('$'))) {\r\n    throw new Error(`Control errors must not use $ as a prefix; got ${JSON.stringify(action.errors)}`); // `;\r\n  }\r\n\r\n  const asyncErrors =\r\n    Object.keys(state.errors)\r\n      .filter(key => key.startsWith('$'))\r\n      .reduce((res, key) => Object.assign(res, { [key]: state.errors[key] }), {} as ValidationErrors);\r\n\r\n  const newErrors = isEmpty(asyncErrors) ? action.errors : Object.assign(asyncErrors, action.errors);\r\n  const isValid = isEmpty(newErrors);\r\n\r\n  return {\r\n    ...state,\r\n    isValid,\r\n    isInvalid: !isValid,\r\n    errors: newErrors,\r\n  };\r\n}\r\n","import { Actions, SetValueAction } from '../../actions';\r\nimport { FormControlState, FormControlValueTypes, verifyFormControlValueIsValid } from '../../state';\r\n\r\nexport function setValueReducer<TValue extends FormControlValueTypes>(\r\n  state: FormControlState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormControlState<TValue> {\r\n  if (action.type !== SetValueAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (state.value === action.value) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    value: verifyFormControlValueIsValid(action.value),\r\n  };\r\n}\r\n","import { Actions } from '../../actions';\r\nimport { formStateReducer } from '../../reducer';\r\nimport { computeArrayState, FormArrayState, FormGroupControls, FormGroupState, FormState, isArrayState, isGroupState } from '../../state';\r\n\r\nexport function dispatchActionPerChild<TValue>(\r\n  controls: readonly FormState<TValue>[],\r\n  actionCreator: (controlId: string) => Actions<TValue>,\r\n): readonly FormState<TValue>[] {\r\n  let hasChanged = false;\r\n  const newControls = controls\r\n    .map(state => {\r\n      const newState = formStateReducer<TValue>(state, actionCreator(state.id));\r\n      hasChanged = hasChanged || state !== newState;\r\n      return newState;\r\n    });\r\n\r\n  return hasChanged ? newControls : controls;\r\n}\r\n\r\nfunction callChildReducers<TValue>(\r\n  controls: readonly FormState<TValue>[],\r\n  action: Actions<TValue[]>,\r\n): readonly FormState<TValue>[] {\r\n  let hasChanged = false;\r\n  const newControls = controls\r\n    .map(state => {\r\n      const newState = formStateReducer<TValue>(state, action);\r\n      hasChanged = hasChanged || state !== newState;\r\n      return newState;\r\n    });\r\n\r\n  return hasChanged ? newControls : controls;\r\n}\r\n\r\nexport function childReducer<TValue>(state: FormArrayState<TValue>, action: Actions<TValue[]>) {\r\n  const controls = callChildReducers(state.controls, action);\r\n\r\n  if (state.controls === controls) {\r\n    return state;\r\n  }\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n\r\nexport function updateIdRecursiveForGroup<TValue>(state: FormGroupState<TValue>, newId: string): FormGroupState<TValue> {\r\n  const controls: FormGroupControls<TValue> =\r\n    Object.keys(state.controls)\r\n      .reduce((agg, key) => Object.assign(agg, {\r\n        [key]: updateIdRecursive<TValue[keyof TValue]>(state.controls[key as keyof TValue], `${newId}.${key}`),\r\n      }), {} as FormGroupControls<TValue>);\r\n\r\n  return {\r\n    ...state,\r\n    id: newId,\r\n    controls,\r\n  };\r\n}\r\n\r\nexport function updateIdRecursiveForArray<TValue>(state: FormArrayState<TValue>, newId: string): FormArrayState<TValue> {\r\n  const controls = state.controls.map((c, i) => updateIdRecursive(c, `${newId}.${i}`));\r\n\r\n  return {\r\n    ...state,\r\n    id: newId,\r\n    controls,\r\n  };\r\n}\r\n\r\nexport function updateIdRecursive<TValue>(state: FormState<TValue>, newId: string): FormState<TValue> {\r\n  if (state.id === newId) {\r\n    return state;\r\n  }\r\n\r\n  if (isGroupState<TValue>(state)) {\r\n    return updateIdRecursiveForGroup<TValue>(state, newId) as FormState<TValue>;\r\n  }\r\n\r\n  if (isArrayState<TValue>(state)) {\r\n    return updateIdRecursiveForArray<TValue>(state, newId) as any;\r\n  }\r\n\r\n  return {\r\n    ...(state as any),\r\n    id: newId,\r\n  };\r\n}\r\n","import { Actions, MoveArrayControlAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState } from '../../state';\r\nimport { childReducer, updateIdRecursive } from './util';\r\n\r\nexport function move(array: readonly any[], fromIndex: number, toIndex: number) {\r\n  const item = array[fromIndex];\r\n  const length = array.length;\r\n  if (fromIndex > toIndex) {\r\n    return [\r\n      ...array.slice(0, toIndex),\r\n      item,\r\n      ...array.slice(toIndex, fromIndex),\r\n      ...array.slice(fromIndex + 1, length),\r\n    ];\r\n  } else {\r\n    const targetIndex = toIndex + 1;\r\n    return [\r\n      ...array.slice(0, fromIndex),\r\n      ...array.slice(fromIndex + 1, targetIndex),\r\n      item,\r\n      ...array.slice(targetIndex, length),\r\n    ];\r\n  }\r\n}\r\n\r\nexport function moveControlReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== MoveArrayControlAction.TYPE) {\r\n    return state;\r\n  }\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  const fromIndex = action.fromIndex;\r\n  const toIndex = action.toIndex;\r\n\r\n  if (fromIndex === toIndex) {\r\n    return state;\r\n  }\r\n\r\n  if (fromIndex < 0 || toIndex < 0) {\r\n    throw new Error(`fromIndex ${fromIndex} or toIndex ${fromIndex} was negative`);\r\n  }\r\n\r\n  if (fromIndex >= state.controls.length || toIndex >= state.controls.length) {\r\n    throw new Error(`fromIndex ${fromIndex} or toIndex ${toIndex} is out of bounds with the length of the controls ${state.controls.length}`);\r\n  }\r\n\r\n  let controls = move(state.controls, fromIndex, toIndex);\r\n\r\n  controls = controls.map((c, i) => updateIdRecursive(c, `${state.id}.${i}`));\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: true,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    }\r\n  );\r\n}\r\n","import { Actions, SwapArrayControlAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState } from '../../state';\r\nimport { childReducer, updateIdRecursive } from './util';\r\n\r\nfunction swapArrayValues(a: readonly any[], i: number, j: number) {\r\n  const n = [...a];\r\n  [n[i], n[j]] = [n[j], n[i]];\r\n  return n;\r\n}\r\n\r\nexport function swapControlReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== SwapArrayControlAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  const fromIndex = action.fromIndex;\r\n  const toIndex = action.toIndex;\r\n\r\n  if (fromIndex === toIndex) {\r\n    return state;\r\n  }\r\n\r\n  if (fromIndex < 0 || toIndex < 0) {\r\n    throw new Error(`fromIndex ${fromIndex} or toIndex ${fromIndex} was negative`);\r\n  }\r\n\r\n  if (fromIndex >= state.controls.length || toIndex >= state.controls.length) {\r\n    throw new Error(`fromIndex ${fromIndex} or toIndex ${toIndex} is out of bounds with the length of the controls ${state.controls.length}`);\r\n  }\r\n\r\n  let controls = swapArrayValues(state.controls, fromIndex, toIndex);\r\n  controls = controls.map((c, i) => (i >= fromIndex || i >= toIndex) ? updateIdRecursive(c, `${state.id}.${i}`) : c);\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: true,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    }\r\n  );\r\n}\r\n","import { Action } from '@ngrx/store';\r\n\r\nimport {\r\n  Actions,\r\n  AddGroupControlAction,\r\n  FocusAction,\r\n  isNgrxFormsAction,\r\n  RemoveGroupControlAction,\r\n  UnfocusAction,\r\n} from '../actions';\r\nimport { FormArrayState, isArrayState } from '../state';\r\nimport { addControlReducer } from './reducer/add-control';\r\nimport { clearAsyncErrorReducer } from './reducer/clear-async-error';\r\nimport { disableReducer } from './reducer/disable';\r\nimport { enableReducer } from './reducer/enable';\r\nimport { markAsDirtyReducer } from './reducer/mark-as-dirty';\r\nimport { markAsPristineReducer } from './reducer/mark-as-pristine';\r\nimport { markAsSubmittedReducer } from './reducer/mark-as-submitted';\r\nimport { markAsTouchedReducer } from './reducer/mark-as-touched';\r\nimport { markAsUnsubmittedReducer } from './reducer/mark-as-unsubmitted';\r\nimport { markAsUntouchedReducer } from './reducer/mark-as-untouched';\r\nimport { moveControlReducer } from './reducer/move-control';\r\nimport { removeControlReducer } from './reducer/remove-control';\r\nimport { resetReducer } from './reducer/reset';\r\nimport { setAsyncErrorReducer } from './reducer/set-async-error';\r\nimport { setErrorsReducer } from './reducer/set-errors';\r\nimport { setUserDefinedPropertyReducer } from './reducer/set-user-defined-property';\r\nimport { setValueReducer } from './reducer/set-value';\r\nimport { startAsyncValidationReducer } from './reducer/start-async-validation';\r\nimport { swapControlReducer } from './reducer/swap-control';\r\nimport { childReducer } from './reducer/util';\r\n\r\nexport function formArrayReducerInternal<TValue>(state: FormArrayState<TValue>, action: Actions<TValue[]>) {\r\n  if (!isArrayState(state)) {\r\n    throw new Error('The state must be an array state');\r\n  }\r\n\r\n  if (!isNgrxFormsAction(action)) {\r\n    return state;\r\n  }\r\n\r\n  if (!action.controlId.startsWith(state.id)) {\r\n    return state;\r\n  }\r\n\r\n  switch (action.type) {\r\n    case FocusAction.TYPE:\r\n    case UnfocusAction.TYPE:\r\n    case AddGroupControlAction.TYPE:\r\n    case RemoveGroupControlAction.TYPE:\r\n      return childReducer(state, action);\r\n\r\n    default:\r\n      break;\r\n  }\r\n\r\n  state = setValueReducer(state, action);\r\n  state = setErrorsReducer(state, action);\r\n  state = startAsyncValidationReducer(state, action);\r\n  state = setAsyncErrorReducer(state, action);\r\n  state = clearAsyncErrorReducer(state, action);\r\n  state = enableReducer(state, action);\r\n  state = disableReducer(state, action);\r\n  state = markAsDirtyReducer(state, action);\r\n  state = markAsPristineReducer(state, action);\r\n  state = markAsTouchedReducer(state, action);\r\n  state = markAsUntouchedReducer(state, action);\r\n  state = markAsSubmittedReducer(state, action);\r\n  state = markAsUnsubmittedReducer(state, action);\r\n  state = setUserDefinedPropertyReducer(state, action);\r\n  state = resetReducer(state, action);\r\n  state = addControlReducer(state, action);\r\n  state = removeControlReducer(state, action);\r\n  state = swapControlReducer(state, action);\r\n  state = moveControlReducer(state, action);\r\n\r\n  return state;\r\n}\r\n\r\n/**\r\n * This reducer function updates a form array state with actions.\r\n */\r\nexport function formArrayReducer<TValue>(state: FormArrayState<TValue> | undefined, action: Action) {\r\n  if (!state) {\r\n    throw new Error('The array state must be defined!');\r\n  }\r\n\r\n  return formArrayReducerInternal(state, action as any);\r\n}\r\n","import { Actions, RemoveArrayControlAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState } from '../../state';\r\nimport { childReducer, updateIdRecursive } from './util';\r\n\r\nexport function removeControlReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== RemoveArrayControlAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (action.index >= state.controls.length || action.index < 0) {\r\n    throw new Error(`Index ${action.index} is out of bounds for array '${state.id}' with length ${state.controls.length}!`);\r\n  }\r\n\r\n  const index = action.index;\r\n  const controls = state.controls.filter((_, i) => i !== index).map((c, i) => updateIdRecursive(c, `${state.id}.${i}`));\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: true,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, AddArrayControlAction } from '../../actions';\r\nimport { computeArrayState, createChildState, FormArrayState, FormState } from '../../state';\r\nimport { childReducer, updateIdRecursive } from './util';\r\n\r\nexport function addControlReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== AddArrayControlAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  const index = action.index === undefined ? state.controls.length : action.index;\r\n\r\n  if (index > state.controls.length || index < 0) {\r\n    throw new Error(`Index ${index} is out of bounds for array '${state.id}' with length ${state.controls.length}!`);\r\n  }\r\n\r\n  let controls = [...state.controls];\r\n  controls.splice(index, 0, createChildState(`${state.id}.${index}`, action.value) as FormState<TValue>);\r\n  controls = controls.map((c, i) => updateIdRecursive(c, `${state.id}.${i}`));\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: true,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, ResetAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function resetReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== ResetAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.isPristine && state.isUntouched && state.isUnsubmitted) {\r\n    return state;\r\n  }\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    dispatchActionPerChild(state.controls, controlId => new ResetAction(controlId)),\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: false,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: false,\r\n      wasOrShouldBeSubmitted: false,\r\n    },\r\n  );\r\n}\r\n","import { Actions, SetUserDefinedPropertyAction } from '../../actions';\r\nimport { FormArrayState } from '../../state';\r\nimport { childReducer } from './util';\r\n\r\nexport function setUserDefinedPropertyReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== SetUserDefinedPropertyAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.userDefinedProperties[action.name] === action.value) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    userDefinedProperties: {\r\n      ...state.userDefinedProperties,\r\n      [action.name]: action.value,\r\n    },\r\n  };\r\n}\r\n","import { Actions, MarkAsUnsubmittedAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function markAsUnsubmittedReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== MarkAsUnsubmittedAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.isUnsubmitted) {\r\n    return state;\r\n  }\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    dispatchActionPerChild(state.controls, controlId => new MarkAsUnsubmittedAction(controlId)),\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: false,\r\n    },\r\n  );\r\n}\r\n","import { Actions, MarkAsSubmittedAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function markAsSubmittedReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== MarkAsSubmittedAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  const controls = dispatchActionPerChild(state.controls, controlId => new MarkAsSubmittedAction(controlId));\r\n\r\n  if (controls === state.controls) {\r\n    return state;\r\n  }\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: true,\r\n    },\r\n  );\r\n}\r\n","import { Actions, MarkAsUntouchedAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function markAsUntouchedReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== MarkAsUntouchedAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.isUntouched) {\r\n    return state;\r\n  }\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    dispatchActionPerChild(state.controls, controlId => new MarkAsUntouchedAction(controlId)),\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: false,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, MarkAsTouchedAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function markAsTouchedReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== MarkAsTouchedAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  const controls = dispatchActionPerChild(state.controls, controlId => new MarkAsTouchedAction(controlId));\r\n\r\n  if (controls === state.controls) {\r\n    return state;\r\n  }\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: true,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, MarkAsPristineAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function markAsPristineReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== MarkAsPristineAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.isPristine) {\r\n    return state;\r\n  }\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    dispatchActionPerChild(state.controls, controlId => new MarkAsPristineAction(controlId)),\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: false,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, MarkAsDirtyAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function markAsDirtyReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== MarkAsDirtyAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  const controls = dispatchActionPerChild(state.controls, controlId => new MarkAsDirtyAction(controlId));\r\n\r\n  if (controls === state.controls) {\r\n    return state;\r\n  }\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: true,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, DisableAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function disableReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== DisableAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.isDisabled) {\r\n    return state;\r\n  }\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    dispatchActionPerChild(state.controls, controlId => new DisableAction(controlId)),\r\n    state.value,\r\n    {},\r\n    [],\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: false,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, EnableAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function enableReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== EnableAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  const controls = dispatchActionPerChild(state.controls, controlId => new EnableAction(controlId));\r\n\r\n  if (controls === state.controls && state.isEnabled) {\r\n    return state;\r\n  }\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: true,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, ClearAsyncErrorAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState } from '../../state';\r\nimport { childReducer } from './util';\r\n\r\nexport function clearAsyncErrorReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== ClearAsyncErrorAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  const name = `$${action.name}`;\r\n\r\n  let errors = state.errors;\r\n\r\n  if (state.errors.hasOwnProperty(name)) {\r\n    errors = { ...state.errors };\r\n    delete (errors as any)[name];\r\n  }\r\n\r\n  const pendingValidations = state.pendingValidations.filter(v => v !== action.name);\r\n\r\n  if (errors === state.errors && pendingValidations.length === state.pendingValidations.length) {\r\n    return state;\r\n  }\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    state.controls,\r\n    state.value,\r\n    errors,\r\n    pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, SetAsyncErrorAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState } from '../../state';\r\nimport { deepEquals } from '../../util';\r\nimport { childReducer } from './util';\r\n\r\nexport function setAsyncErrorReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== SetAsyncErrorAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.isDisabled) {\r\n    return state;\r\n  }\r\n\r\n  const name = `$${action.name}`;\r\n  let value = action.value;\r\n\r\n  if (deepEquals(state.errors[name], action.value)) {\r\n    value = state.errors[name];\r\n  }\r\n\r\n  const errors = { ...state.errors, [name]: value };\r\n  const pendingValidations = state.pendingValidations.filter(v => v !== action.name);\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    state.controls,\r\n    state.value,\r\n    errors,\r\n    pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, StartAsyncValidationAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState } from '../../state';\r\nimport { childReducer } from './util';\r\n\r\nexport function startAsyncValidationReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== StartAsyncValidationAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.pendingValidations.indexOf(action.name) >= 0) {\r\n    return state;\r\n  }\r\n\r\n  const pendingValidations = [...state.pendingValidations, action.name];\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    state.controls,\r\n    state.value,\r\n    state.errors,\r\n    pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, SetErrorsAction } from '../../actions';\r\nimport { computeArrayState, FormArrayState, ValidationErrors } from '../../state';\r\nimport { deepEquals } from '../../util';\r\nimport { childReducer } from './util';\r\n\r\nexport function setErrorsReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== SetErrorsAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.isDisabled) {\r\n    return state;\r\n  }\r\n\r\n  if (state.errors === action.errors) {\r\n    return state;\r\n  }\r\n\r\n  if (deepEquals(state.errors, action.errors)) {\r\n    return state;\r\n  }\r\n\r\n  if (!action.errors || typeof (action.errors as any) !== 'object' || Array.isArray(action.errors)) {\r\n    throw new Error(`Control errors must be an object; got ${action.errors}`);\r\n  }\r\n\r\n  if (Object.keys(action.errors).some(key => key.startsWith('_'))) {\r\n    throw new Error(`Control errors must not use underscore as a prefix; got ${JSON.stringify(action.errors)}`);\r\n  }\r\n\r\n  if (Object.keys(action.errors).some(key => key.startsWith('$'))) {\r\n    throw new Error(`Control errors must not use $ as a prefix; got ${JSON.stringify(action.errors)}`);\r\n  }\r\n\r\n  const childAndAsyncErrors =\r\n    Object.keys(state.errors)\r\n      .filter(key => key.startsWith('_') || key.startsWith('$'))\r\n      .reduce((res, key) => Object.assign(res, { [key]: state.errors[key] }), {} as ValidationErrors);\r\n\r\n  const newErrors = Object.assign(childAndAsyncErrors, action.errors);\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    state.controls,\r\n    state.value,\r\n    newErrors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, SetValueAction } from '../../actions';\r\nimport { formStateReducer } from '../../reducer';\r\nimport { computeArrayState, createChildState, FormArrayState } from '../../state';\r\nimport { childReducer } from './util';\r\n\r\nexport function setValueReducer<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  action: Actions<TValue[]>,\r\n): FormArrayState<TValue> {\r\n  if (action.type !== SetValueAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.value === action.value) {\r\n    return state;\r\n  }\r\n\r\n  if (action.value instanceof Date) {\r\n    throw new Error('Date values are not supported. Please used serialized strings instead.');\r\n  }\r\n\r\n  const value = action.value;\r\n\r\n  const controls = value\r\n    .map((v, i) => {\r\n      if (!state.controls[i]) {\r\n        return createChildState(`${state.id}.${i}`, v);\r\n      }\r\n\r\n      return formStateReducer<TValue>(state.controls[i], new SetValueAction(state.controls[i].id, v));\r\n    });\r\n\r\n  return computeArrayState(\r\n    state.id,\r\n    controls,\r\n    value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Action, ActionReducer } from '@ngrx/store';\r\n\r\nimport { Actions, ALL_NGRX_FORMS_ACTION_TYPES } from './actions';\r\nimport { formArrayReducer } from './array/reducer';\r\nimport { formControlReducer } from './control/reducer';\r\nimport { formGroupReducer } from './group/reducer';\r\nimport { AbstractControlState, FormControlState, FormState, isArrayState, isFormState, isGroupState } from './state';\r\nimport { ProjectFn } from './update-function/util';\r\n\r\nexport function formStateReducer<TValue>(\r\n  state: FormState<TValue> | AbstractControlState<TValue> | undefined,\r\n  action: Action,\r\n): FormState<TValue> {\r\n  if (!state) {\r\n    throw new Error('The form state must be defined!');\r\n  }\r\n\r\n  if (!isFormState(state)) {\r\n    throw new Error(`state must be a form state, got ${state}`);\r\n  }\r\n\r\n  if (isGroupState(state)) {\r\n    return formGroupReducer(state, action) as any;\r\n  }\r\n\r\n  if (isArrayState(state)) {\r\n    return formArrayReducer(state, action) as any;\r\n  }\r\n\r\n  return formControlReducer(state as FormControlState<any>, action) as any;\r\n}\r\n\r\n/**\r\n * This function creates a reducer function that first applies an action to the state\r\n * and afterwards applies all given update functions one after another to the resulting\r\n * form state. However, the update functions are only applied if the form state changed\r\n * as result of applying the action. If you need the update functions to be applied\r\n * regardless of whether the state changed (e.g. because the update function closes\r\n * over variables that may change independently of the form state) you can simply apply\r\n * the update manually (e.g. `updateFunction(formStateReducer(state, action))`).\r\n *\r\n * The following (contrived) example uses this function to create a reducer that after\r\n * each action validates the child control `name` to be required and sets the child\r\n * control `email`'s value to be `''` if the name is invalid.\r\n *\r\n```typescript\r\ninterface FormValue {\r\n  name: string;\r\n  email: string;\r\n}\r\n\r\nconst updateFormState = updateGroup<FormValue>(\r\n  {\r\n    name: validate(required),\r\n  },\r\n  {\r\n    email: (email, parentGroup) =>\r\n      parentGroup.controls.name.isInvalid\r\n        ? setValue('', email)\r\n        : email,\r\n  },\r\n);\r\n\r\nconst reducer = createFormStateReducerWithUpdate<FormValue>(updateFormState);\r\n```\r\n */\r\nexport function createFormStateReducerWithUpdate<TValue>(\r\n  updateFnOrUpdateFnArr: ProjectFn<FormState<TValue>> | ProjectFn<FormState<TValue>>[],\r\n  ...updateFnArr: ProjectFn<FormState<TValue>>[]\r\n): ActionReducer<FormState<TValue>> {\r\n  updateFnArr = [...(Array.isArray(updateFnOrUpdateFnArr) ? updateFnOrUpdateFnArr : [updateFnOrUpdateFnArr]), ...updateFnArr];\r\n  return (state: FormState<TValue> | undefined, action: Action): FormState<TValue> => {\r\n    const newState = formStateReducer(state as AbstractControlState<TValue>, action);\r\n    return newState === state ? state : updateFnArr.reduce((s, f) => f(s), newState);\r\n  };\r\n}\r\n\r\nfunction reduceNestedFormState<TState>(state: TState, key: keyof TState, action: Action): TState {\r\n  const value = state[key];\r\n\r\n  if (!isFormState(value)) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    [key]: formStateReducer(value, action),\r\n  };\r\n}\r\n\r\nfunction reduceNestedFormStates<TState>(state: TState, action: Action): TState {\r\n  return Object.keys(state).reduce((s, key) => reduceNestedFormState(s, key as keyof TState, action), state);\r\n}\r\n\r\n/**\r\n * This function returns an object that can be passed to ngrx's `createReducer`\r\n * function (available starting with ngrx version 8). By doing this all form\r\n * state properties on the state will be updated whenever necessary (i.e.\r\n * whenever an ngrx-forms action is dispatched).\r\n *\r\n * To manually update a form state (e.g. to validate it) use\r\n * `wrapReducerWithFormStateUpdate`.\r\n */\r\nexport function onNgrxForms<TState = any>(): { reducer: ActionReducer<TState>; types: string[] } {\r\n  return {\r\n    reducer: (state, action) => reduceNestedFormStates(state!, action),\r\n    types: ALL_NGRX_FORMS_ACTION_TYPES,\r\n  };\r\n}\r\n\r\nexport interface ActionConstructor {\r\n  new(...args: any[]): Actions<any>;\r\n  readonly TYPE: string;\r\n}\r\n\r\nexport type CreatedAction<TActionCons> = TActionCons extends new (...args: any[]) => infer TAction ? TAction : never;\r\n\r\n/**\r\n * Define a reducer for a ngrx-forms action. This functions works the same as\r\n * ngrx's `on` except that you provide the ngrx-forms action class instead of\r\n * your action creator as a parameter.\r\n */\r\nexport function onNgrxFormsAction<\r\n  TActionCons extends ActionConstructor,\r\n  TState\r\n>(\r\n  actionCons: TActionCons,\r\n  reducer: (state: TState, action: CreatedAction<TActionCons>) => TState,\r\n): { reducer: ActionReducer<TState>; types: string[] } {\r\n  return {\r\n    reducer: (state, action) => reducer(reduceNestedFormStates(state!, action), action as any),\r\n    types: [actionCons.TYPE],\r\n  };\r\n}\r\n\r\n/**\r\n * This function wraps a reducer and returns another reducer that first calls\r\n * the given reducer and then calls the given update function for the form state\r\n * that is specified by the form state locator function.\r\n *\r\n * The update function is passed the form state and the updated containing state\r\n * as parameters.\r\n */\r\nexport function wrapReducerWithFormStateUpdate<TState, TFormState extends AbstractControlState<any>>(\r\n  reducer: ActionReducer<TState>,\r\n  formStateLocator: (state: TState) => TFormState,\r\n  updateFn: (formState: TFormState, state: TState) => TFormState,\r\n): ActionReducer<TState> {\r\n  return (state, action) => {\r\n    const updatedState = reducer(state, action);\r\n\r\n    const formState = formStateLocator(updatedState);\r\n    const formStateKey = Object.keys(updatedState).find(key => updatedState[key as keyof TState] as any === formState)!;\r\n\r\n    const updatedFormState = updateFn(formState, updatedState);\r\n\r\n    if (updatedFormState === formState) {\r\n      return updatedState;\r\n    }\r\n\r\n    return {\r\n      ...updatedState,\r\n      [formStateKey]: updatedFormState,\r\n    };\r\n  };\r\n}\r\n","import { Actions } from '../../actions';\r\nimport { formStateReducer } from '../../reducer';\r\nimport { computeGroupState, FormGroupControls, FormGroupState, FormState, KeyValue } from '../../state';\r\n\r\nexport function dispatchActionPerChild<TValue extends KeyValue>(\r\n  controls: FormGroupControls<TValue>,\r\n  actionCreator: (controlId: string) => Actions<TValue>,\r\n) {\r\n  let hasChanged = false;\r\n  const newControls = Object.keys(controls)\r\n    .reduce((c, key) => {\r\n      Object.assign(c, { [key]: formStateReducer(controls[key], actionCreator(controls[key].id)) });\r\n      hasChanged = hasChanged || c[key] !== controls[key];\r\n      return c;\r\n    }, {} as FormGroupControls<TValue>);\r\n  return hasChanged ? newControls : controls;\r\n}\r\n\r\nfunction callChildReducers<TValue extends { [key: string]: any }>(\r\n  controls: FormGroupControls<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupControls<TValue> {\r\n  let hasChanged = false;\r\n  const newControls = Object.keys(controls)\r\n    .map(key => [key, formStateReducer(controls[key], action)] as [string, FormState<any>])\r\n    .reduce((res, [key, state]) => {\r\n      hasChanged = hasChanged || state !== controls[key];\r\n      return Object.assign(res, { [key]: state });\r\n    }, {} as FormGroupControls<TValue>);\r\n  return hasChanged ? newControls : controls;\r\n}\r\n\r\nexport function childReducer<TValue extends KeyValue>(state: FormGroupState<TValue>, action: Actions<TValue>) {\r\n  const controls = callChildReducers(state.controls, action);\r\n\r\n  if (state.controls === controls) {\r\n    return state;\r\n  }\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Action } from '@ngrx/store';\r\n\r\nimport {\r\n  Actions,\r\n  AddArrayControlAction,\r\n  FocusAction,\r\n  isNgrxFormsAction,\r\n  RemoveArrayControlAction,\r\n  UnfocusAction,\r\n} from '../actions';\r\nimport { FormGroupState, isGroupState, KeyValue } from '../state';\r\nimport { addControlReducer } from './reducer/add-control';\r\nimport { clearAsyncErrorReducer } from './reducer/clear-async-error';\r\nimport { disableReducer } from './reducer/disable';\r\nimport { enableReducer } from './reducer/enable';\r\nimport { markAsDirtyReducer } from './reducer/mark-as-dirty';\r\nimport { markAsPristineReducer } from './reducer/mark-as-pristine';\r\nimport { markAsSubmittedReducer } from './reducer/mark-as-submitted';\r\nimport { markAsTouchedReducer } from './reducer/mark-as-touched';\r\nimport { markAsUnsubmittedReducer } from './reducer/mark-as-unsubmitted';\r\nimport { markAsUntouchedReducer } from './reducer/mark-as-untouched';\r\nimport { removeControlReducer } from './reducer/remove-control';\r\nimport { resetReducer } from './reducer/reset';\r\nimport { setAsyncErrorReducer } from './reducer/set-async-error';\r\nimport { setErrorsReducer } from './reducer/set-errors';\r\nimport { setUserDefinedPropertyReducer } from './reducer/set-user-defined-property';\r\nimport { setValueReducer } from './reducer/set-value';\r\nimport { startAsyncValidationReducer } from './reducer/start-async-validation';\r\nimport { childReducer } from './reducer/util';\r\n\r\nexport function formGroupReducerInternal<TValue extends KeyValue>(state: FormGroupState<TValue>, action: Actions<TValue>) {\r\n  if (!isGroupState(state)) {\r\n    throw new Error('The state must be a group state');\r\n  }\r\n\r\n  if (!isNgrxFormsAction(action)) {\r\n    return state;\r\n  }\r\n\r\n  if (!action.controlId.startsWith(state.id)) {\r\n    return state;\r\n  }\r\n\r\n  switch (action.type) {\r\n    case FocusAction.TYPE:\r\n    case UnfocusAction.TYPE:\r\n    case AddArrayControlAction.TYPE:\r\n    case RemoveArrayControlAction.TYPE:\r\n      return childReducer(state, action);\r\n\r\n    default:\r\n      break;\r\n  }\r\n\r\n  state = setValueReducer(state, action);\r\n  state = setErrorsReducer(state, action);\r\n  state = startAsyncValidationReducer(state, action);\r\n  state = setAsyncErrorReducer(state, action);\r\n  state = clearAsyncErrorReducer(state, action);\r\n  state = enableReducer(state, action);\r\n  state = disableReducer(state, action);\r\n  state = markAsDirtyReducer(state, action);\r\n  state = markAsPristineReducer(state, action);\r\n  state = markAsTouchedReducer(state, action);\r\n  state = markAsUntouchedReducer(state, action);\r\n  state = markAsSubmittedReducer(state, action);\r\n  state = markAsUnsubmittedReducer(state, action);\r\n  state = addControlReducer(state, action);\r\n  state = removeControlReducer(state, action);\r\n  state = setUserDefinedPropertyReducer(state, action);\r\n  state = resetReducer(state, action);\r\n\r\n  return state;\r\n}\r\n\r\n/**\r\n * This reducer function updates a form group state with actions.\r\n */\r\nexport function formGroupReducer<TValue extends KeyValue>(state: FormGroupState<TValue> | undefined, action: Action) {\r\n  if (!state) {\r\n    throw new Error('The group state must be defined!');\r\n  }\r\n\r\n  return formGroupReducerInternal(state, action as any);\r\n}\r\n","import { Actions, ResetAction } from '../../actions';\r\nimport { computeGroupState, FormGroupState, KeyValue } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function resetReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== ResetAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.isPristine && state.isUntouched && state.isUnsubmitted) {\r\n    return state;\r\n  }\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    dispatchActionPerChild(state.controls, controlId => new ResetAction(controlId)),\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: false,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: false,\r\n      wasOrShouldBeSubmitted: false,\r\n    },\r\n  );\r\n}\r\n","import { Actions, SetUserDefinedPropertyAction } from '../../actions';\r\nimport { FormGroupState, KeyValue } from '../../state';\r\nimport { childReducer } from './util';\r\n\r\nexport function setUserDefinedPropertyReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== SetUserDefinedPropertyAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.userDefinedProperties[action.name] === action.value) {\r\n    return state;\r\n  }\r\n\r\n  return {\r\n    ...state,\r\n    userDefinedProperties: {\r\n      ...state.userDefinedProperties,\r\n      [action.name]: action.value,\r\n    },\r\n  };\r\n}\r\n","import { Actions, RemoveGroupControlAction } from '../../actions';\r\nimport { computeGroupState, FormGroupState, KeyValue } from '../../state';\r\nimport { childReducer } from './util';\r\n\r\nexport function removeControlReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== RemoveGroupControlAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (!state.controls.hasOwnProperty(action.name)) {\r\n    throw new Error(`Group '${state.id}' does not have child control '${action.name}'!`); // `;\r\n  }\r\n\r\n  const controls = Object.assign({}, state.controls);\r\n  delete controls[action.name];\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: true,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, AddGroupControlAction } from '../../actions';\r\nimport { computeGroupState, createChildState, FormGroupState, KeyValue } from '../../state';\r\nimport { childReducer } from './util';\r\n\r\nexport function addControlReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== AddGroupControlAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.controls.hasOwnProperty(action.name)) {\r\n    throw new Error(`Group '${state.id}' already has child control '${action.name}'!`); // `;\r\n  }\r\n\r\n  const controls = Object.assign({}, state.controls, {\r\n    [action.name]: createChildState(`${state.id}.${action.name}`, action.value),\r\n  });\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: true,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, MarkAsUnsubmittedAction } from '../../actions';\r\nimport { computeGroupState, FormGroupState, KeyValue } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function markAsUnsubmittedReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== MarkAsUnsubmittedAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.isUnsubmitted) {\r\n    return state;\r\n  }\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    dispatchActionPerChild(state.controls, controlId => new MarkAsUnsubmittedAction(controlId)),\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: false,\r\n    },\r\n  );\r\n}\r\n","import { Actions, MarkAsSubmittedAction } from '../../actions';\r\nimport { computeGroupState, FormGroupState, KeyValue } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function markAsSubmittedReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== MarkAsSubmittedAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  const controls = dispatchActionPerChild(state.controls, controlId => new MarkAsSubmittedAction(controlId));\r\n\r\n  if (controls === state.controls) {\r\n    return state;\r\n  }\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: true,\r\n    },\r\n  );\r\n}\r\n","import { Actions, MarkAsUntouchedAction } from '../../actions';\r\nimport { computeGroupState, FormGroupState, KeyValue } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function markAsUntouchedReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== MarkAsUntouchedAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.isUntouched) {\r\n    return state;\r\n  }\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    dispatchActionPerChild(state.controls, controlId => new MarkAsUntouchedAction(controlId)),\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: false,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, MarkAsTouchedAction } from '../../actions';\r\nimport { computeGroupState, FormGroupState, KeyValue } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function markAsTouchedReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== MarkAsTouchedAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  const controls = dispatchActionPerChild(state.controls, controlId => new MarkAsTouchedAction(controlId));\r\n\r\n  if (controls === state.controls) {\r\n    return state;\r\n  }\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: true,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, MarkAsPristineAction } from '../../actions';\r\nimport { computeGroupState, FormGroupState, KeyValue } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function markAsPristineReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== MarkAsPristineAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.isPristine) {\r\n    return state;\r\n  }\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    dispatchActionPerChild(state.controls, controlId => new MarkAsPristineAction(controlId)),\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: false,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, MarkAsDirtyAction } from '../../actions';\r\nimport { computeGroupState, FormGroupState, KeyValue } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function markAsDirtyReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== MarkAsDirtyAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  const controls = dispatchActionPerChild(state.controls, controlId => new MarkAsDirtyAction(controlId));\r\n\r\n  if (controls === state.controls) {\r\n    return state;\r\n  }\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: true,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, DisableAction } from '../../actions';\r\nimport { computeGroupState, FormGroupState, KeyValue } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function disableReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== DisableAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.isDisabled) {\r\n    return state;\r\n  }\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    dispatchActionPerChild(state.controls, controlId => new DisableAction(controlId)),\r\n    state.value,\r\n    {},\r\n    [],\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: false,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, EnableAction } from '../../actions';\r\nimport { computeGroupState, FormGroupState, KeyValue } from '../../state';\r\nimport { childReducer, dispatchActionPerChild } from './util';\r\n\r\nexport function enableReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== EnableAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  const controls = dispatchActionPerChild(state.controls, controlId => new EnableAction(controlId));\r\n\r\n  if (controls === state.controls) {\r\n    return state;\r\n  }\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    controls,\r\n    state.value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: true,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, ClearAsyncErrorAction } from '../../actions';\r\nimport { computeGroupState, FormGroupState, KeyValue } from '../../state';\r\nimport { childReducer } from './util';\r\n\r\nexport function clearAsyncErrorReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== ClearAsyncErrorAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  const name = `$${action.name}`;\r\n\r\n  let errors = state.errors;\r\n\r\n  if (errors.hasOwnProperty(name)) {\r\n    errors = { ...state.errors };\r\n    delete (errors as any)[name];\r\n  }\r\n\r\n  const pendingValidations = state.pendingValidations.filter(v => v !== action.name);\r\n\r\n  if (errors === state.errors && pendingValidations.length === state.pendingValidations.length) {\r\n    return state;\r\n  }\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    state.controls,\r\n    state.value,\r\n    errors,\r\n    pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, SetAsyncErrorAction } from '../../actions';\r\nimport { computeGroupState, FormGroupState, KeyValue } from '../../state';\r\nimport { deepEquals } from '../../util';\r\nimport { childReducer } from './util';\r\n\r\nexport function setAsyncErrorReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== SetAsyncErrorAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.isDisabled) {\r\n    return state;\r\n  }\r\n\r\n  const name = `$${action.name}`;\r\n  let value = action.value;\r\n\r\n  if (deepEquals(state.errors[name], action.value)) {\r\n    value = state.errors[name];\r\n  }\r\n\r\n  const errors = { ...state.errors, [name]: value };\r\n  const pendingValidations = state.pendingValidations.filter(v => v !== action.name);\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    state.controls,\r\n    state.value,\r\n    errors,\r\n    pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, StartAsyncValidationAction } from '../../actions';\r\nimport { computeGroupState, FormGroupState, KeyValue } from '../../state';\r\nimport { childReducer } from './util';\r\n\r\nexport function startAsyncValidationReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== StartAsyncValidationAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.pendingValidations.indexOf(action.name) >= 0) {\r\n    return state;\r\n  }\r\n\r\n  const pendingValidations = [...state.pendingValidations, action.name];\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    state.controls,\r\n    state.value,\r\n    state.errors,\r\n    pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, SetErrorsAction } from '../../actions';\r\nimport { computeGroupState, FormGroupState, KeyValue, ValidationErrors } from '../../state';\r\nimport { deepEquals } from '../../util';\r\nimport { childReducer } from './util';\r\n\r\nexport function setErrorsReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== SetErrorsAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.isDisabled) {\r\n    return state;\r\n  }\r\n\r\n  if (state.errors === action.errors) {\r\n    return state;\r\n  }\r\n\r\n  if (deepEquals(state.errors, action.errors)) {\r\n    return state;\r\n  }\r\n\r\n  if (!action.errors || typeof (action.errors as any) !== 'object' || Array.isArray(action.errors)) {\r\n    throw new Error(`Control errors must be an object; got ${action.errors}`); // `;\r\n  }\r\n\r\n  if (Object.keys(action.errors).some(key => key.startsWith('_'))) {\r\n    throw new Error(`Control errors must not use underscore as a prefix; got ${JSON.stringify(action.errors)}`); // `;\r\n  }\r\n\r\n  if (Object.keys(action.errors).some(key => key.startsWith('$'))) {\r\n    throw new Error(`Control errors must not use $ as a prefix; got ${JSON.stringify(action.errors)}`); // `;\r\n  }\r\n\r\n  const childAndAsyncErrors =\r\n    Object.keys(state.errors)\r\n      .filter(key => key.startsWith('_') || key.startsWith('$'))\r\n      .reduce((res, key) => Object.assign(res, { [key]: state.errors[key] }), {} as ValidationErrors);\r\n\r\n  const newErrors = Object.assign(childAndAsyncErrors, action.errors);\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    state.controls,\r\n    state.value,\r\n    newErrors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Actions, SetValueAction } from '../../actions';\r\nimport { formStateReducer } from '../../reducer';\r\nimport { computeGroupState, createChildState, FormGroupControls, FormGroupState, KeyValue } from '../../state';\r\nimport { childReducer } from './util';\r\n\r\nexport function setValueReducer<TValue extends KeyValue>(\r\n  state: FormGroupState<TValue>,\r\n  action: Actions<TValue>,\r\n): FormGroupState<TValue> {\r\n  if (action.type !== SetValueAction.TYPE) {\r\n    return state;\r\n  }\r\n\r\n  if (action.controlId !== state.id) {\r\n    return childReducer(state, action);\r\n  }\r\n\r\n  if (state.value === action.value) {\r\n    return state;\r\n  }\r\n\r\n  if (action.value instanceof Date) {\r\n    throw new Error('Date values are not supported. Please used serialized strings instead.');\r\n  }\r\n\r\n  const value = action.value;\r\n\r\n  const controls = Object.keys(value)\r\n    .reduce((c, key) => {\r\n      // tslint:disable-next-line:prefer-conditional-expression\r\n      if (!state.controls[key]) {\r\n        Object.assign(c, { [key]: createChildState<TValue[string]>(`${state.id}.${key}`, value[key]) });\r\n      } else {\r\n        Object.assign(c, { [key]: formStateReducer(state.controls[key], new SetValueAction(state.controls[key].id, value[key])) });\r\n      }\r\n      return c;\r\n    }, {} as FormGroupControls<TValue>);\r\n\r\n  return computeGroupState(\r\n    state.id,\r\n    controls,\r\n    value,\r\n    state.errors,\r\n    state.pendingValidations,\r\n    state.userDefinedProperties,\r\n    {\r\n      wasOrShouldBeDirty: state.isDirty,\r\n      wasOrShouldBeEnabled: state.isEnabled,\r\n      wasOrShouldBeTouched: state.isTouched,\r\n      wasOrShouldBeSubmitted: state.isSubmitted,\r\n    },\r\n  );\r\n}\r\n","import { Action } from '@ngrx/store';\r\n\r\nimport { formArrayReducer } from '../array/reducer';\r\nimport { formControlReducer } from '../control/reducer';\r\nimport { formGroupReducer } from '../group/reducer';\r\nimport { AbstractControlState, isArrayState, isGroupState } from '../state';\r\n\r\nexport type ProjectFn<T> = (t: T) => T;\r\nexport type ProjectFn2<T, K> = (t: T, k: K) => T;\r\n\r\nexport function abstractControlReducer<TValue>(state: AbstractControlState<TValue>, action: Action): AbstractControlState<TValue> {\r\n  if (isArrayState(state)) {\r\n    return formArrayReducer(state, action as any) as any;\r\n  }\r\n\r\n  if (isGroupState(state)) {\r\n    return formGroupReducer(state, action);\r\n  }\r\n\r\n  return formControlReducer(state as any, action) as any;\r\n}\r\n\r\nexport function compose<T>(...fns: ((t: T) => T)[]) {\r\n  return (t: T) => fns.reduce((res, f) => f(res), t);\r\n}\r\n\r\nexport function ensureState<TState>(state: TState | undefined): TState {\r\n  if (!state) {\r\n    throw new Error('state must not be undefined!');\r\n  }\r\n\r\n  return state;\r\n}\r\n","import { computeArrayState, FormArrayState, FormState, isArrayState } from '../state';\r\nimport { ensureState, ProjectFn2 } from './util';\r\n\r\nexport type FilterFn<TValue> = (s: FormState<TValue>, idx: number) => boolean;\r\n\r\nfunction updateArrayControlsState<TValue>(filterFn: FilterFn<TValue>, updateFn: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>) {\r\n  return (state: FormArrayState<TValue>) => {\r\n    let hasChanged = false;\r\n    const newControls = state.controls.map((control, idx) => {\r\n      if (!filterFn(control, idx)) {\r\n        return control;\r\n      }\r\n\r\n      const newControl = updateFn(control, state);\r\n      hasChanged = hasChanged || newControl !== control;\r\n      return newControl;\r\n    });\r\n    return hasChanged ? newControls : state.controls;\r\n  };\r\n}\r\n\r\nfunction updateArraySingle<TValue>(filterFn: FilterFn<TValue>, updateFn: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>) {\r\n  return (state: FormArrayState<TValue>): FormArrayState<TValue> => {\r\n    const newControls = updateArrayControlsState<TValue>(filterFn, updateFn)(state);\r\n    return newControls !== state.controls\r\n      ? computeArrayState<TValue>(\r\n        state.id,\r\n        newControls,\r\n        state.value,\r\n        state.errors,\r\n        state.pendingValidations,\r\n        state.userDefinedProperties,\r\n        {\r\n          wasOrShouldBeDirty: state.isDirty,\r\n          wasOrShouldBeEnabled: state.isEnabled,\r\n          wasOrShouldBeTouched: state.isTouched,\r\n          wasOrShouldBeSubmitted: state.isSubmitted,\r\n        },\r\n      )\r\n      : state;\r\n  };\r\n}\r\n\r\n/**\r\n * This update function takes a filter function and one or more update functions\r\n * and returns a projection function that applies all update functions one after\r\n * another to each element of the form array state for which the filter function\r\n * returns `true`.\r\n *\r\n * The following (contrived) example uses this function to validate all its\r\n * children to be required and mark them as dirty.\r\n *\r\n```typescript\r\nconst arrayUpdateFn = updateArray<string>(\r\n  (_, idx) => idx > 0,\r\n  validate(required),\r\n  markAsDirty,\r\n);\r\nconst updatedState = arrayUpdateFn(state);\r\n```\r\n */\r\nexport function updateArrayWithFilter<TValue>(\r\n  filterFn: FilterFn<TValue>,\r\n  updateFn: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>,\r\n  ...updateFnArr: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>[]\r\n): (state: FormArrayState<TValue>) => FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes a filter function and an array of update functions\r\n * and returns a projection function that applies all update functions one after\r\n * another to each element of the form array state for which the filter function\r\n * returns `true`.\r\n *\r\n * The following (contrived) example uses this function to validate all its\r\n * children to be required and mark them as dirty.\r\n *\r\n```typescript\r\nconst arrayUpdateFn = updateArray<string>(\r\n  (_, idx) => idx > 0,\r\n  [\r\n    validate(required),\r\n    markAsDirty,\r\n  ],\r\n);\r\nconst updatedState = arrayUpdateFn(state);\r\n```\r\n */\r\nexport function updateArrayWithFilter<TValue>(\r\n  filterFn: FilterFn<TValue>,\r\n  updateFnArr: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>[],\r\n): (state: FormArrayState<TValue>) => FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes a form array state, a filter function, and a variable\r\n * number of update functions and applies all update functions one after another to\r\n * each element of the form array state for which the filter function returns `true`.\r\n *\r\n * The following (contrived) example uses this function to validate all its\r\n * children to be required and mark them as dirty.\r\n *\r\n```typescript\r\nconst updatedState = updateArray<string>(\r\n  state,\r\n  (_, idx) => idx > 0,\r\n  validate(required),\r\n  markAsDirty,\r\n);\r\n```\r\n */\r\nexport function updateArrayWithFilter<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  filterFn: FilterFn<TValue>,\r\n  updateFn: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>,\r\n  ...updateFnArr: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>[]\r\n): FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes a form array state, a filter function, and an array of\r\n * update functions and applies all update functions one after another to each\r\n * element of the form array state for which the filter function returns `true`.\r\n *\r\n * The following (contrived) example uses this function to validate all its\r\n * children to be required and mark them as dirty.\r\n *\r\n```typescript\r\nconst updatedState = updateArray<string>(\r\n  state,\r\n  (_, idx) => idx > 0,\r\n  [\r\n    validate(required),\r\n    markAsDirty,\r\n  ],\r\n);\r\n```\r\n */\r\nexport function updateArrayWithFilter<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  filterFn: FilterFn<TValue>,\r\n  updateFnArr: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>[],\r\n): FormArrayState<TValue>;\r\n\r\nexport function updateArrayWithFilter<TValue>(\r\n  stateOrFilterFunction: FormArrayState<TValue> | FilterFn<TValue>,\r\n  filterFunctionOrFunctionOrFunctionArray:\r\n    | FilterFn<TValue>\r\n    | ProjectFn2<FormState<TValue>, FormArrayState<TValue>>\r\n    | ProjectFn2<FormState<TValue>, FormArrayState<TValue>>[],\r\n  updateFnOrUpdateFnArr?: ProjectFn2<FormState<TValue>, FormArrayState<TValue>> | ProjectFn2<FormState<TValue>, FormArrayState<TValue>>[],\r\n  ...rest: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>[]\r\n) {\r\n  if (isArrayState<TValue>(stateOrFilterFunction)) {\r\n    const filterFn = filterFunctionOrFunctionOrFunctionArray as FilterFn<TValue>;\r\n    const updateFnArr = Array.isArray(updateFnOrUpdateFnArr) ? updateFnOrUpdateFnArr : [updateFnOrUpdateFnArr!];\r\n    return updateFnArr.concat(...rest).reduce((s, updateFn) => updateArraySingle<TValue>(filterFn, updateFn)(s), stateOrFilterFunction);\r\n  }\r\n\r\n  let updateFnArr = Array.isArray(filterFunctionOrFunctionOrFunctionArray)\r\n    ? filterFunctionOrFunctionOrFunctionArray\r\n    : [filterFunctionOrFunctionOrFunctionArray as ProjectFn2<FormState<TValue>, FormArrayState<TValue>>];\r\n  updateFnArr = updateFnOrUpdateFnArr === undefined ? updateFnArr : updateFnArr.concat(updateFnOrUpdateFnArr);\r\n  return (s: FormArrayState<TValue>) => updateArrayWithFilter<TValue>(ensureState(s), stateOrFilterFunction, updateFnArr.concat(rest));\r\n}\r\n\r\n/**\r\n * This update function takes one or more update functions and returns a\r\n * projection function that applies all update functions one after another to\r\n * each element of the form array state.\r\n *\r\n * The following (contrived) example uses this function to validate all its\r\n * children to be required and mark them as dirty.\r\n *\r\n```typescript\r\nconst arrayUpdateFn = updateArray<string>(\r\n  validate<string>(required),\r\n  markAsDirty,\r\n);\r\nconst updatedState = arrayUpdateFn(state);\r\n```\r\n */\r\nexport function updateArray<TValue>(\r\n  updateFn: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>,\r\n  ...updateFnArr: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>[]\r\n): (state: FormArrayState<TValue>) => FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes an array of update functions and returns\r\n * a projection function that applies all update functions one after another to\r\n * each element of the form array state.\r\n *\r\n * The following (contrived) example uses this function to validate all its\r\n * children to be required and mark them as dirty.\r\n *\r\n```typescript\r\nconst arrayUpdateFn = updateArray<string>([\r\n  validate<string>(required),\r\n  markAsDirty,\r\n]);\r\nconst updatedState = arrayUpdateFn(state);\r\n```\r\n */\r\nexport function updateArray<TValue>(\r\n  updateFnArr: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>[],\r\n): (state: FormArrayState<TValue>) => FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes a form array state and one or more update functions\r\n * and applies all update functions one after another to each element of the form\r\n * array state.\r\n *\r\n * The following (contrived) example uses this function to validate all its\r\n * children to be required and mark them as dirty.\r\n *\r\n```typescript\r\nconst updatedState = updateArray<string>(\r\n  state,\r\n  validate<string>(required),\r\n  markAsDirty,\r\n);\r\n```\r\n */\r\nexport function updateArray<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  updateFn: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>,\r\n  ...updateFnArr: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>[]\r\n): FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes a form array state and an array of update\r\n * functions and applies all update functions one after another to each element\r\n * of the form array state.\r\n *\r\n * The following (contrived) example uses this function to validate all its\r\n * children to be required and mark them as dirty.\r\n *\r\n```typescript\r\nconst updatedState = updateArray<string>(\r\n  state,\r\n  [\r\n    validate<string>(required),\r\n    markAsDirty,\r\n  ],\r\n);\r\n```\r\n */\r\nexport function updateArray<TValue>(\r\n  state: FormArrayState<TValue>,\r\n  updateFnArr: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>[],\r\n): FormArrayState<TValue>;\r\n\r\nexport function updateArray<TValue>(\r\n  stateOrFunctionOrFunctionArray:\r\n    | FormArrayState<TValue>\r\n    | ProjectFn2<FormState<TValue>, FormArrayState<TValue>>\r\n    | ProjectFn2<FormState<TValue>, FormArrayState<TValue>>[],\r\n  updateFnOrUpdateFnArr?: ProjectFn2<FormState<TValue>, FormArrayState<TValue>> | ProjectFn2<FormState<TValue>, FormArrayState<TValue>>[],\r\n  ...rest: ProjectFn2<FormState<TValue>, FormArrayState<TValue>>[]\r\n) {\r\n  if (isArrayState<TValue>(stateOrFunctionOrFunctionArray)) {\r\n    const updateFnArr = Array.isArray(updateFnOrUpdateFnArr) ? updateFnOrUpdateFnArr : [updateFnOrUpdateFnArr!];\r\n    return updateFnArr.concat(...rest).reduce((s, updateFn) => updateArraySingle<TValue>(() => true, updateFn)(s), stateOrFunctionOrFunctionArray);\r\n  }\r\n\r\n  let updateFnArr = Array.isArray(stateOrFunctionOrFunctionArray) ? stateOrFunctionOrFunctionArray : [stateOrFunctionOrFunctionArray];\r\n  updateFnArr = updateFnOrUpdateFnArr === undefined ? updateFnArr : updateFnArr.concat(updateFnOrUpdateFnArr);\r\n  return (s: FormArrayState<TValue>) => updateArray<TValue>(ensureState(s), updateFnArr.concat(rest));\r\n}\r\n","import { computeGroupState, FormGroupControls, FormGroupState, FormState, isGroupState, KeyValue } from '../state';\r\nimport { ensureState, ProjectFn2 } from './util';\r\n\r\nexport type StateUpdateFns<TValue extends KeyValue> = {\r\n  [controlId in keyof TValue]?: ProjectFn2<FormState<TValue[controlId]>, FormGroupState<TValue>>;\r\n};\r\n\r\nfunction updateGroupControlsState<TValue extends KeyValue>(updateFns: StateUpdateFns<TValue>) {\r\n  return (state: FormGroupState<TValue>) => {\r\n    let hasChanged = false;\r\n    const newControls = Object.keys(state.controls).reduce((res, key) => {\r\n      const control = state.controls[key];\r\n      Object.assign(res, { [key]: control });\r\n      if (updateFns.hasOwnProperty(key)) {\r\n        const newControl = updateFns[key]!(control, state);\r\n        hasChanged = hasChanged || newControl !== control;\r\n        Object.assign(res, { [key]: newControl });\r\n      }\r\n      return res;\r\n    }, {} as FormGroupControls<TValue>);\r\n    return hasChanged ? newControls : state.controls;\r\n  };\r\n}\r\n\r\nfunction updateGroupSingle<TValue extends KeyValue>(updateFns: StateUpdateFns<TValue>) {\r\n  return (state: FormGroupState<TValue>): FormGroupState<TValue> => {\r\n    const newControls = updateGroupControlsState<TValue>(updateFns)(state);\r\n    return newControls !== state.controls\r\n      ? computeGroupState<TValue>(\r\n        state.id,\r\n        newControls,\r\n        state.value,\r\n        state.errors,\r\n        state.pendingValidations,\r\n        state.userDefinedProperties,\r\n        {\r\n          wasOrShouldBeDirty: state.isDirty,\r\n          wasOrShouldBeEnabled: state.isEnabled,\r\n          wasOrShouldBeTouched: state.isTouched,\r\n          wasOrShouldBeSubmitted: state.isSubmitted,\r\n        },\r\n      )\r\n      : state;\r\n  };\r\n}\r\n\r\n/**\r\n * This update function takes one or more update function objects and returns\r\n * a projection function that applies all objects one after another to a form\r\n * group state.\r\n *\r\n * The following (contrived) example uses this function to validate the child\r\n * control `name` to be required and set the child control `email`'s value to\r\n * be `''` if the name is invalid.\r\n *\r\n```typescript\r\ninterface FormValue {\r\n  name: string;\r\n  email: string;\r\n}\r\n\r\nconst groupUpdateFn = updateGroup<FormValue>(\r\n  {\r\n    name: validate<string>(required),\r\n  },\r\n  {\r\n    email: (email, parentGroup) =>\r\n      parentGroup.controls.name.isInvalid\r\n        ? setValue('', email)\r\n        : email,\r\n  },\r\n);\r\nconst updatedState = groupUpdateFn(state);\r\n```\r\n */\r\nexport function updateGroup<TValue>(\r\n  updateFn: StateUpdateFns<TValue>,\r\n  ...updateFnsArr: StateUpdateFns<TValue>[]\r\n): (state: FormGroupState<TValue>) => FormGroupState<TValue>;\r\n\r\n/**\r\n * This update function takes an array of update function objects and\r\n * returns a projection function that applies all objects one after another to\r\n * a form group state.\r\n *\r\n * The following (contrived) example uses this function to validate the child\r\n * control `name` to be required and set the child control `email`'s value to\r\n * be `''` if the name is invalid.\r\n *\r\n```typescript\r\ninterface FormValue {\r\n  name: string;\r\n  email: string;\r\n}\r\n\r\nconst groupUpdateFn = updateGroup<FormValue>(\r\n  [\r\n    {\r\n      name: validate<string>(required),\r\n    },\r\n    {\r\n      email: (email, parentGroup) =>\r\n        parentGroup.controls.name.isInvalid\r\n          ? setValue('', email)\r\n          : email,\r\n    },\r\n  ],\r\n);\r\nconst updatedState = groupUpdateFn(state);\r\n```\r\n */\r\nexport function updateGroup<TValue>(\r\n  updateFnsArr: StateUpdateFns<TValue>[],\r\n): (state: FormGroupState<TValue>) => FormGroupState<TValue>;\r\n\r\n/**\r\n * This update function takes a form group state and one or more update\r\n * function objects and applies all objects one after another to the state.\r\n * Providing multiple update function objects is mainly useful if the result\r\n * of a later object depends on the result of previous objects.\r\n *\r\n * The following (contrived) example uses this function to validate the child\r\n * control `name` to be required and set the child control `email`'s value to\r\n * be `''` if the name is invalid.\r\n *\r\n```typescript\r\ninterface FormValue {\r\n  name: string;\r\n  email: string;\r\n}\r\n\r\nconst updatedState = updateGroup<FormValue>(\r\n  state,\r\n  {\r\n    name: validate<string>(required),\r\n  },\r\n  {\r\n    email: (email, parentGroup) =>\r\n      parentGroup.controls.name.isInvalid\r\n        ? setValue('', email)\r\n        : email,\r\n  },\r\n);\r\n```\r\n */\r\nexport function updateGroup<TValue>(\r\n  state: FormGroupState<TValue>,\r\n  updateFn: StateUpdateFns<TValue>,\r\n  ...updateFnsArr: StateUpdateFns<TValue>[]\r\n): FormGroupState<TValue>;\r\n\r\n/**\r\n * This update function takes a form group state and an array of update\r\n * function objects and applies all objects one after another to the state.\r\n * Providing multiple update function objects is mainly useful if the result\r\n * of a later object depends on the result of previous objects.\r\n *\r\n * The following (contrived) example uses this function to validate the child\r\n * control `name` to be required and set the child control `email`'s value to\r\n * be `''` if the name is invalid.\r\n *\r\n```typescript\r\ninterface FormValue {\r\n  name: string;\r\n  email: string;\r\n}\r\n\r\nconst updatedState = updateGroup<FormValue>(\r\n  state,\r\n  [\r\n    {\r\n      name: validate<string>(required),\r\n    },\r\n    {\r\n      email: (email, parentGroup) =>\r\n        parentGroup.controls.name.isInvalid\r\n          ? setValue('', email)\r\n          : email,\r\n    },\r\n  ],\r\n);\r\n```\r\n */\r\nexport function updateGroup<TValue>(\r\n  state: FormGroupState<TValue>,\r\n  updateFnsArr: StateUpdateFns<TValue>[],\r\n): FormGroupState<TValue>;\r\n\r\nexport function updateGroup<TValue extends KeyValue>(\r\n  stateOrUpdateFnOrUpdateFnArray: FormGroupState<TValue> | StateUpdateFns<TValue> | StateUpdateFns<TValue>[],\r\n  updateFnOrUpdateFnArr?: StateUpdateFns<TValue> | StateUpdateFns<TValue>[],\r\n  ...rest: StateUpdateFns<TValue>[]\r\n) {\r\n  if (isGroupState<TValue>(stateOrUpdateFnOrUpdateFnArray)) {\r\n    const updateFnArr = Array.isArray(updateFnOrUpdateFnArr) ? updateFnOrUpdateFnArr : [updateFnOrUpdateFnArr!];\r\n    return updateFnArr.concat(...rest).reduce((s, updateFn) => updateGroupSingle<TValue>(updateFn)(s), stateOrUpdateFnOrUpdateFnArray);\r\n  }\r\n\r\n  let updateFnArr = Array.isArray(stateOrUpdateFnOrUpdateFnArray) ? stateOrUpdateFnOrUpdateFnArray : [stateOrUpdateFnOrUpdateFnArray];\r\n  updateFnArr = updateFnOrUpdateFnArr === undefined ? updateFnArr : updateFnArr.concat(updateFnOrUpdateFnArr);\r\n  return (s: FormGroupState<TValue>) => updateGroup<TValue>(ensureState(s), updateFnArr.concat(rest));\r\n}\r\n","import { InjectionToken } from '@angular/core';\r\n\r\nexport interface FormViewAdapter {\r\n  /**\r\n   * Sets a new value for the form element.\r\n   */\r\n  setViewValue(value: any): void;\r\n\r\n  /**\r\n   * Set the function to be called when the form element receives a change event.\r\n   */\r\n  setOnChangeCallback(fn: (value: any) => void): void;\r\n\r\n  /**\r\n   * Set the function to be called when the form element receives a touch event.\r\n   */\r\n  setOnTouchedCallback(fn: () => void): void;\r\n\r\n  /**\r\n   * Enable or disable the form element.\r\n   */\r\n  setIsDisabled?(isDisabled: boolean): void;\r\n}\r\n\r\n/**\r\n * Used to provide a {@link FormViewAdapter} for form elements.\r\n */\r\nexport const NGRX_FORM_VIEW_ADAPTER = new InjectionToken<FormViewAdapter>('NgrxFormViewAdapter');\r\n","import { AfterViewInit, Directive, ElementRef, forwardRef, HostListener, Input, Renderer2 } from '@angular/core';\r\n\r\nimport { FormControlState } from '../state';\r\nimport { FormViewAdapter, NGRX_FORM_VIEW_ADAPTER } from './view-adapter';\r\n\r\n// tslint:disable:directive-class-suffix\r\n\r\n@Directive({\r\n  // tslint:disable-next-line:directive-selector\r\n  selector: 'input[type=checkbox][ngrxFormControlState]',\r\n  providers: [{\r\n    provide: NGRX_FORM_VIEW_ADAPTER,\r\n    useExisting: forwardRef(() => NgrxCheckboxViewAdapter),\r\n    multi: true,\r\n  }],\r\n})\r\nexport class NgrxCheckboxViewAdapter implements FormViewAdapter, AfterViewInit {\r\n  private state: FormControlState<any>;\r\n  private nativeIdWasSet = false;\r\n\r\n  onChange: (value: any) => void = () => void 0;\r\n\r\n  @HostListener('blur')\r\n  onTouched: () => void = () => void 0\r\n\r\n  @Input() set ngrxFormControlState(value: FormControlState<any>) {\r\n    if (!value) {\r\n      throw new Error('The control state must not be undefined!');\r\n    }\r\n\r\n    this.state = value;\r\n    const nativeId = this.elementRef.nativeElement.id;\r\n    const shouldSetNativeId = value.id !== nativeId && this.nativeIdWasSet;\r\n    if (shouldSetNativeId) {\r\n      this.renderer.setProperty(this.elementRef.nativeElement, 'id', value.id);\r\n    }\r\n  }\r\n\r\n  constructor(private renderer: Renderer2, private elementRef: ElementRef) { }\r\n\r\n  ngAfterViewInit() {\r\n    const nativeId = this.elementRef.nativeElement.id;\r\n    const shouldSetNativeId = this.state.id !== nativeId && !nativeId;\r\n    if (shouldSetNativeId) {\r\n      this.renderer.setProperty(this.elementRef.nativeElement, 'id', this.state.id);\r\n      this.nativeIdWasSet = true;\r\n    }\r\n  }\r\n\r\n  setViewValue(value: any): void {\r\n    this.renderer.setProperty(this.elementRef.nativeElement, 'checked', value);\r\n  }\r\n\r\n  setOnChangeCallback(fn: (value: any) => void): void {\r\n    this.onChange = fn;\r\n  }\r\n\r\n  setOnTouchedCallback(fn: () => void): void {\r\n    this.onTouched = fn;\r\n  }\r\n\r\n  setIsDisabled(isDisabled: boolean): void {\r\n    this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);\r\n  }\r\n\r\n  @HostListener('change', ['$event'])\r\n  handleInput({ target }: { target: HTMLInputElement }): void {\r\n    this.onChange(target.checked);\r\n  }\r\n}\r\n","import { isPlatformBrowser } from '@angular/common';\r\nimport { AfterViewInit, Directive, ElementRef, forwardRef, HostListener, Inject, Input, Optional, PLATFORM_ID, Renderer2 } from '@angular/core';\r\n\r\nimport { FormControlState } from '../state';\r\nimport { FormViewAdapter, NGRX_FORM_VIEW_ADAPTER } from './view-adapter';\r\n\r\nexport interface Navigator {\r\n  userAgent: string;\r\n}\r\n\r\n/**\r\n * We must check whether the agent is Android because composition events\r\n * behave differently between iOS and Android.\r\n */\r\nfunction isAndroid(navigator: Navigator): boolean {\r\n  return /android (\\d+)/.test(navigator.userAgent.toLowerCase());\r\n}\r\n\r\n// tslint:disable:directive-class-suffix\r\n// tslint:disable:directive-selector\r\n\r\n// TODO: since this directive has a side-effect (setting the element's id attribute)\r\n// it should not blacklist other types of inputs but instead it should somehow figure\r\n// out whether it is the \"active\" view adapter and only perform its side effects if it\r\n// is active\r\n@Directive({\r\n  selector: 'input:not([type=checkbox]):not([type=number]):not([type=radio]):not([type=range])[ngrxFormControlState],textarea[ngrxFormControlState]',\r\n  providers: [{\r\n    provide: NGRX_FORM_VIEW_ADAPTER,\r\n    useExisting: forwardRef(() => NgrxDefaultViewAdapter),\r\n    multi: true,\r\n  }],\r\n})\r\nexport class NgrxDefaultViewAdapter implements FormViewAdapter, AfterViewInit {\r\n  private state: FormControlState<any>;\r\n  private nativeIdWasSet = false;\r\n\r\n  onChange: (value: any) => void = () => void 0;\r\n\r\n  @HostListener('blur')\r\n  onTouched: () => void = () => void 0\r\n\r\n  @Input() set ngrxFormControlState(value: FormControlState<any>) {\r\n    if (!value) {\r\n      throw new Error('The control state must not be undefined!');\r\n    }\r\n\r\n    this.state = value;\r\n    const nativeId = this.elementRef.nativeElement.id;\r\n    const shouldSetNativeId = value.id !== nativeId && this.nativeIdWasSet;\r\n    if (shouldSetNativeId) {\r\n      this.renderer.setProperty(this.elementRef.nativeElement, 'id', value.id);\r\n    }\r\n  }\r\n\r\n  /** Whether the user is creating a composition string (IME events). */\r\n  private isComposing = false;\r\n  private isCompositionSupported: boolean;\r\n\r\n  constructor(\r\n    private renderer: Renderer2,\r\n    private elementRef: ElementRef,\r\n    @Optional() @Inject(PLATFORM_ID) private platformId: string | null = null,\r\n    // we use a special injection string that should never exist at runtime to allow mocking this dependency for testing\r\n    @Optional() @Inject('ngrx-forms/never') navigator: Navigator | null = null,\r\n  ) {\r\n    this.isCompositionSupported = isPlatformBrowser(this.platformId || '') && !isAndroid(navigator || window.navigator);\r\n  }\r\n\r\n  ngAfterViewInit() {\r\n    const nativeId = this.elementRef.nativeElement.id;\r\n    const shouldSetNativeId = this.state.id !== nativeId && !nativeId;\r\n    if (shouldSetNativeId) {\r\n      this.renderer.setProperty(this.elementRef.nativeElement, 'id', this.state.id);\r\n      this.nativeIdWasSet = true;\r\n    }\r\n  }\r\n\r\n  setViewValue(value: any): void {\r\n    const normalizedValue = value == null ? '' : value;\r\n    this.renderer.setProperty(this.elementRef.nativeElement, 'value', normalizedValue);\r\n  }\r\n\r\n  setOnChangeCallback(fn: (value: any) => void): void {\r\n    this.onChange = fn;\r\n  }\r\n\r\n  setOnTouchedCallback(fn: () => void): void {\r\n    this.onTouched = fn;\r\n  }\r\n\r\n  setIsDisabled(isDisabled: boolean): void {\r\n    this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);\r\n  }\r\n\r\n  @HostListener('input', ['$event'])\r\n  handleInput({ target }: { target: HTMLInputElement }): void {\r\n    if (this.isCompositionSupported && this.isComposing) {\r\n      return;\r\n    }\r\n\r\n    this.onChange(target.value);\r\n  }\r\n\r\n  @HostListener('compositionstart')\r\n  compositionStart(): void {\r\n    this.isComposing = true;\r\n  }\r\n\r\n  @HostListener('compositionend', ['$event'])\r\n  compositionEnd({ target }: { target: HTMLInputElement }): void {\r\n    this.isComposing = false;\r\n    if (this.isCompositionSupported) {\r\n      this.onChange(target.value);\r\n    }\r\n  }\r\n}\r\n","import { AfterViewInit, Directive, ElementRef, forwardRef, HostListener, Input, Renderer2 } from '@angular/core';\r\n\r\nimport { FormControlState } from '../state';\r\nimport { FormViewAdapter, NGRX_FORM_VIEW_ADAPTER } from './view-adapter';\r\n\r\n// tslint:disable:directive-class-suffix\r\n\r\n@Directive({\r\n  // tslint:disable-next-line:directive-selector\r\n  selector: 'input[type=number][ngrxFormControlState]',\r\n  providers: [{\r\n    provide: NGRX_FORM_VIEW_ADAPTER,\r\n    useExisting: forwardRef(() => NgrxNumberViewAdapter),\r\n    multi: true,\r\n  }],\r\n})\r\nexport class NgrxNumberViewAdapter implements FormViewAdapter, AfterViewInit {\r\n  private state: FormControlState<any>;\r\n  private nativeIdWasSet = false;\r\n\r\n  onChange: (value: any) => void = () => void 0;\r\n\r\n  @HostListener('blur')\r\n  onTouched: () => void = () => void 0\r\n\r\n  @Input() set ngrxFormControlState(value: FormControlState<any>) {\r\n    if (!value) {\r\n      throw new Error('The control state must not be undefined!');\r\n    }\r\n\r\n    this.state = value;\r\n    const nativeId = this.elementRef.nativeElement.id;\r\n    const shouldSetNativeId = value.id !== nativeId && this.nativeIdWasSet;\r\n    if (shouldSetNativeId) {\r\n      this.renderer.setProperty(this.elementRef.nativeElement, 'id', value.id);\r\n    }\r\n  }\r\n\r\n  constructor(private renderer: Renderer2, private elementRef: ElementRef) { }\r\n\r\n  ngAfterViewInit() {\r\n    const nativeId = this.elementRef.nativeElement.id;\r\n    const shouldSetNativeId = this.state.id !== nativeId && !nativeId;\r\n    if (shouldSetNativeId) {\r\n      this.renderer.setProperty(this.elementRef.nativeElement, 'id', this.state.id);\r\n      this.nativeIdWasSet = true;\r\n    }\r\n  }\r\n\r\n  setViewValue(value: any): void {\r\n    // The value needs to be normalized for IE9, otherwise it is set to 'null' when null\r\n    const normalizedValue = value === null ? '' : value;\r\n    this.renderer.setProperty(this.elementRef.nativeElement, 'value', normalizedValue);\r\n  }\r\n\r\n  setOnChangeCallback(fn: (value: any) => void): void {\r\n    this.onChange = fn;\r\n  }\r\n\r\n  setOnTouchedCallback(fn: () => void): void {\r\n    this.onTouched = fn;\r\n  }\r\n\r\n  setIsDisabled(isDisabled: boolean): void {\r\n    this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);\r\n  }\r\n\r\n  @HostListener('change', ['$event'])\r\n  @HostListener('input', ['$event'])\r\n  handleInput({ target }: { target: HTMLInputElement }): void {\r\n    const value = target.value;\r\n    this.onChange(value === '' ? null : parseFloat(value));\r\n  }\r\n}\r\n","import {\r\n  AfterViewInit,\r\n  Directive,\r\n  ElementRef,\r\n  forwardRef,\r\n  Host,\r\n  HostListener,\r\n  Input,\r\n  OnDestroy,\r\n  Optional,\r\n  Renderer2,\r\n} from '@angular/core';\r\n\r\nimport { FormControlState } from '../state';\r\nimport { FormViewAdapter, NGRX_FORM_VIEW_ADAPTER } from './view-adapter';\r\n\r\n// tslint:disable:directive-class-suffix\r\n\r\n@Directive({\r\n  // tslint:disable-next-line:directive-selector\r\n  selector: 'select:not([multiple])[ngrxFormControlState]',\r\n  providers: [{\r\n    provide: NGRX_FORM_VIEW_ADAPTER,\r\n    useExisting: forwardRef(() => NgrxSelectViewAdapter),\r\n    multi: true,\r\n  }],\r\n})\r\nexport class NgrxSelectViewAdapter implements FormViewAdapter, AfterViewInit {\r\n  private state: FormControlState<any>;\r\n  private optionMap: { [id: string]: any } = {};\r\n  private idCounter = 0;\r\n  private selectedId: string | null = null;\r\n  private value: any = undefined;\r\n  private nativeIdWasSet = false;\r\n\r\n  onChangeFn: (value: any) => void = () => void 0;\r\n\r\n  @HostListener('blur')\r\n  onTouched: () => void = () => void 0\r\n\r\n  @Input() set ngrxFormControlState(value: FormControlState<any>) {\r\n    if (!value) {\r\n      throw new Error('The control state must not be undefined!');\r\n    }\r\n\r\n    this.state = value;\r\n    const nativeId = this.elementRef.nativeElement.id;\r\n    const shouldSetNativeId = value.id !== nativeId && this.nativeIdWasSet;\r\n    if (shouldSetNativeId) {\r\n      this.renderer.setProperty(this.elementRef.nativeElement, 'id', value.id);\r\n    }\r\n  }\r\n\r\n  constructor(private renderer: Renderer2, private elementRef: ElementRef) { }\r\n\r\n  ngAfterViewInit() {\r\n    const nativeId = this.elementRef.nativeElement.id;\r\n    const shouldSetNativeId = this.state.id !== nativeId && !nativeId;\r\n    if (shouldSetNativeId) {\r\n      this.renderer.setProperty(this.elementRef.nativeElement, 'id', this.state.id);\r\n      this.nativeIdWasSet = true;\r\n    }\r\n  }\r\n\r\n  setViewValue(value: any) {\r\n    this.value = value;\r\n    this.selectedId = this.getOptionId(value);\r\n    if (this.selectedId === null) {\r\n      this.renderer.setProperty(this.elementRef.nativeElement, 'selectedIndex', -1);\r\n    }\r\n\r\n    this.renderer.setProperty(this.elementRef.nativeElement, 'value', this.selectedId);\r\n  }\r\n\r\n  @HostListener('change', ['$event'])\r\n  onChange({ target }: { target: HTMLOptionElement }) {\r\n    this.selectedId = target.value;\r\n    const value = this.optionMap[this.selectedId];\r\n    this.value = value;\r\n    this.onChangeFn(value);\r\n  }\r\n\r\n  setOnChangeCallback(fn: (value: any) => void) {\r\n    this.onChangeFn = fn;\r\n  }\r\n\r\n  setOnTouchedCallback(fn: () => void) {\r\n    this.onTouched = fn;\r\n  }\r\n\r\n  setIsDisabled(isDisabled: boolean) {\r\n    this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);\r\n  }\r\n\r\n  createOptionId() {\r\n    const id = this.idCounter.toString();\r\n    this.idCounter += 1;\r\n    return id;\r\n  }\r\n\r\n  updateOptionValue(id: string, value: any) {\r\n    this.optionMap[id] = value;\r\n\r\n    if (this.selectedId === id) {\r\n      this.onChangeFn(value);\r\n    } else if (value === this.value) {\r\n      this.setViewValue(value);\r\n    }\r\n  }\r\n\r\n  deregisterOption(id: string) {\r\n    delete this.optionMap[id];\r\n  }\r\n\r\n  private getOptionId(value: any) {\r\n    for (const id of Array.from(Object.keys(this.optionMap))) {\r\n      if (this.optionMap[id] === value) {\r\n        return id;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nconst NULL_VIEW_ADAPTER: NgrxSelectViewAdapter = {\r\n  createOptionId: () => '',\r\n  deregisterOption: () => void 0,\r\n  updateOptionValue: () => void 0,\r\n} as any;\r\n\r\nconst NULL_RENDERER: Renderer2 = {\r\n  setProperty: () => void 0,\r\n} as any;\r\n\r\n@Directive({\r\n  // tslint:disable-next-line:directive-selector\r\n  selector: 'option',\r\n})\r\nexport class NgrxSelectOption implements OnDestroy {\r\n  private isInitialized = false;\r\n  id: string;\r\n\r\n  constructor(\r\n    private element: ElementRef,\r\n    private renderer: Renderer2,\r\n    @Host() @Optional() private viewAdapter: NgrxSelectViewAdapter,\r\n  ) {\r\n    this.renderer = viewAdapter ? renderer : NULL_RENDERER;\r\n    this.viewAdapter = viewAdapter || NULL_VIEW_ADAPTER;\r\n    this.id = this.viewAdapter.createOptionId();\r\n  }\r\n\r\n  @Input('value')\r\n  set value(value: any) {\r\n    // this cannot be done inside ngOnInit since the value property\r\n    // must be already set when the option value is updated in the view\r\n    // adapter and the initial binding of 'value' happens before\r\n    // ngOnInit runs\r\n    if (!this.isInitialized) {\r\n      this.isInitialized = true;\r\n      this.renderer.setProperty(this.element.nativeElement, 'value', this.id);\r\n    }\r\n\r\n    this.viewAdapter.updateOptionValue(this.id, value);\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.viewAdapter.deregisterOption(this.id);\r\n  }\r\n}\r\n","import {\r\n  AfterViewInit,\r\n  Directive,\r\n  ElementRef,\r\n  forwardRef,\r\n  Host,\r\n  HostListener,\r\n  Input,\r\n  OnDestroy,\r\n  OnInit,\r\n  Optional,\r\n  Renderer2,\r\n} from '@angular/core';\r\n\r\nimport { FormControlState } from '../state';\r\nimport { FormViewAdapter, NGRX_FORM_VIEW_ADAPTER } from './view-adapter';\r\n\r\n// tslint:disable:directive-class-suffix\r\n\r\n@Directive({\r\n  // tslint:disable-next-line:directive-selector\r\n  selector: 'select[multiple][ngrxFormControlState]',\r\n  providers: [{\r\n    provide: NGRX_FORM_VIEW_ADAPTER,\r\n    useExisting: forwardRef(() => NgrxSelectMultipleViewAdapter),\r\n    multi: true,\r\n  }],\r\n})\r\nexport class NgrxSelectMultipleViewAdapter implements FormViewAdapter, AfterViewInit {\r\n  private state: FormControlState<any>;\r\n  private options: { [id: string]: NgrxSelectMultipleOption } = {};\r\n  private optionValues: { [id: string]: any } = {};\r\n  private idCounter = 0;\r\n  private selectedIds: string[] = [];\r\n  private nativeIdWasSet = false;\r\n\r\n  onChangeFn: (value: any) => void = () => void 0;\r\n\r\n  @HostListener('blur')\r\n  onTouched: () => void = () => void 0\r\n\r\n  @Input() set ngrxFormControlState(value: FormControlState<any>) {\r\n    if (!value) {\r\n      throw new Error('The control state must not be undefined!');\r\n    }\r\n\r\n    this.state = value;\r\n    const nativeId = this.elementRef.nativeElement.id;\r\n    const shouldSetNativeId = value.id !== nativeId && this.nativeIdWasSet;\r\n    if (shouldSetNativeId) {\r\n      this.renderer.setProperty(this.elementRef.nativeElement, 'id', value.id);\r\n    }\r\n  }\r\n\r\n  constructor(private renderer: Renderer2, private elementRef: ElementRef) { }\r\n\r\n  ngAfterViewInit() {\r\n    const nativeId = this.elementRef.nativeElement.id;\r\n    const shouldSetNativeId = this.state.id !== nativeId && !nativeId;\r\n    if (shouldSetNativeId) {\r\n      this.renderer.setProperty(this.elementRef.nativeElement, 'id', this.state.id);\r\n      this.nativeIdWasSet = true;\r\n    }\r\n  }\r\n\r\n  setViewValue(value: any) {\r\n    if (value === null) {\r\n      value = [];\r\n    }\r\n\r\n    if (!Array.isArray(value)) {\r\n      throw new Error(`the value provided to a NgrxSelectMultipleViewAdapter must be null or an array; got ${value} of type ${typeof value}`); // `\r\n    }\r\n\r\n    this.selectedIds = value.map(v => this.getOptionId(v)).filter(id => id !== null).map(id => id as string);\r\n    Object.keys(this.options).forEach(id => this.options[id].isSelected = this.selectedIds.indexOf(id) >= 0);\r\n  }\r\n\r\n  @HostListener('change')\r\n  onChange() {\r\n    this.selectedIds = Object.keys(this.options).filter(id => this.options[id].isSelected);\r\n    const value = this.selectedIds.map(id => this.optionValues[id]);\r\n    this.onChangeFn(value);\r\n  }\r\n\r\n  setOnChangeCallback(fn: (value: any) => void) {\r\n    this.onChangeFn = fn;\r\n  }\r\n\r\n  setOnTouchedCallback(fn: () => void) {\r\n    this.onTouched = fn;\r\n  }\r\n\r\n  setIsDisabled(isDisabled: boolean) {\r\n    this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);\r\n  }\r\n\r\n  registerOption(option: NgrxSelectMultipleOption) {\r\n    const id = this.idCounter.toString();\r\n    this.options[id] = option;\r\n    this.idCounter += 1;\r\n    return id;\r\n  }\r\n\r\n  updateOptionValue(id: string, value: any) {\r\n    this.optionValues[id] = value;\r\n\r\n    if (this.selectedIds.indexOf(id) >= 0) {\r\n      this.onChange();\r\n    }\r\n  }\r\n\r\n  deregisterOption(id: string) {\r\n    delete this.options[id];\r\n    delete this.optionValues[id];\r\n  }\r\n\r\n  private getOptionId(value: any) {\r\n    for (const id of Array.from(Object.keys(this.optionValues))) {\r\n      if (this.optionValues[id] === value) {\r\n        return id;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nconst NULL_VIEW_ADAPTER: NgrxSelectMultipleViewAdapter = {\r\n  registerOption: () => '',\r\n  deregisterOption: () => void 0,\r\n  updateOptionValue: () => void 0,\r\n} as any;\r\n\r\nconst NULL_RENDERER: Renderer2 = {\r\n  setProperty: () => void 0,\r\n} as any;\r\n\r\n@Directive({\r\n  // tslint:disable-next-line:directive-selector\r\n  selector: 'option',\r\n})\r\nexport class NgrxSelectMultipleOption implements OnInit, OnDestroy {\r\n  id: string;\r\n\r\n  constructor(\r\n    private element: ElementRef,\r\n    private renderer: Renderer2,\r\n    @Host() @Optional() private viewAdapter: NgrxSelectMultipleViewAdapter,\r\n  ) {\r\n    this.renderer = viewAdapter ? renderer : NULL_RENDERER;\r\n    this.viewAdapter = viewAdapter || NULL_VIEW_ADAPTER;\r\n    this.id = this.viewAdapter.registerOption(this);\r\n  }\r\n\r\n  @Input('value')\r\n  set value(value: any) {\r\n    this.viewAdapter.updateOptionValue(this.id, value);\r\n  }\r\n\r\n  set isSelected(selected: boolean) {\r\n    this.renderer.setProperty(this.element.nativeElement, 'selected', selected);\r\n  }\r\n\r\n  get isSelected() {\r\n    return (this.element.nativeElement as HTMLOptionElement).selected;\r\n  }\r\n\r\n  ngOnInit() {\r\n    this.renderer.setProperty(this.element.nativeElement, 'value', this.id);\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.viewAdapter.deregisterOption(this.id);\r\n  }\r\n}\r\n","import {\r\n  Directive,\r\n  ElementRef,\r\n  Host,\r\n  Input,\r\n  Optional,\r\n  Renderer2,\r\n} from '@angular/core';\r\n\r\nimport { NgrxSelectViewAdapter } from './select';\r\nimport { NgrxSelectMultipleViewAdapter } from './select-multiple';\r\n\r\n// tslint:disable:directive-class-suffix\r\n\r\nconst NULL_RENDERER: Renderer2 = {\r\n  setProperty: () => void 0,\r\n} as any;\r\n\r\n/**\r\n * This directive is necessary to restore the default behaviour of Angular\r\n * when an `option` is used without an **ngrx-forms** form state. Since it\r\n * is not possible to select an element with a selector that considers its\r\n * parent the `option` directives for `select` and `select[multiple]` will\r\n * always be applied and therefore overriding the `[value]` binding which\r\n * disabled Angular's normal behaviour. This directive restores this\r\n * behaviour if no `select` or `select[multiple]` view adapter is found.\r\n * This is not a perfect solution since it may interfere with other\r\n * directives that try to set the `[value]` but that is very unlikely.\r\n */\r\n@Directive({\r\n  // tslint:disable-next-line:directive-selector\r\n  selector: 'option',\r\n})\r\nexport class NgrxFallbackSelectOption {\r\n  constructor(\r\n    private element: ElementRef,\r\n    private renderer: Renderer2,\r\n    @Host() @Optional() viewAdapter: NgrxSelectViewAdapter,\r\n    @Host() @Optional() multipleViewAdapter: NgrxSelectMultipleViewAdapter,\r\n  ) {\r\n    this.renderer = viewAdapter || multipleViewAdapter ? NULL_RENDERER : renderer;\r\n  }\r\n\r\n  @Input('value')\r\n  set value(value: any) {\r\n    this.renderer.setProperty(this.element.nativeElement, 'value', value);\r\n  }\r\n}\r\n","import { AfterViewInit, Directive, ElementRef, forwardRef, HostListener, Input, OnInit, Renderer2 } from '@angular/core';\r\n\r\nimport { FormControlState } from '../state';\r\nimport { FormViewAdapter, NGRX_FORM_VIEW_ADAPTER } from './view-adapter';\r\n\r\n// tslint:disable:directive-class-suffix\r\n\r\n@Directive({\r\n  // tslint:disable-next-line:directive-selector\r\n  selector: 'input[type=radio][ngrxFormControlState]',\r\n  providers: [{\r\n    provide: NGRX_FORM_VIEW_ADAPTER,\r\n    useExisting: forwardRef(() => NgrxRadioViewAdapter),\r\n    multi: true,\r\n  }],\r\n})\r\nexport class NgrxRadioViewAdapter implements FormViewAdapter, OnInit, AfterViewInit {\r\n  private state: FormControlState<any>;\r\n  private nativeNameWasSet = false;\r\n\r\n  @Input() set value(val: any) {\r\n    if (val !== this.latestValue) {\r\n      this.latestValue = val;\r\n      if (this.isChecked) {\r\n        this.onChange();\r\n      }\r\n    }\r\n  }\r\n\r\n  @Input() set ngrxFormControlState(value: FormControlState<any>) {\r\n    if (!value) {\r\n      throw new Error('The control state must not be undefined!');\r\n    }\r\n\r\n    this.state = value;\r\n    const nativeName = this.elementRef.nativeElement.name;\r\n    const shouldSetNativeName = value.id !== nativeName && this.nativeNameWasSet;\r\n    if (shouldSetNativeName) {\r\n      this.renderer.setProperty(this.elementRef.nativeElement, 'name', value.id);\r\n    }\r\n  }\r\n\r\n  private latestValue: any;\r\n  private isChecked: boolean;\r\n\r\n  @HostListener('change')\r\n  onChange: () => void = () => void 0\r\n\r\n  @HostListener('blur')\r\n  onTouched: () => void = () => void 0\r\n\r\n  constructor(\r\n    private renderer: Renderer2,\r\n    private elementRef: ElementRef,\r\n  ) { }\r\n\r\n  ngOnInit() {\r\n    this.isChecked = (this.elementRef.nativeElement as HTMLInputElement).checked;\r\n  }\r\n\r\n  ngAfterViewInit() {\r\n    const nativeName = this.elementRef.nativeElement.name;\r\n    const shouldSetNativeName = this.state.id !== nativeName && !nativeName;\r\n    if (shouldSetNativeName) {\r\n      this.renderer.setProperty(this.elementRef.nativeElement, 'name', this.state.id);\r\n      this.nativeNameWasSet = true;\r\n    }\r\n  }\r\n\r\n  setViewValue(value: any): void {\r\n    this.isChecked = value === this.latestValue;\r\n    this.renderer.setProperty(this.elementRef.nativeElement, 'checked', this.isChecked);\r\n  }\r\n\r\n  setOnChangeCallback(fn: (_: any) => void): void {\r\n    this.onChange = () => fn(this.latestValue);\r\n  }\r\n\r\n  setOnTouchedCallback(fn: () => void): void {\r\n    this.onTouched = fn;\r\n  }\r\n\r\n  setIsDisabled(isDisabled: boolean): void {\r\n    this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);\r\n  }\r\n}\r\n","import { AfterViewInit, Directive, ElementRef, forwardRef, HostListener, Input, Renderer2 } from '@angular/core';\r\n\r\nimport { FormControlState } from '../state';\r\nimport { FormViewAdapter, NGRX_FORM_VIEW_ADAPTER } from './view-adapter';\r\n\r\n// tslint:disable:directive-class-suffix\r\n\r\n@Directive({\r\n  // tslint:disable-next-line:directive-selector\r\n  selector: 'input[type=range][ngrxFormControlState]',\r\n  providers: [{\r\n    provide: NGRX_FORM_VIEW_ADAPTER,\r\n    useExisting: forwardRef(() => NgrxRangeViewAdapter),\r\n    multi: true,\r\n  }],\r\n})\r\nexport class NgrxRangeViewAdapter implements FormViewAdapter, AfterViewInit {\r\n  private state: FormControlState<any>;\r\n  private nativeIdWasSet = false;\r\n\r\n  onChange: (value: any) => void = () => void 0;\r\n\r\n  @HostListener('blur')\r\n  onTouched: () => void = () => void 0\r\n\r\n  @Input() set ngrxFormControlState(value: FormControlState<any>) {\r\n    if (!value) {\r\n      throw new Error('The control state must not be undefined!');\r\n    }\r\n\r\n    this.state = value;\r\n    const nativeId = this.elementRef.nativeElement.id;\r\n    const shouldSetNativeId = value.id !== nativeId && this.nativeIdWasSet;\r\n    if (shouldSetNativeId) {\r\n      this.renderer.setProperty(this.elementRef.nativeElement, 'id', value.id);\r\n    }\r\n  }\r\n\r\n  constructor(private renderer: Renderer2, private elementRef: ElementRef) { }\r\n\r\n  ngAfterViewInit() {\r\n    const nativeId = this.elementRef.nativeElement.id;\r\n    const shouldSetNativeId = this.state.id !== nativeId && !nativeId;\r\n    if (shouldSetNativeId) {\r\n      this.renderer.setProperty(this.elementRef.nativeElement, 'id', this.state.id);\r\n      this.nativeIdWasSet = true;\r\n    }\r\n  }\r\n\r\n  setViewValue(value: any): void {\r\n    this.renderer.setProperty(this.elementRef.nativeElement, 'value', parseFloat(value));\r\n  }\r\n\r\n  setOnChangeCallback(fn: (value: any) => void): void {\r\n    this.onChange = fn;\r\n  }\r\n\r\n  setOnTouchedCallback(fn: () => void): void {\r\n    this.onTouched = fn;\r\n  }\r\n\r\n  setIsDisabled(isDisabled: boolean): void {\r\n    this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);\r\n  }\r\n\r\n  @HostListener('change', ['$event'])\r\n  @HostListener('input', ['$event'])\r\n  handleInput({ target }: { target: HTMLInputElement }): void {\r\n    const value = target.value;\r\n    this.onChange(value === '' ? null : parseFloat(value));\r\n  }\r\n}\r\n","import { NgrxCheckboxViewAdapter } from './checkbox';\r\nimport { NgrxDefaultViewAdapter } from './default';\r\nimport { NgrxNumberViewAdapter } from './number';\r\nimport { NgrxRadioViewAdapter } from './radio';\r\nimport { NgrxRangeViewAdapter } from './range';\r\nimport { NgrxSelectViewAdapter } from './select';\r\nimport { NgrxSelectMultipleViewAdapter } from './select-multiple';\r\nimport { FormViewAdapter } from './view-adapter';\r\n\r\nconst BUILTIN_ADAPTERS = [\r\n  NgrxCheckboxViewAdapter,\r\n  NgrxRangeViewAdapter,\r\n  NgrxNumberViewAdapter,\r\n  NgrxSelectViewAdapter,\r\n  NgrxSelectMultipleViewAdapter,\r\n  NgrxRadioViewAdapter,\r\n];\r\n\r\nexport function isBuiltInViewAdapter(viewAdapter: FormViewAdapter): boolean {\r\n  return BUILTIN_ADAPTERS.some(a => viewAdapter.constructor === a);\r\n}\r\n\r\nexport function selectViewAdapter(viewAdapters: FormViewAdapter[]): FormViewAdapter {\r\n  if (!viewAdapters) {\r\n    throw new Error('No view adapter matches!');\r\n  }\r\n\r\n  let defaultAdapter: FormViewAdapter | undefined;\r\n  let builtinAdapter: FormViewAdapter | undefined;\r\n  let customAdapter: FormViewAdapter | undefined;\r\n  viewAdapters.forEach((v: FormViewAdapter) => {\r\n    if (v.constructor === NgrxDefaultViewAdapter) {\r\n      defaultAdapter = v;\r\n    } else if (isBuiltInViewAdapter(v)) {\r\n      if (builtinAdapter) {\r\n        throw new Error('More than one built-in view adapter matches!');\r\n      }\r\n\r\n      builtinAdapter = v;\r\n    } else {\r\n      if (customAdapter) {\r\n        throw new Error('More than one custom view adapter matches!');\r\n      }\r\n\r\n      customAdapter = v;\r\n    }\r\n  });\r\n\r\n  if (customAdapter) {\r\n    return customAdapter;\r\n  }\r\n\r\n  if (builtinAdapter) {\r\n    return builtinAdapter;\r\n  }\r\n\r\n  if (defaultAdapter) {\r\n    return defaultAdapter;\r\n  }\r\n\r\n  throw new Error('No valid view adapter!');\r\n}\r\n","import { DOCUMENT } from '@angular/common';\r\nimport {\r\n  AfterViewInit,\r\n  Directive,\r\n  ElementRef,\r\n  HostBinding,\r\n  HostListener,\r\n  Inject,\r\n  Input,\r\n  OnInit,\r\n  Optional,\r\n  Self,\r\n} from '@angular/core';\r\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\r\nimport { ActionsSubject } from '@ngrx/store';\r\n\r\nimport { Actions, FocusAction, MarkAsDirtyAction, MarkAsTouchedAction, SetValueAction, UnfocusAction } from '../actions';\r\nimport { FormControlState, FormControlValueTypes } from '../state';\r\nimport { selectViewAdapter } from '../view-adapter/util';\r\nimport { FormViewAdapter, NGRX_FORM_VIEW_ADAPTER } from '../view-adapter/view-adapter';\r\nimport { NgrxValueConverter, NgrxValueConverters } from './value-converter';\r\n\r\nexport interface Document {\r\n  activeElement: any;\r\n}\r\n\r\nexport enum NGRX_UPDATE_ON_TYPE {\r\n  CHANGE = 'change',\r\n  BLUR = 'blur',\r\n  NEVER = 'never',\r\n}\r\n\r\nclass ControlValueAccessorAdapter implements FormViewAdapter {\r\n  constructor(private valueAccessor: ControlValueAccessor) { }\r\n\r\n  setViewValue(value: any): void {\r\n    this.valueAccessor.writeValue(value);\r\n  }\r\n\r\n  setOnChangeCallback(fn: (value: any) => void): void {\r\n    this.valueAccessor.registerOnChange(fn);\r\n  }\r\n  setOnTouchedCallback(fn: () => void): void {\r\n    this.valueAccessor.registerOnTouched(fn);\r\n  }\r\n\r\n  setIsDisabled(isDisabled: boolean) {\r\n    if (this.valueAccessor.setDisabledState) {\r\n      this.valueAccessor.setDisabledState(isDisabled);\r\n    }\r\n  }\r\n}\r\n\r\n@Directive({\r\n  // tslint:disable-next-line:directive-selector\r\n  selector: ':not([ngrxFormsAction])[ngrxFormControlState]',\r\n})\r\nexport class NgrxFormControlDirective<TStateValue extends FormControlValueTypes, TViewValue = TStateValue> implements AfterViewInit, OnInit {\r\n  private isInitialized = false;\r\n  private focusTrackingIsEnabled = false;\r\n\r\n  @Input() set ngrxFormControlState(newState: FormControlState<TStateValue>) {\r\n    if (!newState) {\r\n      throw new Error('The control state must not be undefined!');\r\n    }\r\n\r\n    const oldState = this.state;\r\n    this.state = newState;\r\n\r\n    if (this.isInitialized) {\r\n      this.updateViewIfControlIdChanged(newState, oldState);\r\n      this.updateViewIfValueChanged(newState, oldState);\r\n      this.updateViewIfIsDisabledChanged(newState, oldState);\r\n      this.updateViewIfIsFocusedChanged(newState, oldState);\r\n    }\r\n  }\r\n\r\n  @Input() ngrxUpdateOn: NGRX_UPDATE_ON_TYPE = NGRX_UPDATE_ON_TYPE.CHANGE;\r\n  @Input() set ngrxEnableFocusTracking(value: boolean) {\r\n    if (value && !this.dom) {\r\n      throw new Error('focus tracking is only supported on the browser platform');\r\n    }\r\n\r\n    this.focusTrackingIsEnabled = value;\r\n  }\r\n\r\n  @Input() ngrxValueConverter: NgrxValueConverter<TViewValue, TStateValue> = NgrxValueConverters.default<any>();\r\n\r\n  // TODO: move this into a separate directive\r\n  // automatically apply the attribute that's used by the CDK to set initial focus\r\n  @HostBinding('attr.cdk-focus-region-start') get focusRegionStartAttr() {\r\n    return this.state && this.state.isFocused ? '' : null;\r\n  }\r\n\r\n  state: FormControlState<TStateValue>;\r\n\r\n  private viewAdapter: FormViewAdapter;\r\n\r\n  // we have to store the latest known state value since most input elements don't play nicely with\r\n  // setting the same value again (e.g. input elements move the cursor to the end of the input when\r\n  // a new value is set which means whenever the user types something the cursor is forced to the\r\n  // end of the input) which would for example happen every time a new value is pushed to the state\r\n  // since when the action to update the state is dispatched a new state will be received inside\r\n  // the directive, which in turn would trigger a view update; to prevent this behavior we compare\r\n  // the latest known state value with the value to be set and filter out those values that are equal\r\n  // to the latest known value\r\n  private viewValue: TViewValue;\r\n  private stateValue: TStateValue;\r\n\r\n  constructor(\r\n    private el: ElementRef,\r\n    // for the dom parameter the `null` type must be last to ensure that in the compiled output\r\n    // there is no reference to the Document type to support non-browser platforms\r\n    @Optional() @Inject(DOCUMENT) private dom: Document | null,\r\n    @Optional() @Inject(ActionsSubject) private actionsSubject: ActionsSubject | null,\r\n    @Self() @Optional() @Inject(NGRX_FORM_VIEW_ADAPTER) viewAdapters: FormViewAdapter[],\r\n    @Self() @Optional() @Inject(NG_VALUE_ACCESSOR) valueAccessors: ControlValueAccessor[],\r\n  ) {\r\n    viewAdapters = viewAdapters || [];\r\n    valueAccessors = valueAccessors || [];\r\n\r\n    if (valueAccessors.length > 1) {\r\n      throw new Error('More than one custom control value accessor matches!');\r\n    }\r\n\r\n    this.viewAdapter = valueAccessors.length > 0\r\n      ? new ControlValueAccessorAdapter(valueAccessors[0])\r\n      : selectViewAdapter(viewAdapters);\r\n  }\r\n\r\n  updateViewIfControlIdChanged(newState: FormControlState<TStateValue>, oldState: FormControlState<TStateValue> | undefined) {\r\n    if (oldState && newState.id === oldState.id) {\r\n      return;\r\n    }\r\n\r\n    this.stateValue = newState.value;\r\n    this.viewValue = this.ngrxValueConverter.convertStateToViewValue(this.stateValue);\r\n    this.viewAdapter.setViewValue(this.viewValue);\r\n    if (this.viewAdapter.setIsDisabled) {\r\n      this.viewAdapter.setIsDisabled(newState.isDisabled);\r\n    }\r\n  }\r\n\r\n  updateViewIfValueChanged(newState: FormControlState<TStateValue>, _: FormControlState<TStateValue> | undefined) {\r\n    if (newState.value === this.stateValue) {\r\n      return;\r\n    }\r\n\r\n    this.stateValue = newState.value;\r\n    this.viewValue = this.ngrxValueConverter.convertStateToViewValue(newState.value);\r\n    this.viewAdapter.setViewValue(this.viewValue);\r\n  }\r\n\r\n  updateViewIfIsDisabledChanged(newState: FormControlState<TStateValue>, oldState: FormControlState<TStateValue> | undefined) {\r\n    if (!this.viewAdapter.setIsDisabled) {\r\n      return;\r\n    }\r\n\r\n    if (oldState && newState.isDisabled === oldState.isDisabled) {\r\n      return;\r\n    }\r\n\r\n    this.viewAdapter.setIsDisabled(newState.isDisabled);\r\n  }\r\n\r\n  updateViewIfIsFocusedChanged(newState: FormControlState<TStateValue>, oldState: FormControlState<TStateValue> | undefined) {\r\n    if (!this.focusTrackingIsEnabled) {\r\n      return;\r\n    }\r\n\r\n    if (oldState && newState.isFocused === oldState.isFocused) {\r\n      return;\r\n    }\r\n\r\n    if (newState.isFocused) {\r\n      this.el.nativeElement.focus();\r\n    } else {\r\n      this.el.nativeElement.blur();\r\n    }\r\n  }\r\n\r\n  protected dispatchAction(action: Actions<TStateValue>) {\r\n    if (this.actionsSubject !== null) {\r\n      this.actionsSubject.next(action);\r\n    } else {\r\n      throw new Error('ActionsSubject must be present in order to dispatch actions!');\r\n    }\r\n  }\r\n\r\n  ngOnInit() {\r\n    if (!this.state) {\r\n      throw new Error('The form state must not be undefined!');\r\n    }\r\n\r\n    this.isInitialized = true;\r\n\r\n    this.updateViewIfControlIdChanged(this.state, undefined);\r\n    this.updateViewIfValueChanged(this.state, undefined);\r\n    this.updateViewIfIsDisabledChanged(this.state, undefined);\r\n    this.updateViewIfIsFocusedChanged(this.state, undefined);\r\n\r\n    const dispatchMarkAsDirtyAction = () => {\r\n      if (this.state.isPristine) {\r\n        this.dispatchAction(new MarkAsDirtyAction(this.state.id));\r\n      }\r\n    };\r\n\r\n    const dispatchSetValueAction = () => {\r\n      this.stateValue = this.ngrxValueConverter.convertViewToStateValue(this.viewValue);\r\n      if (this.stateValue !== this.state.value) {\r\n        this.dispatchAction(new SetValueAction(this.state.id, this.stateValue));\r\n\r\n        dispatchMarkAsDirtyAction();\r\n      }\r\n    };\r\n\r\n    this.viewAdapter.setOnChangeCallback((viewValue: TViewValue) => {\r\n      this.viewValue = viewValue;\r\n\r\n      if (this.ngrxUpdateOn === NGRX_UPDATE_ON_TYPE.CHANGE) {\r\n        dispatchSetValueAction();\r\n      }\r\n    });\r\n\r\n    this.viewAdapter.setOnTouchedCallback(() => {\r\n      if (!this.state.isTouched && this.ngrxUpdateOn !== NGRX_UPDATE_ON_TYPE.NEVER) {\r\n        this.dispatchAction(new MarkAsTouchedAction(this.state.id));\r\n      }\r\n\r\n      if (this.ngrxUpdateOn === NGRX_UPDATE_ON_TYPE.BLUR) {\r\n        dispatchSetValueAction();\r\n      }\r\n    });\r\n  }\r\n\r\n  ngAfterViewInit() {\r\n    // we need to update the view again after it was initialized since some\r\n    // controls depend on child elements for setting the value (e.g. selects)\r\n    this.viewAdapter.setViewValue(this.viewValue);\r\n    if (this.viewAdapter.setIsDisabled) {\r\n      this.viewAdapter.setIsDisabled(this.state.isDisabled);\r\n    }\r\n  }\r\n\r\n  @HostListener('focusin')\r\n  @HostListener('focusout')\r\n  onFocusChange() {\r\n    if (!this.focusTrackingIsEnabled) {\r\n      return;\r\n    }\r\n\r\n    const isControlFocused = this.el.nativeElement === this.dom!.activeElement;\r\n    if (isControlFocused !== this.state.isFocused) {\r\n      this.dispatchAction(isControlFocused ? new FocusAction(this.state.id) : new UnfocusAction(this.state.id));\r\n    }\r\n  }\r\n}\r\n","import { box, Boxed, unbox } from '../boxing';\r\n\r\nexport interface NgrxValueConverter<TView, TState> {\r\n  convertViewToStateValue(value: TView): TState;\r\n  convertStateToViewValue(value: TState): TView;\r\n}\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const NgrxValueConverters = {\r\n  default<T>() {\r\n    return {\r\n      convertViewToStateValue: value => typeof value === 'object' && value !== null ? box(value) : value,\r\n      convertStateToViewValue: unbox,\r\n    } as NgrxValueConverter<T, Boxed<T> | T>;\r\n  },\r\n  dateToISOString: {\r\n    convertViewToStateValue: date => date === null ? null : date.toISOString(),\r\n    convertStateToViewValue: s => s === null ? null : new Date(Date.parse(s)),\r\n  } as NgrxValueConverter<Date | null, string | null>,\r\n  objectToJSON: {\r\n    convertViewToStateValue: value => value === null ? null : JSON.stringify(value),\r\n    convertStateToViewValue: s => s === null ? null : JSON.parse(s),\r\n  } as NgrxValueConverter<{} | null, string | null>,\r\n};\r\n","import { DOCUMENT } from '@angular/common';\r\nimport {\r\n  Directive,\r\n  ElementRef,\r\n  EventEmitter,\r\n  Inject,\r\n  Optional,\r\n  Output,\r\n  Self,\r\n} from '@angular/core';\r\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\r\n\r\nimport { Actions } from '../actions';\r\nimport { FormControlValueTypes } from '../state';\r\nimport { FormViewAdapter, NGRX_FORM_VIEW_ADAPTER } from '../view-adapter/view-adapter';\r\nimport { Document, NgrxFormControlDirective } from './directive';\r\n\r\n@Directive({\r\n  // tslint:disable-next-line:directive-selector\r\n  selector: '[ngrxFormControlState][ngrxFormsAction]',\r\n})\r\nexport class NgrxLocalFormControlDirective<TStateValue extends FormControlValueTypes, TViewValue = TStateValue>\r\n  extends NgrxFormControlDirective<TStateValue, TViewValue> {\r\n\r\n  @Output() ngrxFormsAction = new EventEmitter<Actions<TStateValue>>();\r\n\r\n  constructor(\r\n    el: ElementRef,\r\n    @Optional() @Inject(DOCUMENT) dom: Document | null,\r\n    @Self() @Optional() @Inject(NGRX_FORM_VIEW_ADAPTER) viewAdapters: FormViewAdapter[],\r\n    @Self() @Optional() @Inject(NG_VALUE_ACCESSOR) valueAccessors: ControlValueAccessor[],\r\n  ) {\r\n    super(el, dom, null, viewAdapters, valueAccessors);\r\n  }\r\n\r\n  protected dispatchAction(action: Actions<TStateValue>) {\r\n    this.ngrxFormsAction.emit(action);\r\n  }\r\n}\r\n","import { Directive, HostListener, Inject, Input, OnInit, Optional } from '@angular/core';\r\nimport { ActionsSubject } from '@ngrx/store';\r\n\r\nimport { Actions, MarkAsSubmittedAction } from '../actions';\r\nimport { FormGroupState } from '../state';\r\n\r\n// this interface just exists to prevent a direct reference to\r\n// `Event` in our code, which otherwise causes issues in NativeScript\r\n// applications\r\ninterface CustomEvent extends Event { }\r\n\r\n@Directive({\r\n  // tslint:disable-next-line:directive-selector\r\n  selector: 'form:not([ngrxFormsAction])[ngrxFormState]',\r\n})\r\nexport class NgrxFormDirective<TValue extends { [key: string]: any }> implements OnInit {\r\n  // tslint:disable-next-line:no-input-rename\r\n  @Input('ngrxFormState') state: FormGroupState<TValue>;\r\n\r\n  constructor(\r\n    @Optional() @Inject(ActionsSubject) private actionsSubject: ActionsSubject | null\r\n  ) {\r\n    this.actionsSubject = actionsSubject;\r\n  }\r\n\r\n  protected dispatchAction(action: Actions<TValue>) {\r\n    if (this.actionsSubject !== null) {\r\n      this.actionsSubject.next(action);\r\n    } else {\r\n      throw new Error('ActionsSubject must be present in order to dispatch actions!');\r\n    }\r\n  }\r\n\r\n  ngOnInit() {\r\n    if (!this.state) {\r\n      throw new Error('The form state must not be undefined!');\r\n    }\r\n  }\r\n\r\n  @HostListener('submit', ['$event'])\r\n  onSubmit(event: CustomEvent) {\r\n    event.preventDefault();\r\n    if (this.state.isUnsubmitted) {\r\n      this.dispatchAction(new MarkAsSubmittedAction(this.state.id));\r\n    }\r\n  }\r\n}\r\n","import { Directive, EventEmitter, Output } from '@angular/core';\r\n\r\nimport { Actions } from '../actions';\r\nimport { NgrxFormDirective } from './directive';\r\n\r\n@Directive({\r\n  // tslint:disable-next-line:directive-selector\r\n  selector: 'form[ngrxFormState][ngrxFormsAction]',\r\n})\r\nexport class NgrxLocalFormDirective<TValue extends { [key: string]: any }>\r\n  extends NgrxFormDirective<TValue> {\r\n\r\n  @Output() ngrxFormsAction = new EventEmitter<Actions<TValue>>();\r\n\r\n  constructor() {\r\n    super(null);\r\n  }\r\n\r\n  protected dispatchAction(action: Actions<TValue>) {\r\n    this.ngrxFormsAction.emit(action);\r\n  }\r\n}\r\n","import { Directive, HostBinding, Input } from '@angular/core';\r\nimport { AbstractControlState } from './state';\r\n\r\n/**\r\n * Lists the available status class names based on the property\r\n * they are depending on.\r\n */\r\nexport const NGRX_STATUS_CLASS_NAMES = {\r\n  isValid: 'ngrx-forms-valid',\r\n  isInvalid: 'ngrx-forms-invalid',\r\n  isDirty: 'ngrx-forms-dirty',\r\n  isPristine: 'ngrx-forms-pristine',\r\n  isTouched: 'ngrx-forms-touched',\r\n  isUntouched: 'ngrx-forms-untouched',\r\n  isSubmitted: 'ngrx-forms-submitted',\r\n  isUnsubmitted: 'ngrx-forms-unsubmitted',\r\n  isValidationPending: 'ngrx-forms-validation-pending',\r\n};\r\n\r\n@Directive({\r\n  // tslint:disable-next-line:directive-selector\r\n  selector: 'form[ngrxFormState],[ngrxFormControlState]',\r\n})\r\nexport class NgrxStatusCssClassesDirective {\r\n  private state: AbstractControlState<any>;\r\n\r\n  @Input()\r\n  set ngrxFormControlState(state: AbstractControlState<any>) {\r\n    this.state = state;\r\n  }\r\n\r\n  @Input()\r\n  set ngrxFormState(state: AbstractControlState<any>) {\r\n    this.state = state;\r\n  }\r\n\r\n  @HostBinding(`class.${NGRX_STATUS_CLASS_NAMES.isValid}`)\r\n  get isValid() {\r\n    return this.state.isValid;\r\n  }\r\n\r\n  @HostBinding(`class.${NGRX_STATUS_CLASS_NAMES.isInvalid}`)\r\n  get isInvalid() {\r\n    return this.state.isInvalid;\r\n  }\r\n\r\n  @HostBinding(`class.${NGRX_STATUS_CLASS_NAMES.isDirty}`)\r\n  get isDirty() {\r\n    return this.state.isDirty;\r\n  }\r\n\r\n  @HostBinding(`class.${NGRX_STATUS_CLASS_NAMES.isPristine}`)\r\n  get isPristine() {\r\n    return this.state.isPristine;\r\n  }\r\n\r\n  @HostBinding(`class.${NGRX_STATUS_CLASS_NAMES.isTouched}`)\r\n  get isTouched() {\r\n    return this.state.isTouched;\r\n  }\r\n\r\n  @HostBinding(`class.${NGRX_STATUS_CLASS_NAMES.isUntouched}`)\r\n  get isUntouched() {\r\n    return this.state.isUntouched;\r\n  }\r\n\r\n  @HostBinding(`class.${NGRX_STATUS_CLASS_NAMES.isSubmitted}`)\r\n  get isSubmitted() {\r\n    return this.state.isSubmitted;\r\n  }\r\n\r\n  @HostBinding(`class.${NGRX_STATUS_CLASS_NAMES.isUnsubmitted}`)\r\n  get isUnsubmitted() {\r\n    return this.state.isUnsubmitted;\r\n  }\r\n\r\n  @HostBinding(`class.${NGRX_STATUS_CLASS_NAMES.isValidationPending}`)\r\n  get isValidationPending() {\r\n    return this.state.isValidationPending;\r\n  }\r\n}\r\n","import { NgModule } from '@angular/core';\r\n\r\nimport { NgrxFormControlDirective } from './control/directive';\r\nimport { NgrxLocalFormControlDirective } from './control/local-state-directive';\r\nimport { NgrxFormDirective } from './group/directive';\r\nimport { NgrxLocalFormDirective } from './group/local-state-directive';\r\nimport { NgrxStatusCssClassesDirective } from './status-css-classes.directive';\r\nimport { NgrxCheckboxViewAdapter } from './view-adapter/checkbox';\r\nimport { NgrxDefaultViewAdapter } from './view-adapter/default';\r\nimport { NgrxNumberViewAdapter } from './view-adapter/number';\r\nimport { NgrxFallbackSelectOption } from './view-adapter/option';\r\nimport { NgrxRadioViewAdapter } from './view-adapter/radio';\r\nimport { NgrxRangeViewAdapter } from './view-adapter/range';\r\nimport { NgrxSelectOption, NgrxSelectViewAdapter } from './view-adapter/select';\r\nimport { NgrxSelectMultipleOption, NgrxSelectMultipleViewAdapter } from './view-adapter/select-multiple';\r\n\r\nconst exportsAndDeclarations = [\r\n  NgrxFormControlDirective,\r\n  NgrxLocalFormControlDirective,\r\n  NgrxFormDirective,\r\n  NgrxLocalFormDirective,\r\n  NgrxCheckboxViewAdapter,\r\n  NgrxDefaultViewAdapter,\r\n  NgrxNumberViewAdapter,\r\n  NgrxRadioViewAdapter,\r\n  NgrxRangeViewAdapter,\r\n  NgrxSelectMultipleOption,\r\n  NgrxSelectMultipleViewAdapter,\r\n  NgrxSelectOption,\r\n  NgrxSelectViewAdapter,\r\n  NgrxFallbackSelectOption,\r\n  NgrxStatusCssClassesDirective,\r\n];\r\n\r\n@NgModule({\r\n  declarations: exportsAndDeclarations,\r\n  exports: exportsAndDeclarations,\r\n})\r\nexport class NgrxFormsModule { }\r\n","import { AddArrayControlAction } from '../actions';\r\nimport { formArrayReducer } from '../array/reducer';\r\nimport { FormArrayState, isArrayState } from '../state';\r\nimport { ensureState } from './util';\r\n\r\n/**\r\n * This update function takes a value and optionally an index and returns a projection function\r\n * that adds a child control at the given index or at the end of a form array state.\r\n */\r\nexport function addArrayControl<TValue>(value: TValue, index?: number): (state: FormArrayState<TValue>) => FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes an array form state, a value, and optionally an index and adds a\r\n * child control at the given index or at the end of the state.\r\n */\r\nexport function addArrayControl<TValue>(state: FormArrayState<TValue>, value: TValue, index?: number): FormArrayState<TValue>;\r\n\r\nexport function addArrayControl<TValue>(valueOrState: TValue | FormArrayState<TValue>, indexOrValue: number | TValue | undefined, index?: number) {\r\n  if (isArrayState(valueOrState)) {\r\n    return formArrayReducer(valueOrState, new AddArrayControlAction(valueOrState.id, indexOrValue as TValue, index));\r\n  }\r\n\r\n  return (s: FormArrayState<TValue>) => addArrayControl(ensureState(s), valueOrState as TValue, indexOrValue as number);\r\n}\r\n","import { AddGroupControlAction } from '../actions';\r\nimport { formGroupReducer } from '../group/reducer';\r\nimport { FormGroupState, isGroupState, KeyValue } from '../state';\r\nimport { ensureState } from './util';\r\n\r\n/**\r\n * This update function takes a name and a value and returns a projection function\r\n * that adds a child control with the given name and value to a form group state.\r\n */\r\nexport function addGroupControl<TValue extends KeyValue, TControlKey extends keyof TValue = keyof TValue>(\r\n  name: TControlKey,\r\n  value: TValue[TControlKey],\r\n): (state: FormGroupState<TValue>) => FormGroupState<TValue>;\r\n\r\n/**\r\n * This update function takes a form group state, a name, and a value, and adds a child\r\n * control with the given name and value to the form group state.\r\n */\r\nexport function addGroupControl<TValue extends KeyValue, TControlKey extends keyof TValue = keyof TValue>(\r\n  state: FormGroupState<TValue>,\r\n  name: TControlKey,\r\n  value: TValue[TControlKey],\r\n): FormGroupState<TValue>;\r\n\r\nexport function addGroupControl<TValue extends KeyValue, TControlKey extends keyof TValue = keyof TValue>(\r\n  nameOrState: TControlKey | FormGroupState<TValue>,\r\n  valueOrName: TValue[TControlKey] | TControlKey,\r\n  value?: TValue[TControlKey],\r\n) {\r\n  if (isGroupState(nameOrState)) {\r\n    return formGroupReducer(nameOrState, new AddGroupControlAction<TValue, TControlKey>(nameOrState.id, valueOrName as TControlKey, value!));\r\n  }\r\n\r\n  return (s: FormGroupState<TValue>) => addGroupControl(ensureState(s), nameOrState as TControlKey, valueOrName as TValue[TControlKey]);\r\n}\r\n","import { ClearAsyncErrorAction } from '../actions';\r\nimport { AbstractControlState, FormState, isFormState } from '../state';\r\nimport { abstractControlReducer, ensureState } from './util';\r\n\r\n/**\r\n * This update function takes a name and returns a projection function that\r\n * clears the async error with the given name.\r\n */\r\nexport function clearAsyncError(name: string): <TValue>(state: AbstractControlState<TValue>) => FormState<TValue>;\r\n\r\n/**\r\n * This update function takes a form state and a name, and clears the async\r\n * error with the given name.\r\n */\r\nexport function clearAsyncError<TValue>(state: AbstractControlState<TValue>, name: string): FormState<TValue>;\r\n\r\nexport function clearAsyncError<TValue>(nameOrState: string | AbstractControlState<TValue>, name?: string) {\r\n  if (isFormState(nameOrState)) {\r\n    return abstractControlReducer(nameOrState, new ClearAsyncErrorAction(nameOrState.id, name!));\r\n  }\r\n\r\n  return (s: AbstractControlState<TValue>) => clearAsyncError(ensureState(s), nameOrState);\r\n}\r\n","import { DisableAction } from '../actions';\r\nimport { AbstractControlState, FormArrayState, FormControlState, FormControlValueTypes, FormGroupState, FormState } from '../state';\r\nimport { abstractControlReducer } from './util';\r\n\r\n/**\r\n * This update function takes a form control state and disables it. Disabling a control\r\n * will clear all of its errors (i.e. making it always valid) and will remove all\r\n * pending validations (thereby effectively cancelling those validations).\r\n */\r\nexport function disable<TValue extends FormControlValueTypes>(state: FormControlState<TValue>): FormControlState<TValue>;\r\n\r\n/**\r\n * This update function takes a form array state and disables it and all of its children.\r\n * Disabling a control will clear all of its errors (i.e. making it always valid) and\r\n * will remove all pending validations (thereby effectively cancelling those validations).\r\n */\r\nexport function disable<TValue>(state: FormArrayState<TValue>): FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes a form group state and disables it and all of its children.\r\n * Disabling a control will clear all of its errors (i.e. making it always valid) and\r\n * will remove all pending validations (thereby effectively cancelling those validations).\r\n */\r\nexport function disable<TValue>(state: FormGroupState<TValue>): FormGroupState<TValue>;\r\n\r\n/**\r\n * This update function takes a form state and disables it. For groups and arrays also\r\n * disables all children. Disabling a control will clear all of its errors (i.e. making\r\n * it always valid) and will remove all pending validations (thereby effectively\r\n * cancelling those validations).\r\n */\r\nexport function disable<TValue>(state: AbstractControlState<TValue>): FormState<TValue>;\r\n\r\nexport function disable<TValue>(state: AbstractControlState<TValue>) {\r\n  return abstractControlReducer(state, new DisableAction(state.id));\r\n}\r\n","import { EnableAction } from '../actions';\r\nimport { AbstractControlState, FormArrayState, FormControlState, FormControlValueTypes, FormGroupState, FormState } from '../state';\r\nimport { abstractControlReducer } from './util';\r\n\r\n/**\r\n * This update function takes a form control state and enables it.\r\n */\r\nexport function enable<TValue extends FormControlValueTypes>(state: FormControlState<TValue>): FormControlState<TValue>;\r\n\r\n/**\r\n * This update function takes a form array state and enables it and all of its children.\r\n */\r\nexport function enable<TValue>(state: FormArrayState<TValue>): FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes a form group state and enables it and all of its children.\r\n */\r\nexport function enable<TValue>(state: FormGroupState<TValue>): FormGroupState<TValue>;\r\n\r\n/**\r\n * This update function takes a form state and enables it. For groups and arrays also\r\n * enables all children.\r\n */\r\nexport function enable<TValue>(state: AbstractControlState<TValue>): FormState<TValue>;\r\n\r\nexport function enable<TValue>(state: AbstractControlState<TValue>) {\r\n  return abstractControlReducer(state, new EnableAction(state.id));\r\n}\r\n","import { FocusAction } from '../actions';\r\nimport { formControlReducer } from '../control/reducer';\r\nimport { FormControlState, FormControlValueTypes } from '../state';\r\n\r\n/**\r\n * This update function takes a form control state and marks it as focused (which\r\n * will also `.focus()` the form element).\r\n */\r\nexport function focus<TValue extends FormControlValueTypes>(state: FormControlState<TValue>) {\r\n  return formControlReducer(state, new FocusAction(state.id));\r\n}\r\n","import { MarkAsDirtyAction } from '../actions';\r\nimport { AbstractControlState, FormArrayState, FormControlState, FormControlValueTypes, FormGroupState, FormState } from '../state';\r\nimport { abstractControlReducer } from './util';\r\n\r\n/**\r\n * This update function takes a form control state and marks it as dirty.\r\n */\r\nexport function markAsDirty<TValue extends FormControlValueTypes>(state: FormControlState<TValue>): FormControlState<TValue>;\r\n\r\n/**\r\n * This update function takes a form array state and marks it and all of its children as dirty.\r\n */\r\nexport function markAsDirty<TValue>(state: FormArrayState<TValue>): FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes a form group state and marks it and all of its children as dirty.\r\n */\r\nexport function markAsDirty<TValue>(state: FormGroupState<TValue>): FormGroupState<TValue>;\r\n\r\n/**\r\n * This update function takes a state and marks it as dirty. For groups and arrays this also marks\r\n * all children as dirty.\r\n */\r\nexport function markAsDirty<TValue>(state: AbstractControlState<TValue>): FormState<TValue>;\r\n\r\nexport function markAsDirty<TValue>(state: AbstractControlState<TValue>) {\r\n  return abstractControlReducer(state, new MarkAsDirtyAction(state.id));\r\n}\r\n","import { MarkAsPristineAction } from '../actions';\r\nimport { AbstractControlState, FormArrayState, FormControlState, FormControlValueTypes, FormGroupState, FormState } from '../state';\r\nimport { abstractControlReducer } from './util';\r\n\r\n/**\r\n * This update function takes a form control state and marks it as pristine.\r\n */\r\nexport function markAsPristine<TValue extends FormControlValueTypes>(state: FormControlState<TValue>): FormControlState<TValue>;\r\n\r\n/**\r\n * This update function takes a form array state and marks it and all of its children as pristine.\r\n */\r\nexport function markAsPristine<TValue>(state: FormArrayState<TValue>): FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes a form group state and marks it and all of its children as pristine.\r\n */\r\nexport function markAsPristine<TValue>(state: FormGroupState<TValue>): FormGroupState<TValue>;\r\n\r\n/**\r\n * This update function takes a state and marks it as pristine. For groups and arrays this also marks\r\n * all children as pristine.\r\n */\r\nexport function markAsPristine<TValue>(state: AbstractControlState<TValue>): FormState<TValue>;\r\n\r\nexport function markAsPristine<TValue>(state: AbstractControlState<TValue>) {\r\n  return abstractControlReducer(state, new MarkAsPristineAction(state.id));\r\n}\r\n","import { MarkAsSubmittedAction } from '../actions';\r\nimport { AbstractControlState, FormArrayState, FormControlState, FormControlValueTypes, FormGroupState, FormState } from '../state';\r\nimport { abstractControlReducer } from './util';\r\n\r\n/**\r\n * This update function takes a form control state and marks it as submitted.\r\n */\r\nexport function markAsSubmitted<TValue extends FormControlValueTypes>(state: FormControlState<TValue>): FormControlState<TValue>;\r\n\r\n/**\r\n * This update function takes a form array state and marks it and all of its children as submitted.\r\n */\r\nexport function markAsSubmitted<TValue>(state: FormArrayState<TValue>): FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes a form group state and marks it and all of its children as submitted.\r\n */\r\nexport function markAsSubmitted<TValue>(state: FormGroupState<TValue>): FormGroupState<TValue>;\r\n\r\n/**\r\n * This update function takes a state and marks it as submitted. For groups and arrays this also marks\r\n * all children as submitted.\r\n */\r\nexport function markAsSubmitted<TValue>(state: AbstractControlState<TValue>): FormState<TValue>;\r\n\r\nexport function markAsSubmitted<TValue>(state: AbstractControlState<TValue>) {\r\n  return abstractControlReducer(state, new MarkAsSubmittedAction(state.id));\r\n}\r\n","import { MarkAsTouchedAction } from '../actions';\r\nimport { AbstractControlState, FormArrayState, FormControlState, FormControlValueTypes, FormGroupState, FormState } from '../state';\r\nimport { abstractControlReducer } from './util';\r\n\r\n/**\r\n * This update function takes a form control state and marks it as touched.\r\n */\r\nexport function markAsTouched<TValue extends FormControlValueTypes>(state: FormControlState<TValue>): FormControlState<TValue>;\r\n\r\n/**\r\n * This update function takes a form array state and marks it and all of its children as touched.\r\n */\r\nexport function markAsTouched<TValue>(state: FormArrayState<TValue>): FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes a form group state and marks it and all of its children as touched.\r\n */\r\nexport function markAsTouched<TValue>(state: FormGroupState<TValue>): FormGroupState<TValue>;\r\n\r\n/**\r\n * This update function takes a state and marks it as touched. For groups and arrays this also marks\r\n * all children as touched.\r\n */\r\nexport function markAsTouched<TValue>(state: AbstractControlState<TValue>): FormState<TValue>;\r\n\r\nexport function markAsTouched<TValue>(state: AbstractControlState<TValue>) {\r\n  return abstractControlReducer(state, new MarkAsTouchedAction(state.id));\r\n}\r\n","import { MarkAsUnsubmittedAction } from '../actions';\r\nimport { AbstractControlState, FormArrayState, FormControlState, FormControlValueTypes, FormGroupState, FormState } from '../state';\r\nimport { abstractControlReducer } from './util';\r\n\r\n/**\r\n * This update function takes a form control state and marks it as unsubmitted.\r\n */\r\nexport function markAsUnsubmitted<TValue extends FormControlValueTypes>(state: FormControlState<TValue>): FormControlState<TValue>;\r\n\r\n/**\r\n * This update function takes a form array state and marks it and all of its children as unsubmitted.\r\n */\r\nexport function markAsUnsubmitted<TValue>(state: FormArrayState<TValue>): FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes a form group state and marks it and all of its children as unsubmitted.\r\n */\r\nexport function markAsUnsubmitted<TValue>(state: FormGroupState<TValue>): FormGroupState<TValue>;\r\n\r\n/**\r\n * This update function takes a state and marks it as unsubmitted. For groups and arrays this also marks\r\n * all children as unsubmitted.\r\n */\r\nexport function markAsUnsubmitted<TValue>(state: AbstractControlState<TValue>): FormState<TValue>;\r\n\r\nexport function markAsUnsubmitted<TValue>(state: AbstractControlState<TValue>) {\r\n  return abstractControlReducer(state, new MarkAsUnsubmittedAction(state.id));\r\n}\r\n","import { MarkAsUntouchedAction } from '../actions';\r\nimport { AbstractControlState, FormArrayState, FormControlState, FormControlValueTypes, FormGroupState, FormState } from '../state';\r\nimport { abstractControlReducer } from './util';\r\n\r\n/**\r\n * This update function takes a form control state and marks it as untouched.\r\n */\r\nexport function markAsUntouched<TValue extends FormControlValueTypes>(state: FormControlState<TValue>): FormControlState<TValue>;\r\n\r\n/**\r\n * This update function takes a form array state and marks it and all of its children as untouched.\r\n */\r\nexport function markAsUntouched<TValue>(state: FormArrayState<TValue>): FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes a form group state and marks it and all of its children as untouched.\r\n */\r\nexport function markAsUntouched<TValue>(state: FormGroupState<TValue>): FormGroupState<TValue>;\r\n\r\n/**\r\n * This update function takes a state and marks it as untouched. For groups and arrays this also marks\r\n * all children as untouched.\r\n */\r\nexport function markAsUntouched<TValue>(state: AbstractControlState<TValue>): FormState<TValue>;\r\n\r\nexport function markAsUntouched<TValue>(state: AbstractControlState<TValue>) {\r\n  return abstractControlReducer(state, new MarkAsUntouchedAction(state.id));\r\n}\r\n","import { RemoveArrayControlAction } from '../actions';\r\nimport { formArrayReducer } from '../array/reducer';\r\nimport { FormArrayState, isArrayState } from '../state';\r\nimport { ensureState } from './util';\r\n\r\n/**\r\n * This update function takes an index and returns a projection function\r\n * that removes the child control at the given index from a form array state.\r\n */\r\nexport function removeArrayControl(index: number): <TValue>(state: FormArrayState<TValue>) => FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes an array form state and an index and removes the\r\n * child control at the given index from the state.\r\n */\r\nexport function removeArrayControl<TValue>(state: FormArrayState<TValue>, index: number): FormArrayState<TValue>;\r\n\r\nexport function removeArrayControl<TValue>(indexOrState: number | FormArrayState<TValue>, index?: number) {\r\n  if (isArrayState(indexOrState)) {\r\n    return formArrayReducer(indexOrState, new RemoveArrayControlAction(indexOrState.id, index!));\r\n  }\r\n\r\n  return (s: FormArrayState<TValue>) => removeArrayControl(ensureState(s), indexOrState as number);\r\n}\r\n","import { RemoveGroupControlAction } from '../actions';\r\nimport { formGroupReducer } from '../group/reducer';\r\nimport { FormGroupState, isGroupState, KeyValue } from '../state';\r\nimport { ensureState } from './util';\r\n\r\n/**\r\n * This update function takes a name and returns a projection function\r\n * that removes the child control with the given name from a form group state.\r\n */\r\nexport function removeGroupControl<TValue extends KeyValue>(name: keyof TValue): (state: FormGroupState<TValue>) => FormGroupState<TValue>;\r\n\r\n/**\r\n * This update function takes a group form state and a name and removes the\r\n * child control with the given name from the state.\r\n */\r\nexport function removeGroupControl<TValue extends KeyValue>(state: FormGroupState<TValue>, name: keyof TValue): FormGroupState<TValue>;\r\n\r\nexport function removeGroupControl<TValue extends KeyValue>(nameOrState: keyof TValue | FormGroupState<TValue>, name?: keyof TValue) {\r\n  if (isGroupState(nameOrState)) {\r\n    return formGroupReducer(nameOrState, new RemoveGroupControlAction<TValue>(nameOrState.id, name!));\r\n  }\r\n\r\n  return (s: FormGroupState<TValue>) => removeGroupControl(ensureState(s), nameOrState as keyof TValue);\r\n}\r\n","import { ResetAction } from '../actions';\r\nimport { AbstractControlState, FormArrayState, FormControlState, FormControlValueTypes, FormGroupState, FormState } from '../state';\r\nimport { abstractControlReducer } from './util';\r\n\r\n/**\r\n * This update function takes a form control state and marks it as pristine,\r\n * untouched, and unsubmitted.\r\n */\r\nexport function reset<TValue extends FormControlValueTypes>(state: FormControlState<TValue>): FormControlState<TValue>;\r\n\r\n/**\r\n * This update function takes a form array state and marks it and all of its\r\n * children as pristine, untouched, and unsubmitted.\r\n */\r\nexport function reset<TValue>(state: FormArrayState<TValue>): FormArrayState<TValue>;\r\n\r\n/**\r\n * This update function takes a form group state and marks it and all of its\r\n * children as pristine, untouched, and unsubmitted.\r\n */\r\nexport function reset<TValue>(state: FormGroupState<TValue>): FormGroupState<TValue>;\r\n\r\n/**\r\n * This update function takes a state and marks it as pristine, untouched, and\r\n * unsubmitted. For groups and arrays this also marks all children as pristine,\r\n * untouched, and unsubmitted.\r\n */\r\nexport function reset<TValue>(state: AbstractControlState<TValue>): FormState<TValue>;\r\n\r\nexport function reset<TValue>(state: AbstractControlState<TValue>) {\r\n  return abstractControlReducer(state, new ResetAction(state.id));\r\n}\r\n","import { SetAsyncErrorAction } from '../actions';\r\nimport { AbstractControlState, FormState, isFormState } from '../state';\r\nimport { abstractControlReducer, ensureState } from './util';\r\n\r\n/**\r\n * This update function takes a name and a value and returns a projection\r\n * function that sets the async error for the given name to the given value.\r\n * It also marks the validation for the name as not pending anymore if it\r\n * was pending.\r\n */\r\nexport function setAsyncError(name: string, value: any): <TValue>(state: AbstractControlState<TValue>) => FormState<TValue>;\r\n\r\n/**\r\n * This update function takes a form state, a name, and a value and sets the\r\n * async error for the given name to the given value. It also marks the\r\n * validation for the name as not pending anymore if it was pending.\r\n */\r\nexport function setAsyncError<TValue>(state: AbstractControlState<TValue>, name: string, value: any): FormState<TValue>;\r\n\r\nexport function setAsyncError<TValue>(nameOrState: string | AbstractControlState<TValue>, nameOrValue?: string | any, value?: any) {\r\n  if (isFormState(nameOrState)) {\r\n    return abstractControlReducer(nameOrState, new SetAsyncErrorAction(nameOrState.id, nameOrValue, value));\r\n  }\r\n\r\n  return (s: AbstractControlState<TValue>) => setAsyncError(ensureState(s), nameOrState, nameOrValue);\r\n}\r\n","import { SetErrorsAction } from '../actions';\r\nimport { formStateReducer } from '../reducer';\r\nimport { AbstractControlState, FormState, isFormState, ValidationErrors } from '../state';\r\nimport { ensureState } from './util';\r\n\r\n/**\r\n * This update function takes a form state and a number of error objects and sets the\r\n * errors of the state.\r\n */\r\nexport function setErrors<TValue>(\r\n  state: AbstractControlState<TValue>,\r\n  errors: ValidationErrors,\r\n  ...rest: ValidationErrors[]\r\n): FormState<TValue>;\r\n\r\n/**\r\n * This update function takes a form state and an array of error objects and sets the\r\n * errors of the state.\r\n */\r\nexport function setErrors<TValue>(\r\n  state: AbstractControlState<TValue>,\r\n  errorsArray: ValidationErrors[],\r\n): FormState<TValue>;\r\n\r\n/**\r\n * This update function takes a number of error objects and returns a projection\r\n * function that sets the errors of a form state.\r\n */\r\nexport function setErrors(errors: ValidationErrors, ...rest: ValidationErrors[]): <TValue>(state: AbstractControlState<TValue>) => FormState<TValue>;\r\n\r\n/**\r\n * This update function takes an array of error objects and returns a projection\r\n * function that sets the errors of a form state.\r\n */\r\nexport function setErrors(errorsArray: ValidationErrors[]): <TValue>(state: AbstractControlState<TValue>) => FormState<TValue>;\r\n\r\nexport function setErrors<TValue>(\r\n  errorsOrErrorsArrayOrState: ValidationErrors | ValidationErrors[] | FormState<TValue>,\r\n  errorsOrErrorsArray?: ValidationErrors | ValidationErrors[],\r\n  ...rest: ValidationErrors[]\r\n) {\r\n  if (isFormState<TValue>(errorsOrErrorsArrayOrState)) {\r\n    const errorsArray = Array.isArray(errorsOrErrorsArray) ? errorsOrErrorsArray : [errorsOrErrorsArray!];\r\n    const errors = errorsArray.concat(...rest).reduce((agg, err) => Object.assign(agg, err), {} as ValidationErrors);\r\n\r\n    return formStateReducer(errorsOrErrorsArrayOrState, new SetErrorsAction(errorsOrErrorsArrayOrState.id, errors));\r\n  }\r\n\r\n  let errorsArray = Array.isArray(errorsOrErrorsArrayOrState) ? errorsOrErrorsArrayOrState : [errorsOrErrorsArrayOrState];\r\n  errorsArray = errorsOrErrorsArray === undefined ? errorsArray : errorsArray.concat(errorsOrErrorsArray);\r\n  return (s: AbstractControlState<TValue>) => setErrors<TValue>(ensureState(s), errorsArray.concat(rest));\r\n}\r\n","import { SetUserDefinedPropertyAction } from '../actions';\r\nimport { formStateReducer } from '../reducer';\r\nimport { AbstractControlState, FormState, isFormState } from '../state';\r\nimport { ensureState } from './util';\r\n\r\n/**\r\n * This update function takes a name and a value and returns a projection\r\n * function that sets a user-defined property on a form state.\r\n */\r\nexport function setUserDefinedProperty(name: string, value: any): <TValue>(state: AbstractControlState<TValue>) => FormState<TValue>;\r\n\r\n/**\r\n * This update function takes a form state, a name, and a value and sets\r\n * a user-defined property on the state.\r\n */\r\nexport function setUserDefinedProperty<TValue>(state: AbstractControlState<TValue>, name: string, value: any): FormState<TValue>;\r\n\r\nexport function setUserDefinedProperty<TValue>(nameOrState: string | FormState<TValue>, valueOrName: any | string, value?: any) {\r\n  if (isFormState<TValue>(nameOrState)) {\r\n    return formStateReducer(nameOrState, new SetUserDefinedPropertyAction(nameOrState.id, valueOrName, value));\r\n  }\r\n\r\n  return (s: AbstractControlState<TValue>) => setUserDefinedProperty(ensureState(s), nameOrState, valueOrName);\r\n}\r\n","import { SetValueAction } from '../actions';\r\nimport { AbstractControlState, FormState, isFormState } from '../state';\r\nimport { abstractControlReducer, ensureState } from './util';\r\n\r\n/**\r\n * This update function takes a value and returns a projection function that\r\n * sets the value of a form state. Setting the value of a group or array will\r\n * also update the values of all children including adding and removing\r\n * children on the fly for added/removed properties/items.\r\n */\r\nexport function setValue<TValue>(value: TValue): (state: AbstractControlState<TValue>) => FormState<TValue>;\r\n\r\n/**\r\n * This update function takes a form state and a value and sets the value of\r\n * the state. Setting the value of a group or array will also update the\r\n * values of all children including adding and removing children on the fly\r\n * for added/removed properties/items.\r\n */\r\nexport function setValue<TValue>(state: AbstractControlState<TValue>, value: TValue): FormState<TValue>;\r\n\r\nexport function setValue<TValue>(valueOrState: TValue | AbstractControlState<TValue>, value?: TValue) {\r\n  if (isFormState(valueOrState)) {\r\n    return abstractControlReducer(valueOrState, new SetValueAction(valueOrState.id, value));\r\n  }\r\n\r\n  return (s: AbstractControlState<TValue>) => setValue(ensureState(s), valueOrState);\r\n}\r\n","import { StartAsyncValidationAction } from '../actions';\r\nimport { AbstractControlState, FormState, isFormState } from '../state';\r\nimport { abstractControlReducer, ensureState } from './util';\r\n\r\n/**\r\n * This update function takes a name and returns a projection function that\r\n * marks the async validation for the given name as pending.\r\n */\r\nexport function startAsyncValidation(name: string): <TValue>(state: AbstractControlState<TValue>) => FormState<TValue>;\r\n\r\n/**\r\n * This update function takes a form state and a name and marks the async\r\n * validation for the given name as pending.\r\n */\r\nexport function startAsyncValidation<TValue>(state: AbstractControlState<TValue>, name: string): FormState<TValue>;\r\n\r\nexport function startAsyncValidation<TValue>(nameOrState: string | AbstractControlState<TValue>, name?: string) {\r\n  if (isFormState(nameOrState)) {\r\n    return abstractControlReducer(nameOrState, new StartAsyncValidationAction(nameOrState.id, name!));\r\n  }\r\n\r\n  return (s: AbstractControlState<TValue>) => startAsyncValidation(ensureState(s), nameOrState);\r\n}\r\n","import { UnfocusAction } from '../actions';\r\nimport { formControlReducer } from '../control/reducer';\r\nimport { FormControlState, FormControlValueTypes } from '../state';\r\n\r\n/**\r\n * This update function takes a form control state and marks it as not focused (which\r\n * will also `.blur()` the form element).\r\n */\r\nexport function unfocus<TValue extends FormControlValueTypes>(state: FormControlState<TValue>) {\r\n  return formControlReducer(state, new UnfocusAction(state.id));\r\n}\r\n","import {\r\n  AbstractControlState,\r\n  FormState,\r\n  isArrayState,\r\n  isFormState,\r\n  isGroupState,\r\n} from '../state';\r\nimport { updateArray } from './update-array';\r\nimport { StateUpdateFns, updateGroup } from './update-group';\r\nimport { ensureState, ProjectFn2 } from './util';\r\n\r\nfunction updateRecursiveSingle(parent: AbstractControlState<any>, updateFn: ProjectFn2<AbstractControlState<any>, AbstractControlState<any>>) {\r\n  return (state: AbstractControlState<any>): AbstractControlState<any> => {\r\n    if (isGroupState(state)) {\r\n      const updateFunctions = Object.keys(state.controls).reduce((agg, key) => Object.assign(agg, {\r\n        [key]: (s: AbstractControlState<any>, p: AbstractControlState<any>) => updateRecursiveSingle(p, updateFn)(s),\r\n      }), {} as StateUpdateFns<any>);\r\n      state = updateGroup<any>(updateFunctions)(state);\r\n      return updateFn(state, parent);\r\n    }\r\n\r\n    if (isArrayState(state)) {\r\n      state = updateArray<any>((s, p) => updateRecursiveSingle(p, updateFn)(s))(state);\r\n      return updateFn(state, parent);\r\n    }\r\n\r\n    return updateFn(state, parent);\r\n  };\r\n}\r\n\r\n/**\r\n * This update function takes a form array state and one or more update\r\n * functions applies all update functions one after another to the state\r\n * recursively, i.e. the function is applied to the state's children,\r\n * their children etc.\r\n *\r\n * The following example uses this function to validate all controls in a\r\n * group or array as required.\r\n *\r\n ```typescript\r\n const updatedState = updateRecursive(\r\n   state,\r\n   validate<any>(required),\r\n );\r\n ```\r\n */\r\nexport function updateRecursive<TValue>(\r\n  state: AbstractControlState<TValue>,\r\n  updateFn: ProjectFn2<AbstractControlState<any>, AbstractControlState<any>>,\r\n  ...updateFnArr: ProjectFn2<AbstractControlState<any>, AbstractControlState<any>>[]\r\n): FormState<TValue>;\r\n\r\n/**\r\n * This update function takes a form array state and an array of\r\n * update functions applies all update functions one after another to the\r\n * state recursively, i.e. the function is applied to the state's children,\r\n * their children etc.\r\n *\r\n * The following example uses this function to validate all controls in a\r\n * group or array as required.\r\n *\r\n```typescript\r\nconst updatedState = updateRecursive(\r\n  state,\r\n  [validate<any>(required)],\r\n);\r\n```\r\n */\r\nexport function updateRecursive<TValue>(\r\n  state: AbstractControlState<TValue>,\r\n  updateFnArr: ProjectFn2<AbstractControlState<any>, AbstractControlState<any>>[],\r\n): FormState<TValue>;\r\n\r\n/**\r\n * This update function takes one or more update functions and returns a\r\n * projection function that applies all update functions one after another to\r\n * a form state.\r\n *\r\n * The following example uses this function to validate all controls in a\r\n * group as required.\r\n *\r\n```typescript\r\nconst updateFn = updateRecursive(validate<any>(required));\r\nconst updatedState = updateFn(state);\r\n```\r\n */\r\nexport function updateRecursive(\r\n  updateFn: ProjectFn2<AbstractControlState<any>, AbstractControlState<any>>,\r\n  ...updateFnArr: ProjectFn2<AbstractControlState<any>, AbstractControlState<any>>[]\r\n): <TValue>(state: AbstractControlState<TValue>) => FormState<TValue>;\r\n\r\n/**\r\n * This update function takes an array of update functions and returns\r\n * a projection function that applies all update functions one after another to\r\n * a form state.\r\n *\r\n * The following example uses this function to validate all controls in a\r\n * group as required.\r\n *\r\n```typescript\r\nconst updateFn = updateRecursive([validate<any>(required)]);\r\nconst updatedState = updateFn(state);\r\n```\r\n */\r\nexport function updateRecursive(\r\n  updateFnArr: ProjectFn2<AbstractControlState<any>, AbstractControlState<any>>[],\r\n): <TValue>(state: AbstractControlState<TValue>) => FormState<TValue>;\r\n\r\nexport function updateRecursive<TValue>(\r\n  stateOrFunctionOrFunctionArray:\r\n    | AbstractControlState<TValue>\r\n    | ProjectFn2<AbstractControlState<any>, AbstractControlState<any>>\r\n    | ProjectFn2<AbstractControlState<any>, AbstractControlState<any>>[],\r\n  updateFnOrUpdateFnArr?: ProjectFn2<AbstractControlState<any>, AbstractControlState<any>> | ProjectFn2<AbstractControlState<any>, AbstractControlState<any>>[],\r\n  ...rest: ProjectFn2<AbstractControlState<any>, AbstractControlState<any>>[]\r\n) {\r\n  if (isFormState(stateOrFunctionOrFunctionArray)) {\r\n    const updateFnArr = Array.isArray(updateFnOrUpdateFnArr) ? updateFnOrUpdateFnArr : [updateFnOrUpdateFnArr!];\r\n    return updateFnArr.concat(...rest)\r\n      .reduce((s, updateFn) => updateRecursiveSingle(stateOrFunctionOrFunctionArray, updateFn)(s), stateOrFunctionOrFunctionArray);\r\n  }\r\n\r\n  let updateFnArr = Array.isArray(stateOrFunctionOrFunctionArray) ? stateOrFunctionOrFunctionArray : [stateOrFunctionOrFunctionArray];\r\n  updateFnArr = updateFnOrUpdateFnArr === undefined ? updateFnArr : updateFnArr.concat(updateFnOrUpdateFnArr);\r\n  return (s: AbstractControlState<TValue>) => updateRecursive<TValue>(ensureState(s), updateFnArr.concat(rest));\r\n}\r\n","import { SetErrorsAction } from '../actions';\r\nimport { formStateReducer } from '../reducer';\r\nimport { AbstractControlState, FormState, isFormState, ValidationErrors } from '../state';\r\nimport { ensureState } from './util';\r\n\r\nexport type ValidationFn<TValue> = (value: TValue) => ValidationErrors;\r\n\r\n/**\r\n * This update function takes one or more validation functions and a form\r\n * state and sets the errors of the state to the result of applying the\r\n * given validation function(s) to the state's value.\r\n */\r\nexport function validate<TValue>(\r\n  state: AbstractControlState<TValue>,\r\n  fn: ValidationFn<TValue>,\r\n  ...rest: ValidationFn<TValue>[]\r\n): FormState<TValue>;\r\n\r\n/**\r\n * This update function takes an array of validation functions and a form\r\n * state and sets the errors of the state to the result of applying the given\r\n * validation function(s) to the state's value.\r\n */\r\nexport function validate<TValue>(\r\n  state: AbstractControlState<TValue>,\r\n  rest: ValidationFn<TValue>[],\r\n): FormState<TValue>;\r\n\r\n/**\r\n * This update function takes one or more validation functions and returns\r\n * a projection function that sets the errors of a form state to the result\r\n * of applying the given validation function(s) to the state's value.\r\n */\r\nexport function validate<TValue>(\r\n  fn: ValidationFn<TValue>,\r\n  ...rest: ValidationFn<TValue>[]\r\n): (state: AbstractControlState<TValue>) => FormState<TValue>;\r\n\r\n/**\r\n * This update function takes an array of validation functions and returns a\r\n * projection function that sets the errors of a form state to the result of\r\n * applying the given validation function(s) to the state's value.\r\n */\r\nexport function validate<TValue>(\r\n  rest: ValidationFn<TValue>[],\r\n): (state: AbstractControlState<TValue>) => FormState<TValue>;\r\n\r\nexport function validate<TValue>(\r\n  stateOrFunctionOrFunctionArray: FormState<TValue> | ValidationFn<TValue> | ValidationFn<TValue>[],\r\n  functionOrFunctionArr?: ValidationFn<TValue> | ValidationFn<TValue>[],\r\n  ...rest: ValidationFn<TValue>[]\r\n) {\r\n  if (isFormState<TValue>(stateOrFunctionOrFunctionArray)) {\r\n    const functionArr = Array.isArray(functionOrFunctionArr) ? functionOrFunctionArr : [functionOrFunctionArr!];\r\n    const errors = functionArr.concat(...rest)\r\n      .reduce((agg, validationFn) => Object.assign(agg, validationFn(stateOrFunctionOrFunctionArray.value)), {} as ValidationErrors);\r\n    return formStateReducer<TValue>(stateOrFunctionOrFunctionArray, new SetErrorsAction(stateOrFunctionOrFunctionArray.id, errors));\r\n  }\r\n\r\n  let updateFnArr = Array.isArray(stateOrFunctionOrFunctionArray) ? stateOrFunctionOrFunctionArray : [stateOrFunctionOrFunctionArray];\r\n  updateFnArr = functionOrFunctionArr === undefined ? updateFnArr : updateFnArr.concat(functionOrFunctionArr);\r\n  return (s: AbstractControlState<TValue>) => validate<TValue>(ensureState(s), updateFnArr.concat(rest));\r\n}\r\n"]}
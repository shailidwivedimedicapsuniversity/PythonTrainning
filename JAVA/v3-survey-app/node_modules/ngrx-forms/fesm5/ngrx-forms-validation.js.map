{"version":3,"file":"ngrx-forms-validation.js","sources":["ng://ngrx-forms/validation/src/email.ts","ng://ngrx-forms/validation/src/equal-to.ts","ng://ngrx-forms/validation/src/greater-than.ts","ng://ngrx-forms/validation/src/greater-than-or-equal-to.ts","ng://ngrx-forms/validation/src/less-than.ts","ng://ngrx-forms/validation/src/less-than-or-equal-to.ts","ng://ngrx-forms/validation/src/max-length.ts","ng://ngrx-forms/validation/src/min-length.ts","ng://ngrx-forms/validation/src/not-equal-to.ts","ng://ngrx-forms/validation/src/pattern.ts","ng://ngrx-forms/validation/src/required.ts","ng://ngrx-forms/validation/src/required-false.ts","ng://ngrx-forms/validation/src/required-true.ts","ng://ngrx-forms/validation/public_api.ts","ng://ngrx-forms/validation/ngrx-forms-validation.ts"],"sourcesContent":["import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\r\n\r\n// this regex is taken from the @angular/forms source code\r\n// tslint:disable-next-line:max-line-length\r\nexport const NGRX_FORMS_EMAIL_VALIDATION_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;\r\n\r\nexport interface EmailValidationError {\r\n  pattern: string;\r\n  actual: string;\r\n}\r\n\r\n// @ts-ignore\r\ndeclare module 'ngrx-forms/src/state' {\r\n  export interface ValidationErrors {\r\n    email?: EmailValidationError;\r\n  }\r\n}\r\n\r\n/**\r\n * A validation function that requires a value to be a valid e-mail address.\r\n * Considers `null`, `undefined`, and `''` as valid. Combine this function with the\r\n * `required` validation function if these values should be considered invalid.\r\n *\r\n * The validation error returned by this validation function has the following shape:\r\n *\r\n```typescript\r\n{\r\n  email: {\r\n    pattern: string;\r\n    actual: string;\r\n  };\r\n}\r\n```\r\n *\r\n * Usually you would use this validation function in conjunction with the `validate`\r\n * update function to perform synchronous validation in your reducer:\r\n *\r\n```typescript\r\nupdateGroup<MyFormValue>({\r\n  userMailAddress: validate(email),\r\n})\r\n```\r\n *\r\n * Note that this function is generic to allow the compiler to properly infer the type\r\n * of the `validate` function for both optional and non-optional controls.\r\n */\r\nexport function email<T extends string | Boxed<string> | null | undefined>(value: T): ValidationErrors {\r\n  value = unbox(value) as string | null | undefined as T;\r\n\r\n  if (value === null || value === undefined || (value as string).length === 0) {\r\n    return {};\r\n  }\r\n\r\n  if (NGRX_FORMS_EMAIL_VALIDATION_REGEXP.test(value as string)) {\r\n    return {};\r\n  }\r\n\r\n  return {\r\n    email: {\r\n      pattern: NGRX_FORMS_EMAIL_VALIDATION_REGEXP.toString(),\r\n      actual: value as string,\r\n    },\r\n  };\r\n}\r\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\r\n\r\nexport interface EqualToValidationError<T> {\r\n  comparand: T;\r\n  actual: T;\r\n}\r\n\r\n// @ts-ignore\r\ndeclare module 'ngrx-forms/src/state' {\r\n  export interface ValidationErrors {\r\n    equalTo?: EqualToValidationError<any>;\r\n  }\r\n}\r\n\r\n/**\r\n * A validation function that requires the value to be strictly equal (i.e. `===`)\r\n * to another value.\r\n *\r\n * The validation error returned by this validation function has the following shape:\r\n *\r\n```typescript\r\n{\r\n  equalTo: {\r\n    comparand: T;\r\n    actual: T;\r\n  };\r\n}\r\n```\r\n *\r\n * Usually you would use this validation function in conjunction with the `validate`\r\n * update function to perform synchronous validation in your reducer:\r\n *\r\n```typescript\r\nupdateGroup<MyFormValue>({\r\n  name: validate(equalTo('John Doe')),\r\n})\r\n```\r\n */\r\nexport function equalTo<T>(comparand: T) {\r\n  return <TV extends T | Boxed<T> = T>(value: TV): ValidationErrors => {\r\n    value = unbox(value) as T as TV;\r\n\r\n    if (value === comparand) {\r\n      return {};\r\n    }\r\n\r\n    return {\r\n      equalTo: {\r\n        comparand,\r\n        actual: value,\r\n      },\r\n    };\r\n  };\r\n}\r\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\r\n\r\nexport interface GreaterThanValidationError {\r\n  comparand: number;\r\n  actual: number;\r\n}\r\n\r\n// @ts-ignore\r\ndeclare module 'ngrx-forms/src/state' {\r\n  export interface ValidationErrors {\r\n    greaterThan?: GreaterThanValidationError;\r\n  }\r\n}\r\n\r\n/**\r\n * A validation function that requires the value to be greater than a number.\r\n * Considers `null` and `undefined` as valid. Combine this function with the `required`\r\n * validation function if `null` or `undefined` should be considered invalid.\r\n *\r\n * The validation error returned by this validation function has the following shape:\r\n *\r\n```typescript\r\n{\r\n  greaterThan: {\r\n    comparand: number;\r\n    actual: number;\r\n  };\r\n}\r\n```\r\n *\r\n * Usually you would use this validation function in conjunction with the `validate`\r\n * update function to perform synchronous validation in your reducer:\r\n *\r\n```typescript\r\nupdateGroup<MyFormValue>({\r\n  amount: validate(greaterThan(10)),\r\n})\r\n```\r\n *\r\n * Note that this function is generic to allow the compiler to properly infer the type\r\n * of the `validate` function for both optional and non-optional controls.\r\n */\r\nexport function greaterThan(comparand: number) {\r\n  // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)\r\n  if (comparand === null || comparand === undefined) {\r\n    throw new Error(`The greaterThan Validation function requires the comparand parameter to be a non-null number, got ${comparand}!`);\r\n  }\r\n\r\n  return <T extends number | Boxed<number> | null | undefined>(value: T): ValidationErrors => {\r\n    value = unbox(value) as number | null | undefined as T;\r\n\r\n    if (value === null || value === undefined) {\r\n      return {};\r\n    }\r\n\r\n    if (value > comparand) {\r\n      return {};\r\n    }\r\n\r\n    return {\r\n      greaterThan: {\r\n        comparand,\r\n        actual: value as number,\r\n      },\r\n    };\r\n  };\r\n}\r\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\r\n\r\nexport interface GreaterThanOrEqualToValidationError {\r\n  comparand: number;\r\n  actual: number;\r\n}\r\n\r\n// @ts-ignore\r\ndeclare module 'ngrx-forms/src/state' {\r\n  export interface ValidationErrors {\r\n    greaterThanOrEqualTo?: GreaterThanOrEqualToValidationError;\r\n  }\r\n}\r\n\r\n/**\r\n * A validation function that requires the value to be greater than or equal to a number.\r\n * Considers `null` and `undefined` as valid. Combine this function with the `required`\r\n * validation function if `null` or `undefined` should be considered invalid.\r\n *\r\n * The validation error returned by this validation function has the following shape:\r\n *\r\n```typescript\r\n{\r\n  greaterThanOrEqualTo: {\r\n    comparand: number;\r\n    actual: number;\r\n  };\r\n}\r\n```\r\n *\r\n * Usually you would use this validation function in conjunction with the `validate`\r\n * update function to perform synchronous validation in your reducer:\r\n *\r\n```typescript\r\nupdateGroup<MyFormValue>({\r\n  amount: validate(greaterThanOrEqualTo(10)),\r\n})\r\n```\r\n *\r\n * Note that this function is generic to allow the compiler to properly infer the type\r\n * of the `validate` function for both optional and non-optional controls.\r\n */\r\nexport function greaterThanOrEqualTo(comparand: number) {\r\n  // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)\r\n  if (comparand === null || comparand === undefined) {\r\n    throw new Error(`The greaterThanOrEqualTo Validation function requires the comparand parameter to be a non-null number, got ${comparand}!`);\r\n  }\r\n\r\n  return <T extends number | Boxed<number> | null | undefined>(value: T): ValidationErrors => {\r\n    value = unbox(value) as number | null | undefined as T;\r\n\r\n    if (value === null || value === undefined) {\r\n      return {};\r\n    }\r\n\r\n    if (value >= comparand) {\r\n      return {};\r\n    }\r\n\r\n    return {\r\n      greaterThanOrEqualTo: {\r\n        comparand,\r\n        actual: value as number,\r\n      },\r\n    };\r\n  };\r\n}\r\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\r\n\r\nexport interface LessThanValidationError {\r\n  comparand: number;\r\n  actual: number;\r\n}\r\n\r\n// @ts-ignore\r\ndeclare module 'ngrx-forms/src/state' {\r\n  export interface ValidationErrors {\r\n    lessThan?: LessThanValidationError;\r\n  }\r\n}\r\n\r\n/**\r\n * A validation function that requires the value to be less than a number.\r\n * Considers `null` and `undefined` as valid. Combine this function with the `required`\r\n * validation function if `null` or `undefined` should be considered invalid.\r\n *\r\n * The validation error returned by this validation function has the following shape:\r\n *\r\n```typescript\r\n{\r\n  lessThan: {\r\n    comparand: number;\r\n    actual: number;\r\n  };\r\n}\r\n```\r\n *\r\n * Usually you would use this validation function in conjunction with the `validate`\r\n * update function to perform synchronous validation in your reducer:\r\n *\r\n```typescript\r\nupdateGroup<MyFormValue>({\r\n  amount: validate(lessThan(10)),\r\n})\r\n```\r\n *\r\n * Note that this function is generic to allow the compiler to properly infer the type\r\n * of the `validate` function for both optional and non-optional controls.\r\n */\r\nexport function lessThan(comparand: number) {\r\n  // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)\r\n  if (comparand === null || comparand === undefined) {\r\n    throw new Error(`The lessThan Validation function requires the comparand parameter to be a non-null number, got ${comparand}!`);\r\n  }\r\n\r\n  return <T extends number | Boxed<number> | null | undefined>(value: T): ValidationErrors => {\r\n    value = unbox(value) as number | null | undefined as T;\r\n\r\n    if (value === null || value === undefined) {\r\n      return {};\r\n    }\r\n\r\n    if (value < comparand) {\r\n      return {};\r\n    }\r\n\r\n    return {\r\n      lessThan: {\r\n        comparand,\r\n        actual: value as number,\r\n      },\r\n    };\r\n  };\r\n}\r\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\r\n\r\nexport interface LessThanOrEqualToValidationError {\r\n  comparand: number;\r\n  actual: number;\r\n}\r\n\r\n// @ts-ignore\r\ndeclare module 'ngrx-forms/src/state' {\r\n  export interface ValidationErrors {\r\n    lessThanOrEqualTo?: LessThanOrEqualToValidationError;\r\n  }\r\n}\r\n\r\n/**\r\n * A validation function that requires the value to be less than or equal to a number.\r\n * Considers `null` and `undefined` as valid. Combine this function with the `required`\r\n * validation function if `null` or `undefined` should be considered invalid.\r\n *\r\n * The validation error returned by this validation function has the following shape:\r\n *\r\n```typescript\r\n{\r\n  lessThanOrEqualTo: {\r\n    comparand: number;\r\n    actual: number;\r\n  };\r\n}\r\n```\r\n *\r\n * Usually you would use this validation function in conjunction with the `validate`\r\n * update function to perform synchronous validation in your reducer:\r\n *\r\n```typescript\r\nupdateGroup<MyFormValue>({\r\n  amount: validate(lessThanOrEqualTo(10)),\r\n})\r\n```\r\n *\r\n * Note that this function is generic to allow the compiler to properly infer the type\r\n * of the `validate` function for both optional and non-optional controls.\r\n */\r\nexport function lessThanOrEqualTo(comparand: number) {\r\n  // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)\r\n  if (comparand === null || comparand === undefined) {\r\n    throw new Error(`The lessThanOrEqualTo Validation function requires the comparand parameter to be a non-null number, got ${comparand}!`);\r\n  }\r\n\r\n  return <T extends number | Boxed<number> | null | undefined>(value: T): ValidationErrors => {\r\n    value = unbox(value) as number | null | undefined as T;\r\n\r\n    if (value === null || value === undefined) {\r\n      return {};\r\n    }\r\n\r\n    if (value <= comparand) {\r\n      return {};\r\n    }\r\n\r\n    return {\r\n      lessThanOrEqualTo: {\r\n        comparand,\r\n        actual: value as number,\r\n      },\r\n    };\r\n  };\r\n}\r\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\r\n\r\nexport interface MaxLengthValidationError {\r\n  maxLength: number;\r\n  value: string;\r\n  actualLength: number;\r\n}\r\n\r\n// @ts-ignore\r\ndeclare module 'ngrx-forms/src/state' {\r\n  export interface ValidationErrors {\r\n    maxLength?: MaxLengthValidationError;\r\n  }\r\n}\r\n\r\n/**\r\n * A validation function that requires a `string` or `array` value to have a maximum length.\r\n * Considers `null` and `undefined` as valid. Combine this function with the `required`\r\n * validation function if `null` or `undefined` should be considered invalid.\r\n *\r\n * The validation error returned by this validation function has the following shape:\r\n *\r\n```typescript\r\n{\r\n  maxLength: {\r\n    maxLength: number;\r\n    value: string;\r\n    actualLength: number;\r\n  };\r\n}\r\n```\r\n *\r\n * Usually you would use this validation function in conjunction with the `validate`\r\n * update function to perform synchronous validation in your reducer:\r\n *\r\n```typescript\r\nupdateGroup<MyFormValue>({\r\n  name: validate(maxLength(10)),\r\n})\r\n```\r\n *\r\n * Note that this function is generic to allow the compiler to properly infer the type\r\n * of the `validate` function for both optional and non-optional controls.\r\n */\r\nexport function maxLength(maxLengthParam: number) {\r\n  // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)\r\n  if (maxLengthParam === null || maxLengthParam === undefined) {\r\n    throw new Error(`The maxLength Validation function requires the maxLength parameter to be a non-null number, got ${maxLengthParam}!`);\r\n  }\r\n\r\n  return <T extends string | Boxed<string> | any[] | Boxed<any[]> | null | undefined>(value: T): ValidationErrors => {\r\n    value = unbox(value);\r\n\r\n    if (value === null || value === undefined) {\r\n      return {};\r\n    }\r\n\r\n    const length = (value as string | any[]).length;\r\n\r\n    if (length <= maxLengthParam) {\r\n      return {};\r\n    }\r\n\r\n    return {\r\n      maxLength: {\r\n        maxLength: maxLengthParam,\r\n        value: value as string,\r\n        actualLength: length,\r\n      },\r\n    };\r\n  };\r\n}\r\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\r\n\r\nexport interface MinLengthValidationError {\r\n  minLength: number;\r\n  value: string;\r\n  actualLength: number;\r\n}\r\n\r\n// @ts-ignore\r\ndeclare module 'ngrx-forms/src/state' {\r\n  export interface ValidationErrors {\r\n    minLength?: MinLengthValidationError;\r\n  }\r\n}\r\n\r\n/**\r\n * A validation function that requires a `string` or `array` value to have a minimum length.\r\n * Considers `null`, `undefined`, empty strings and empty arrays as valid. Combine this\r\n * function with the `required` validation function if these values should be considered invalid.\r\n *\r\n * The validation error returned by this validation function has the following shape:\r\n *\r\n```typescript\r\n{\r\n  minLength: {\r\n    minLength: number;\r\n    value: string;\r\n    actualLength: number;\r\n  };\r\n}\r\n```\r\n *\r\n * Usually you would use this validation function in conjunction with the `validate`\r\n * update function to perform synchronous validation in your reducer:\r\n *\r\n```typescript\r\nupdateGroup<MyFormValue>({\r\n  password: validate(minLength(8)),\r\n})\r\n```\r\n *\r\n * Note that this function is generic to allow the compiler to properly infer the type\r\n * of the `validate` function for both optional and non-optional controls.\r\n */\r\nexport function minLength(minLengthParam: number) {\r\n  // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)\r\n  if (minLengthParam === null || minLengthParam === undefined) {\r\n    throw new Error(`The minLength Validation function requires the minLength parameter to be a non-null number, got ${minLengthParam}!`);\r\n  }\r\n\r\n  return <T extends string | Boxed<string> | any[] | Boxed<any[]> | null | undefined>(value: T): ValidationErrors => {\r\n    value = unbox(value);\r\n\r\n    if (value === null || value === undefined) {\r\n      return {};\r\n    }\r\n\r\n    const length = (value as string | any[]).length;\r\n\r\n    if (length === 0) {\r\n      return {}; // don't validate empty values to allow optional controls\r\n    }\r\n\r\n    if (length >= minLengthParam) {\r\n      return {};\r\n    }\r\n\r\n    return {\r\n      minLength: {\r\n        minLength: minLengthParam,\r\n        value: value as string,\r\n        actualLength: length,\r\n      },\r\n    };\r\n  };\r\n}\r\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\r\n\r\nexport interface NotEqualToValidationError<T> {\r\n  comparand: T;\r\n  actual: T;\r\n}\r\n\r\n// @ts-ignore\r\ndeclare module 'ngrx-forms/src/state' {\r\n  export interface ValidationErrors {\r\n    notEqualTo?: NotEqualToValidationError<any>;\r\n  }\r\n}\r\n\r\n/**\r\n * A validation function that requires the value to be strictly not equal (i.e. `!==`)\r\n * to another value.\r\n *\r\n * The validation error returned by this validation function has the following shape:\r\n *\r\n```typescript\r\n{\r\n  notEqualTo: {\r\n    comparand: T;\r\n    actual: T;\r\n  };\r\n}\r\n```\r\n *\r\n * Usually you would use this validation function in conjunction with the `validate`\r\n * update function to perform synchronous validation in your reducer:\r\n *\r\n```typescript\r\nupdateGroup<MyFormValue>({\r\n  name: validate(notEqualTo('John Doe')),\r\n})\r\n```\r\n */\r\nexport function notEqualTo<T>(comparand: T) {\r\n  return <TV extends T | Boxed<T> = T>(value: TV): ValidationErrors => {\r\n    value = unbox(value) as T as TV;\r\n\r\n    if (value !== comparand) {\r\n      return {};\r\n    }\r\n\r\n    return {\r\n      notEqualTo: {\r\n        comparand,\r\n        actual: value,\r\n      },\r\n    };\r\n  };\r\n}\r\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\r\n\r\nexport interface PatternValidationError {\r\n  pattern: string;\r\n  actual: string;\r\n}\r\n\r\n// @ts-ignore\r\ndeclare module 'ngrx-forms/src/state' {\r\n  export interface ValidationErrors {\r\n    pattern?: PatternValidationError;\r\n  }\r\n}\r\n\r\n/**\r\n * A validation function that requires a value to match a regex.\r\n * Considers `null`, `undefined`, and `''` as valid. Combine this function with the\r\n * `required` validation function if these values should be considered invalid.\r\n *\r\n * The validation error returned by this validation function has the following shape:\r\n *\r\n```typescript\r\n{\r\n  pattern: {\r\n    pattern: string;\r\n    actual: string;\r\n  };\r\n}\r\n```\r\n *\r\n * Usually you would use this validation function in conjunction with the `validate`\r\n * update function to perform synchronous validation in your reducer:\r\n *\r\n```typescript\r\nupdateGroup<MyFormValue>({\r\n  numberWithPeriodsOrCommas: validate(pattern(/^[0-9.,]+$/)),\r\n})\r\n```\r\n *\r\n * Note that this function is generic to allow the compiler to properly infer the type\r\n * of the `validate` function for both optional and non-optional controls.\r\n */\r\nexport function pattern(patternParam: RegExp) {\r\n  // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)\r\n  if (patternParam === null || patternParam === undefined) {\r\n    throw new Error(`The pattern Validation function requires the pattern parameter to be a non-null string or regular expression, got ${patternParam}!`);\r\n  }\r\n\r\n  return <T extends string | Boxed<string> | null | undefined>(value: T): ValidationErrors => {\r\n    value = unbox(value) as string | null | undefined as T;\r\n\r\n    if (value === null || value === undefined || (value as string).length === 0) {\r\n      return {};\r\n    }\r\n\r\n    if (patternParam.test(value as string)) {\r\n      return {};\r\n    }\r\n\r\n    return {\r\n      pattern: {\r\n        pattern: patternParam.toString(),\r\n        actual: value as string,\r\n      },\r\n    };\r\n  };\r\n}\r\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\r\n\r\nexport interface RequiredValidationError<T> {\r\n  actual: T | null | undefined;\r\n}\r\n\r\n// @ts-ignore\r\ndeclare module 'ngrx-forms/src/state' {\r\n  export interface ValidationErrors {\r\n    required?: RequiredValidationError<any>;\r\n  }\r\n}\r\n\r\n/**\r\n * A validation function that requires the value to be non-`undefined`, non-'null',\r\n * and non-empty.\r\n *\r\n * The validation error returned by this validation function has the following shape:\r\n *\r\n```typescript\r\n{\r\n  required: {\r\n    actual: T | null | undefined;\r\n  };\r\n}\r\n```\r\n *\r\n * Usually you would use this validation function in conjunction with the `validate`\r\n * update function to perform synchronous validation in your reducer:\r\n *\r\n```typescript\r\nupdateGroup<MyFormValue>({\r\n  name: validate(required),\r\n})\r\n```\r\n */\r\nexport function required<T>(value: T | Boxed<T> | null | undefined): ValidationErrors {\r\n  value = unbox(value) as T | null | undefined;\r\n\r\n  if (value !== undefined && value !== null && (value as any).length !== 0) {\r\n    return {};\r\n  }\r\n\r\n  return {\r\n    required: {\r\n      actual: value,\r\n    },\r\n  };\r\n}\r\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\r\n\r\n/**\r\n * A validation function that requires the value to be `false`. Considers `null` and\r\n * `undefined` as valid. Combine this function with the `required` validation\r\n * function if `null` or `undefined` should be considered invalid.\r\n *\r\n * The validation error returned by this validation function has the following shape:\r\n *\r\n```typescript\r\n{\r\n  required: {\r\n    actual: boolean;\r\n  };\r\n}\r\n```\r\n *\r\n * Usually you would use this validation function in conjunction with the `validate`\r\n * update function to perform synchronous validation in your reducer:\r\n *\r\n```typescript\r\nupdateGroup<MyFormValue>({\r\n  disagreeWithTermsOfService: validate(requiredFalse),\r\n})\r\n```\r\n *\r\n * Note that this function is generic to allow the compiler to properly infer the type\r\n * of the `validate` function for both optional and non-optional controls.\r\n */\r\nexport function requiredFalse<T extends boolean | Boxed<boolean> | null | undefined>(value: T): ValidationErrors {\r\n  value = unbox(value) as boolean | null | undefined as T;\r\n\r\n  // tslint:disable-next-line:strict-type-predicates\r\n  if (value === null || value === undefined) {\r\n    return {};\r\n  }\r\n\r\n  if (!value) {\r\n    return {};\r\n  }\r\n\r\n  return {\r\n    required: {\r\n      actual: value,\r\n    },\r\n  };\r\n}\r\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\r\n\r\n/**\r\n * A validation function that requires the value to be `true`. Considers `null` and\r\n * `undefined` as valid. Combine this function with the `required` validation\r\n * function if `null` or `undefined` should be considered invalid.\r\n *\r\n * The validation error returned by this validation function has the following shape:\r\n *\r\n```typescript\r\n{\r\n  required: {\r\n    actual: boolean;\r\n  };\r\n}\r\n```\r\n *\r\n * Usually you would use this validation function in conjunction with the `validate`\r\n * update function to perform synchronous validation in your reducer:\r\n *\r\n```typescript\r\nupdateGroup<MyFormValue>({\r\n  agreeWithTermsOfService: validate(requiredTrue),\r\n})\r\n```\r\n *\r\n * Note that this function is generic to allow the compiler to properly infer the type\r\n * of the `validate` function for both optional and non-optional controls.\r\n */\r\nexport function requiredTrue<T extends boolean | Boxed<boolean> | null | undefined>(value: T): ValidationErrors {\r\n  value = unbox(value) as boolean | null | undefined as T;\r\n\r\n  // tslint:disable-next-line:strict-type-predicates\r\n  if (value === null || value === undefined) {\r\n    return {};\r\n  }\r\n\r\n  if (value) {\r\n    return {};\r\n  }\r\n\r\n  return {\r\n    required: {\r\n      actual: value,\r\n    },\r\n  };\r\n}\r\n","/**\r\n * ngrx-forms\r\n * Proper integration of forms in Angular applications using Ngrx\r\n * Written by Jonathan Ziller.\r\n * MIT license.\r\n * https://github.com/MrWolfZ/ngrx-forms\r\n */\r\nexport { email, EmailValidationError } from './src/email';\r\nexport { equalTo, EqualToValidationError } from './src/equal-to';\r\nexport { greaterThan, GreaterThanValidationError } from './src/greater-than';\r\nexport { greaterThanOrEqualTo, GreaterThanOrEqualToValidationError } from './src/greater-than-or-equal-to';\r\nexport { lessThan, LessThanValidationError } from './src/less-than';\r\nexport { lessThanOrEqualTo, LessThanOrEqualToValidationError } from './src/less-than-or-equal-to';\r\nexport { maxLength, MaxLengthValidationError } from './src/max-length';\r\nexport { minLength, MinLengthValidationError } from './src/min-length';\r\nexport { notEqualTo, NotEqualToValidationError } from './src/not-equal-to';\r\nexport { pattern, PatternValidationError } from './src/pattern';\r\nexport { required, RequiredValidationError } from './src/required';\r\nexport { requiredFalse } from './src/required-false';\r\nexport { requiredTrue } from './src/required-true';\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":[],"mappings":";;AAEA;;AAEA,AAAO,IAAM,kCAAkC,GAAG,4LAA4L,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0C/O,SAAgB,KAAK,CAAsD,KAAQ;IACjF,KAAK,GAAG,KAAK,CAAC,KAAK,CAAmC,CAAC;IAEvD,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,IAAK,KAAgB,CAAC,MAAM,KAAK,CAAC,EAAE;QAC3E,OAAO,EAAE,CAAC;KACX;IAED,IAAI,kCAAkC,CAAC,IAAI,CAAC,KAAe,CAAC,EAAE;QAC5D,OAAO,EAAE,CAAC;KACX;IAED,OAAO;QACL,KAAK,EAAE;YACL,OAAO,EAAE,kCAAkC,CAAC,QAAQ,EAAE;YACtD,MAAM,EAAE,KAAe;SACxB;KACF,CAAC;CACH;;ACjDD;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,SAAgB,OAAO,CAAI,SAAY;IACrC,OAAO,UAA8B,KAAS;QAC5C,KAAK,GAAG,KAAK,CAAC,KAAK,CAAY,CAAC;QAEhC,IAAI,KAAK,KAAK,SAAS,EAAE;YACvB,OAAO,EAAE,CAAC;SACX;QAED,OAAO;YACL,OAAO,EAAE;gBACP,SAAS,WAAA;gBACT,MAAM,EAAE,KAAK;aACd;SACF,CAAC;KACH,CAAC;CACH;;ACvCD;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,SAAgB,WAAW,CAAC,SAAiB;;IAE3C,IAAI,SAAS,KAAK,IAAI,IAAI,SAAS,KAAK,SAAS,EAAE;QACjD,MAAM,IAAI,KAAK,CAAC,uGAAqG,SAAS,MAAG,CAAC,CAAC;KACpI;IAED,OAAO,UAAsD,KAAQ;QACnE,KAAK,GAAG,KAAK,CAAC,KAAK,CAAmC,CAAC;QAEvD,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,EAAE;YACzC,OAAO,EAAE,CAAC;SACX;QAED,IAAI,KAAK,GAAG,SAAS,EAAE;YACrB,OAAO,EAAE,CAAC;SACX;QAED,OAAO;YACL,WAAW,EAAE;gBACX,SAAS,WAAA;gBACT,MAAM,EAAE,KAAe;aACxB;SACF,CAAC;KACH,CAAC;CACH;;ACpDD;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,SAAgB,oBAAoB,CAAC,SAAiB;;IAEpD,IAAI,SAAS,KAAK,IAAI,IAAI,SAAS,KAAK,SAAS,EAAE;QACjD,MAAM,IAAI,KAAK,CAAC,gHAA8G,SAAS,MAAG,CAAC,CAAC;KAC7I;IAED,OAAO,UAAsD,KAAQ;QACnE,KAAK,GAAG,KAAK,CAAC,KAAK,CAAmC,CAAC;QAEvD,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,EAAE;YACzC,OAAO,EAAE,CAAC;SACX;QAED,IAAI,KAAK,IAAI,SAAS,EAAE;YACtB,OAAO,EAAE,CAAC;SACX;QAED,OAAO;YACL,oBAAoB,EAAE;gBACpB,SAAS,WAAA;gBACT,MAAM,EAAE,KAAe;aACxB;SACF,CAAC;KACH,CAAC;CACH;;ACpDD;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,SAAgB,QAAQ,CAAC,SAAiB;;IAExC,IAAI,SAAS,KAAK,IAAI,IAAI,SAAS,KAAK,SAAS,EAAE;QACjD,MAAM,IAAI,KAAK,CAAC,oGAAkG,SAAS,MAAG,CAAC,CAAC;KACjI;IAED,OAAO,UAAsD,KAAQ;QACnE,KAAK,GAAG,KAAK,CAAC,KAAK,CAAmC,CAAC;QAEvD,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,EAAE;YACzC,OAAO,EAAE,CAAC;SACX;QAED,IAAI,KAAK,GAAG,SAAS,EAAE;YACrB,OAAO,EAAE,CAAC;SACX;QAED,OAAO;YACL,QAAQ,EAAE;gBACR,SAAS,WAAA;gBACT,MAAM,EAAE,KAAe;aACxB;SACF,CAAC;KACH,CAAC;CACH;;ACpDD;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,SAAgB,iBAAiB,CAAC,SAAiB;;IAEjD,IAAI,SAAS,KAAK,IAAI,IAAI,SAAS,KAAK,SAAS,EAAE;QACjD,MAAM,IAAI,KAAK,CAAC,6GAA2G,SAAS,MAAG,CAAC,CAAC;KAC1I;IAED,OAAO,UAAsD,KAAQ;QACnE,KAAK,GAAG,KAAK,CAAC,KAAK,CAAmC,CAAC;QAEvD,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,EAAE;YACzC,OAAO,EAAE,CAAC;SACX;QAED,IAAI,KAAK,IAAI,SAAS,EAAE;YACtB,OAAO,EAAE,CAAC;SACX;QAED,OAAO;YACL,iBAAiB,EAAE;gBACjB,SAAS,WAAA;gBACT,MAAM,EAAE,KAAe;aACxB;SACF,CAAC;KACH,CAAC;CACH;;ACnDD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,SAAgB,SAAS,CAAC,cAAsB;;IAE9C,IAAI,cAAc,KAAK,IAAI,IAAI,cAAc,KAAK,SAAS,EAAE;QAC3D,MAAM,IAAI,KAAK,CAAC,qGAAmG,cAAc,MAAG,CAAC,CAAC;KACvI;IAED,OAAO,UAA6E,KAAQ;QAC1F,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;QAErB,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,EAAE;YACzC,OAAO,EAAE,CAAC;SACX;QAED,IAAM,MAAM,GAAI,KAAwB,CAAC,MAAM,CAAC;QAEhD,IAAI,MAAM,IAAI,cAAc,EAAE;YAC5B,OAAO,EAAE,CAAC;SACX;QAED,OAAO;YACL,SAAS,EAAE;gBACT,SAAS,EAAE,cAAc;gBACzB,KAAK,EAAE,KAAe;gBACtB,YAAY,EAAE,MAAM;aACrB;SACF,CAAC;KACH,CAAC;CACH;;ACxDD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,SAAgB,SAAS,CAAC,cAAsB;;IAE9C,IAAI,cAAc,KAAK,IAAI,IAAI,cAAc,KAAK,SAAS,EAAE;QAC3D,MAAM,IAAI,KAAK,CAAC,qGAAmG,cAAc,MAAG,CAAC,CAAC;KACvI;IAED,OAAO,UAA6E,KAAQ;QAC1F,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;QAErB,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,EAAE;YACzC,OAAO,EAAE,CAAC;SACX;QAED,IAAM,MAAM,GAAI,KAAwB,CAAC,MAAM,CAAC;QAEhD,IAAI,MAAM,KAAK,CAAC,EAAE;YAChB,OAAO,EAAE,CAAC;SACX;QAED,IAAI,MAAM,IAAI,cAAc,EAAE;YAC5B,OAAO,EAAE,CAAC;SACX;QAED,OAAO;YACL,SAAS,EAAE;gBACT,SAAS,EAAE,cAAc;gBACzB,KAAK,EAAE,KAAe;gBACtB,YAAY,EAAE,MAAM;aACrB;SACF,CAAC;KACH,CAAC;CACH;;AC7DD;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,SAAgB,UAAU,CAAI,SAAY;IACxC,OAAO,UAA8B,KAAS;QAC5C,KAAK,GAAG,KAAK,CAAC,KAAK,CAAY,CAAC;QAEhC,IAAI,KAAK,KAAK,SAAS,EAAE;YACvB,OAAO,EAAE,CAAC;SACX;QAED,OAAO;YACL,UAAU,EAAE;gBACV,SAAS,WAAA;gBACT,MAAM,EAAE,KAAK;aACd;SACF,CAAC;KACH,CAAC;CACH;;ACvCD;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,SAAgB,OAAO,CAAC,YAAoB;;IAE1C,IAAI,YAAY,KAAK,IAAI,IAAI,YAAY,KAAK,SAAS,EAAE;QACvD,MAAM,IAAI,KAAK,CAAC,uHAAqH,YAAY,MAAG,CAAC,CAAC;KACvJ;IAED,OAAO,UAAsD,KAAQ;QACnE,KAAK,GAAG,KAAK,CAAC,KAAK,CAAmC,CAAC;QAEvD,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,IAAK,KAAgB,CAAC,MAAM,KAAK,CAAC,EAAE;YAC3E,OAAO,EAAE,CAAC;SACX;QAED,IAAI,YAAY,CAAC,IAAI,CAAC,KAAe,CAAC,EAAE;YACtC,OAAO,EAAE,CAAC;SACX;QAED,OAAO;YACL,OAAO,EAAE;gBACP,OAAO,EAAE,YAAY,CAAC,QAAQ,EAAE;gBAChC,MAAM,EAAE,KAAe;aACxB;SACF,CAAC;KACH,CAAC;CACH;;ACrDD;;;;;;;;;;;;;;;;;;;;;;;AAuBA,SAAgB,QAAQ,CAAI,KAAsC;IAChE,KAAK,GAAG,KAAK,CAAC,KAAK,CAAyB,CAAC;IAE7C,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,IAAI,IAAK,KAAa,CAAC,MAAM,KAAK,CAAC,EAAE;QACxE,OAAO,EAAE,CAAC;KACX;IAED,OAAO;QACL,QAAQ,EAAE;YACR,MAAM,EAAE,KAAK;SACd;KACF,CAAC;CACH;;AC9CD;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,SAAgB,aAAa,CAAwD,KAAQ;IAC3F,KAAK,GAAG,KAAK,CAAC,KAAK,CAAoC,CAAC;;IAGxD,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,EAAE;QACzC,OAAO,EAAE,CAAC;KACX;IAED,IAAI,CAAC,KAAK,EAAE;QACV,OAAO,EAAE,CAAC;KACX;IAED,OAAO;QACL,QAAQ,EAAE;YACR,MAAM,EAAE,KAAK;SACd;KACF,CAAC;CACH;;AC5CD;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,SAAgB,YAAY,CAAwD,KAAQ;IAC1F,KAAK,GAAG,KAAK,CAAC,KAAK,CAAoC,CAAC;;IAGxD,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,EAAE;QACzC,OAAO,EAAE,CAAC;KACX;IAED,IAAI,KAAK,EAAE;QACT,OAAO,EAAE,CAAC;KACX;IAED,OAAO;QACL,QAAQ,EAAE;YACR,MAAM,EAAE,KAAK;SACd;KACF,CAAC;CACH;;AC9CD;;;;;;GAMG;;ACNH;;GAEG;;;;"}